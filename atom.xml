<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Allen&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/d8e88e3eadbeb30ba0a0441af5b05c02</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://allenn.cn/"/>
  <updated>2018-05-11T15:05:19.809Z</updated>
  <id>http://allenn.cn/</id>
  
  <author>
    <name>Allen Zheng</name>
    <email>xudongzheng1225@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决 Windows10 笔记本关上后仍会掉电的问题</title>
    <link href="http://allenn.cn/articles/2018-05/2018-05-11-win10_sleep/"/>
    <id>http://allenn.cn/articles/2018-05/2018-05-11-win10_sleep/</id>
    <published>2018-05-10T16:00:00.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>一开始我只是想在谷歌上搜索一下，为啥我的 Win10 笔记本在盖上盖子以后放入背包中，每次拿出来之后电量都会有所下降，结果就一下子看到了很多很神奇的东西，包括 Win10 的几种节能状态，以及如何设置关闭盖子的行为。且听我一一道来。</p><a id="more"></a><h2 id="Win10-节能状态"><a href="#Win10-节能状态" class="headerlink" title="Win10 节能状态"></a>Win10 节能状态</h2><p>总的来讲，自 Win7 到 Win8 到 Win10 以来，Windows 实际上一共有 3 种不同的节能状态，可参考该<a href="http://www.thewindowsclub.com/difference-between-sleep-hybrid-sleep-and-hibernation-in-windows-7" target="_blank" rel="noopener">链接</a>。链接中的文章很好地介绍了这 3 种状态，这里我就复制过来顺便简单翻译一下。</p><blockquote><p><strong>Sleep</strong> is a power-saving state that allows a computer to quickly resume full-power operation (typically within several seconds) when you want to start working again.</p><p>Putting your computer into the sleep state is like pausing a DVD player; the computer immediately stops what it ’ s doing and is ready to start again when you want to resume working.</p></blockquote><p><strong>睡眠</strong>（Sleep）可以让计算机在你想要开始工作时迅速（通常在几秒钟内）恢复至全速运行状态。让你的计算机进入睡眠模式就像在 DVD 播放机上按下暂停按钮一样 —— 计算机会立刻停止它的当前任务并且随时准备好在你回来工作时再次启动。</p><blockquote><p><strong>Hibernation</strong> is a power-saving state designed primarily for laptops.</p><p>While sleep puts your work and settings in memory and draws a small amount of power, hibernation puts your open documents and programs on your hard disk and then turns off your computer. Of all the power-saving states in Windows, hibernation uses the least amount of power. On a laptop, use hibernation when you know that you won ’ t use your laptop for an extended period and won ’ t have an opportunity to charge the battery during that time.</p></blockquote><p><strong>休眠</strong>（Hibernation）是一种主要为笔记本电脑设计的节能状态。睡眠实际上会把你当前的工作内容和设置放入到内存中，并且需要少量的电力来维持这些数据，而相比之下休眠则会把这些数据放入到磁盘中然后完全关闭你的计算机。在 Windows 中，休眠实际上是所需电力最少的节能状态。如果你使用的是笔记本电脑，那么如果你在一段较长的时间内都不会再使用你的电脑且这段时间也无法给它充电的话，你应该让它进入休眠状态。</p><blockquote><p><strong>Hybrid sleep</strong> is designed primarily for desktop computers. Hybrid sleep is a combination of sleep and hibernate; it puts any open documents and programs in memory and on your hard disk and then puts your computer into a low-power state so that you can quickly resume your work. That way, if a power failure occurs, Windows can restore your work from your hard disk. When hybrid sleep is turned on, putting your computer into sleep automatically puts your computer into hybrid sleep. <em>Hybrid sleep is typically turned on by default on desktop computers and off by default on laptops</em>.</p></blockquote><p><strong>混合睡眠</strong>（Hybrid Sleep）是一种主要为桌面电脑（台式机）设计的节能状态。混合睡眠实际上是睡眠与休眠的结合：它会把当前的工作内容继续保持在内存中，同时也把这些数据复制到磁盘中，然后再让你的计算机进入低耗能状态，如此一来你的计算机便可以快速地恢复当前状态，同时及时发生电力故障，Windows 仍然可以从磁盘中恢复当前的数据。在混合睡眠设置开启时，你令计算机进入睡眠模式时会让计算机自动进入混合睡眠模式。混合睡眠在桌面电脑上是默认开启的，而在笔记本电脑上则是默认关闭的。</p><h2 id="设置-Win10-关闭盖子行为"><a href="#设置-Win10-关闭盖子行为" class="headerlink" title="设置 Win10 关闭盖子行为"></a>设置 Win10 关闭盖子行为</h2><p>“关闭盖子” 这个词听着有点怪，而部分 Win10 用户实际上也应该在电源选项中见过这个名字：</p><p><img src="/assets/images/2018-05-11-win10_sleep/win10@1.png" alt=""></p><p>实际上这个翻译也是挺奇怪的，而该选项的英文实际上是 “ Choose what closing the lid does ”，也就是配置电脑在盖上时应该做什么。</p><p>进入该页面，可看到设置如下：</p><p><img src="/assets/images/2018-05-11-win10_sleep/win10@2.png" alt=""></p><p>这里可以选择在接通与未接通电源两种情况下，按下电源按钮和关闭盖子时计算机应该采取的行为。选项包括 “不采取任何操作”、“睡眠”、“休眠”、“关机”，在了解过 “睡眠” 和 “休眠” 的差异后，我想这四个选项的含义就不难理解了。我们只要将<strong>关闭盖子时</strong>的行为设置为<strong>休眠</strong>即可。</p><p>实际上，“关闭盖子时”的设置默认为“睡眠”，而该模式仍需要一定的电力维持内存中的数据，而且睡眠状态下的笔记本极易被唤醒（被鼠标、键盘、定时事件等唤醒），因此这也就是为何大多数 Win10 笔记本经常在盖子关上时自行启动了。可见这并不是一个 Bug，而只是单纯的设置不当。</p><p>不过值得注意的是，休眠后的计算机无法在短时间内恢复。进入睡眠模式的计算机在恢复时往往能在瞬间进入登录界面，而进入休眠模式的计算机由于需要从磁盘中读取数据，往往需要经历一段和开机相当的时间。当然，如果你的计算机使用的是 SSD，这个不足则微乎其微。</p><p>从上一节中对睡眠和休眠的描述来看，你可以在确定自己比较长时间内不会使用计算机时才选择让计算机进入休眠，如果离开的时间较短则可以选择让其进入睡眠。因此，可以在上述设置中选择在按下电源按钮时让计算机进入睡眠状态，这样如果你只是要短时间离开计算机（上厕所、倒杯水等），就可以考虑按下电源按钮进入睡眠，而不是直接盖上计算机。</p><p>除此之外，在使用休眠模式时要尤其小心：休眠模式在恢复时需要把磁盘上的数据重新读入到内存，考虑到 Win10 的高兼容性，实际上这个过程很容易发生错误导致部分软件无法恢复到原本的状态继续运行，因此恢复时很容易导致部分驱动程序崩溃，令计算机发生所谓的“蓝屏”现象。休眠模式的不稳定实际上自 Win7 以来便一直存在，Win10 也无法幸免，有较小几率仍会“蓝屏”，但相比 Win7 已有很大的改善。我想，这算是我们选择了 Win10 相比于 Mac OS 高得多的兼容性后所必须承受的代价吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一开始我只是想在谷歌上搜索一下，为啥我的 Win10 笔记本在盖上盖子以后放入背包中，每次拿出来之后电量都会有所下降，结果就一下子看到了很多很神奇的东西，包括 Win10 的几种节能状态，以及如何设置关闭盖子的行为。且听我一一道来。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://allenn.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Windows 10" scheme="http://allenn.cn/tags/Windows-10/"/>
    
      <category term="睡眠" scheme="http://allenn.cn/tags/%E7%9D%A1%E7%9C%A0/"/>
    
      <category term="休眠" scheme="http://allenn.cn/tags/%E4%BC%91%E7%9C%A0/"/>
    
  </entry>
  
  <entry>
    <title>一起 Static 和 Synchronized 引发的血案</title>
    <link href="http://allenn.cn/articles/2017-09/2017-09-03-static-synchronized-accident/"/>
    <id>http://allenn.cn/articles/2017-09/2017-09-03-static-synchronized-accident/</id>
    <published>2017-09-03T08:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在定位一个网上问题的时候发现一个很诡异的现象，系统夜间的汇总任务跑了很长一段时间才能结束，而且日志显示这些汇总任务的每个子任务都很快就结束了，但整体任务还是耗费了很长一段时间才结束。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub-job 1 done in 3s</span><br><span class="line">sub-job 2 done in 3s</span><br><span class="line">sub-job 3 done in 2s</span><br><span class="line">sub-job 4 done in 5s</span><br><span class="line">sub-job 5 done in 6s</span><br><span class="line">sub-job 6 done in 8s</span><br><span class="line">sub-job 7 done in 9s</span><br><span class="line">...</span><br><span class="line">whole process is down in 3235s</span><br></pre></td></tr></table></figure><a id="more"></a><p>其实整体业务流程很简单，大致的流程就是系统创建了很多汇总任务，把它们丢到线程池中去执行。这些任务在执行的过程中，为了提高效率，会创建一些子任务并并发的运行它们，当子任务运行结束后，父任务就会结束，所以出现这种现象是非常不科学的。我的第一感觉就是是不是任务间存在不合理的锁竞争导致线程相互等待？仔细检查代码，果然发现了问题，在汇总任务的父类中有这样一个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="title">format</span><span class="params">(DateTime dt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"P"</span> + dt.toString(<span class="string">"yyyyMMHHmmss"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是汇总任务根据时间生成目标汇总时间周期用的，之所以会封装成一个方法，估计是为了代码复用考虑。封装本身并没有错，但是要命的是，开发人员将方法声明为<code>static synchronized</code>，让我们先回忆一下这个两个关键字的作用：</p><ul><li><p>synchronized</p><p>synchronized 关键字放在方法声明上时，表示该方法为<code>Synchronized Methods</code>，即同步方法，在<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html" target="_blank" rel="noopener">The Java™ Tutorials</a>中对同步方法有以下描述：</p><blockquote><p>First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object.</p></blockquote><blockquote><p>Second, when a synchronized method exits, it automatically establishes a happens-before relationship with any subsequent invocation of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads.</p></blockquote><p>简单来说就是当一个方法声明为同步方法的时候，不可能出现多个线程同时调用同一个对象（注意是同一个对象，这点很重要）上的该方法，只有当一个线程调用结束，其他线程才有可能获取锁并执行该方法。</p></li><li><p>static</p><p>在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。</p></li></ul><p>那么<code>synchronized</code>加上<code>static</code>会出现什么效果？按照上面的分析<code>static</code>是整个类共享的，不仅仅是一个对象，那么<code>static synchronized</code>修饰的变量、方法或者代码段就是在类的粒度上进行同步，而不是仅仅是在对象粒度上。对于这个问题，<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3.6" target="_blank" rel="noopener">Java machine language specification</a>中也有描述：</p><blockquote><p>For a class (static) method, the monitor associated with the Class object for the method’s class is used.</p></blockquote><blockquote><p>For an instance method, the monitor associated with this (the object for which the method was invoked) is used.</p></blockquote><p>所以在我们的业务代码中，如果在父类中声明了一个<code>static synchronized</code>的方法，就意味着每个继承它的子类及其对象在调用这个方法时都会争夺这个锁，那么造成任务执行效率低下也就是必然的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在定位一个网上问题的时候发现一个很诡异的现象，系统夜间的汇总任务跑了很长一段时间才能结束，而且日志显示这些汇总任务的每个子任务都很快就结束了，但整体任务还是耗费了很长一段时间才结束。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sub-job 1 done in 3s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub-job 2 done in 3s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub-job 3 done in 2s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub-job 4 done in 5s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub-job 5 done in 6s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub-job 6 done in 8s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub-job 7 done in 9s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;whole process is down in 3235s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://allenn.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>解决在 IntelliJ IDEA 时，搜狗输入法不跟随问题</title>
    <link href="http://allenn.cn/articles/2017-08/2017-08-06-fix-sougou-intellij-compatibility/"/>
    <id>http://allenn.cn/articles/2017-08/2017-08-06-fix-sougou-intellij-compatibility/</id>
    <published>2017-08-06T08:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>最近从华为离职并入职了新的公司，在新领的电脑配置好开发环境后就开始愉快的打码。可是在我要输入中文注释的时候，发现在 IDE 里面没法正常使用搜狗输入法，表现为输入法候选框不跟随光标，输入后不弹出候选字。</p><p><img src="/assets/images/2017-08-06-fix-sougou-intellij-compatibility/screen_print.png" alt="输入法不跟随"></p><a id="more"></a><p>其实候选框不跟随光标还好，但无法弹出候选字确实没法忍，总不能不写注释或者全部用英文写注释吧。这么干的话，后面的维护者一定会有想砍死我的想法。尝试了重装或者升级输入法，均没有解决。这个版本的 IDEA 之前也用过，也没有碰到这个输入法的问题，仔细想了下配置的差异，之前我喜欢把 IDEA 自身使用的 JDK 设置为系统中已经安装的那一个，而这次为了图省事就没指定，那会不会是这个原因导致的？果然，切换后问题解决。</p><p>关于如何设置 IDEA 的 JDK 的问题，Jetbrains 有一份<a href="https://intellij-support.jetbrains.com/hc/en-us/articles/206544879-Selecting-the-JDK-version-the-IDE-will-run-under" target="_blank" rel="noopener">官方文档</a>可以供大家参考，我给大家简要说明一下：</p><ul><li>打开 IDEA 使用 <code>Help | Find Action</code>(可以使用快捷键 ：Ctrl+Shift+A 或者 Cmd+Shift+A Mac平台) ，输入<code>Switch IDE Boot JDK</code>，按下回车；</li><li><code>Switch IDE Boot JDK dialog</code> 对话框会弹出来，在对话框中选择系统安装的 JDK 或者直接输入 JDK 的路径 (比如 c:\Program Files (x86)\Java\jdk1.8.0_112 或者 /Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home/ or /usr/lib/jvm/open-jdk)。</li><li>点击 OK，并重启 IDEA 客户端，重启后打开 About IntelliJ IDEA 看看 JDK 是否设置成功，见下图：</li></ul><p><img src="/assets/images/2017-08-06-fix-sougou-intellij-compatibility/android-studio_jdk_8u131.png" alt="About Page"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近从华为离职并入职了新的公司，在新领的电脑配置好开发环境后就开始愉快的打码。可是在我要输入中文注释的时候，发现在 IDE 里面没法正常使用搜狗输入法，表现为输入法候选框不跟随光标，输入后不弹出候选字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2017-08-06-fix-sougou-intellij-compatibility/screen_print.png&quot; alt=&quot;输入法不跟随&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="IntelliJ" scheme="http://allenn.cn/tags/IntelliJ/"/>
    
      <category term="搜狗输入法" scheme="http://allenn.cn/tags/%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Integer的highestOneBit方法源码解析</title>
    <link href="http://allenn.cn/articles/2017-05/2017-05-25-Integer-highestOneBit/"/>
    <id>http://allenn.cn/articles/2017-05/2017-05-25-Integer-highestOneBit/</id>
    <published>2017-05-25T08:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>在读HashMap源码的时候，遇到了Integer的highestOneBit静态方法不是太理解，所以就读了一下源码，这里记录一下。</p><p>JDK的注释中说</p><blockquote><p>返回具有至多單個 1 位的 int 值，在指定的 int 值中最高位（最左邊）的 1 位的位置。如果指定的值在其二進制補碼表示形式中不具有 1 位，即它等於零，則返回零。</p></blockquote><p>用人话说</p><ul><li>如果一个数是0, 则返回0；</li><li>如果是负数, 则返回 -2147483648：【1000,0000,0000,0000,0000,0000,0000,0000】(二進制表示的數)；</li><li>如果是正数, 返回的则是跟它最靠近的比它小的2的N次方</li></ul><a id="more"></a><p>比如 17：</p><p>二进制是【0000,0000,0000,0000,0000,0000,0001,0001】</p><p>highestOneBit(17)返回的是最高位的1个1, 其它全是0 的二进制數：【0000,0000,0000,0000,0000,0000,0001,0000】，其实就是16。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个整数（二进制）设置最高位为1，其它位为0，然后返回改变后的值</span></span><br><span class="line"><span class="comment"> * 如果这个整数是0返回0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 例如1000</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>); <span class="comment">// 使前2位变为1，相当于i = i | (i &gt;&gt; 1); i = 1000 | 0100 = 1100</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>); <span class="comment">// 使前4位变为1，由于上一步确保了前两位都是1，所以这一次移动两位，1111</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>); <span class="comment">// 使前8位变为1，1111</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>); <span class="comment">// 使前16位变为1，1111</span></span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>); <span class="comment">// 使前32位变为1，1111</span></span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// i &gt;&gt;&gt; 1 无符号右移，使最高位为0，其余位为1，相减即得出结果，1111 - 0111 = 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>”|“是按位操作符的或操作符，按位操作符有与操作符（&amp;），或操作符（|），异或操作符（^），取反操作符（~），其中运算规则如下：</p><ul><li>&amp;：两个输入位都为1才会输出1，否则输出0，如：10 &amp; 11 -&gt; 10</li><li>|：有一个输入位为1就会输出1，如：100 | 110 -&gt; 110</li><li>^：如果输入为的某一个是1，但不全都是1，那么输出1，如：110 ^ 100 -&gt; 010</li><li>~：这个就不用说了吧</li></ul></li><li><p>”&gt;&gt;&gt;“是无符号右移操作符，移位操作符分为有符号左移位操作符（&lt;&lt;）、有符号右移位操作符（&gt;&gt;）、无符号右移操作符（&gt;&gt;&gt;）。<br>有符号左移时低位补0；有符号右移时，若符号为正则高位补0，反之补1；无符号右移操作符无论正负都在高位补0.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在读HashMap源码的时候，遇到了Integer的highestOneBit静态方法不是太理解，所以就读了一下源码，这里记录一下。&lt;/p&gt;
&lt;p&gt;JDK的注释中说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;返回具有至多單個 1 位的 int 值，在指定的 int 值中最高位（最左邊）的 1 位的位置。如果指定的值在其二進制補碼表示形式中不具有 1 位，即它等於零，則返回零。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用人话说&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个数是0, 则返回0；&lt;/li&gt;
&lt;li&gt;如果是负数, 则返回 -2147483648：【1000,0000,0000,0000,0000,0000,0000,0000】(二進制表示的數)；&lt;/li&gt;
&lt;li&gt;如果是正数, 返回的则是跟它最靠近的比它小的2的N次方&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="JDK 源码" scheme="http://allenn.cn/tags/JDK-%E6%BA%90%E7%A0%81/"/>
    
      <category term="Collection" scheme="http://allenn.cn/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>Ubnt UniFi 产品开箱</title>
    <link href="http://allenn.cn/articles/2017-04/2017-04-30-new-home-network-structure/"/>
    <id>http://allenn.cn/articles/2017-04/2017-04-30-new-home-network-structure/</id>
    <published>2017-04-30T08:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>家里的无线网络覆盖一直有些问题，虽然说已经在家里部署了两个无线AP，但是还是一些小问题，首先信号覆盖还是有一些死角，比如说，卫生间，一进卫生间，信号强度瞬间掉到只有一格；其次就是两个 AP 之间相互协作好像有点问题，经常出现终端在 AP 1 的旁边，却连接到了 AP 2 上，只能手动断开 Wi-Fi，并重新连接。虽然说，这不是什么大问题，但对于一个有强迫症的 IT 男来说，这就像背痒一样，不挠一下不舒服。于是，我就打算把家里的无线网络改造一下。</p><a id="more"></a><h1 id="一些背景和需求"><a href="#一些背景和需求" class="headerlink" title="一些背景和需求"></a>一些背景和需求</h1><p>先放一下家里的户型图，家虽然不算很大，正常来说，这样的户型靠一个普通的无线路由器就能完成全屋的覆盖。但是这套房子有点特殊，房间的墙不是普通的那种空心砖，全是钢筋混凝土浇筑的墙，不管路由器放在哪个房间，总有地方覆盖不到。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/huxingtu.png" alt="户型图"></p><p>鉴于这种原因，就只能采用有线路由器加多个无线 AP 的网络结构，下面是我家网络原有的拓扑图。客厅和弱电箱之间，由于只拉了一条网线，而且我们家电视用的是电信的IPTV，所以只能通过划分不同的 VLAN 来达到一条网线跑两路数据的要求。其实大的网络结构上并没有什么问题，就是两个无线 AP 之间的协同有点让人闹心，所以这次网络改造的主要重点就是解决多个无线 AP 之间的协同问题。</p><h1 id="器材选择"><a href="#器材选择" class="headerlink" title="器材选择"></a>器材选择</h1><p>在这之前其实做过很多功课，传统的解决方案一般都是瘦 AP 加上 AC 控制器，但是这种方案并不适合于我。首先，市面上并没有太多面向家庭或者小企业的廉价 AC + 瘦 AP 解决方案，向华为、思科这种牌子，一个 AP 就要 2K 左右，AC 控制器更是天价；其次，弱电箱太小了，里面已经塞了一台光猫，一台路由器和一个交换机了，实在是再也塞不下一个 AC 控制器了。</p><p>前段时间 Ubnt 面向家用市场推出了一个 Wi-Fi Mesh 解决方案：Amplifi Wi-Fi。路由器和扩展点之间的连接走的是无线，省去了拉网线的烦恼，整个产品整体颜值也高，而且由于是全套解决方案，扩展点之间的协作就更加没有问题了。对于这个产品，我曾经有种草了很久，但是最近看到各路评测的开箱，发现这个产品根本不支持 VLAN 这就没法满足我看 IPTV 的需求了，而且扩展点和主路由之间的无线通讯肯定没有有线来的快，所以只能 PASS 这个产品。</p><p>后来我把目光放到了 Ubnt 的 UniFi 产品上，UniFi 的 AP 有个特点，就是可以用软 AC 进行控制，而且不要求 AC 实时在线。使用软 AC 配置好网络后，关闭 AC，整个网络依然可以正常工作，这样就省去了需要硬 AC的烦恼。而且现在家里用的路由器也是 Ubnt 的产品，本着凑一套的思路，我最终选择了 Ubnt UniFi。</p><h1 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h1><p>通过万能的淘宝购买了三件 Ubnt 产品：UBNT US-8-60W 千兆 PoE 交换机、UBNT UAP-AC LITE 吸顶 PoE 无线 AP 和 UBNT UAP-AC-IW 入墙面板无线 AP，整套价格 2K 出头。好了，下面正式进入开箱环节。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2384.jpg" alt="开箱"></p><p>第一个出场的是交换机，因为两个 AP 都需要 PoE 供电，所以一个具备 PoE 输出功能的交换机不可或缺。产品的包装盒十分简洁，没有什么多余的东西，盒子里面的附件除了机器本体外，还有一个 220V 的电源和一个简要的安装说明。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2378.jpg" alt="UBNT US-8-60W 千兆PoE网管型交换机"></p><p>将交换机装入弱电箱，接上电源和路由器之间的网线。请忽略杂乱的布线，开发商装的弱电箱不是怎么给力，所以也就懒得去折腾了。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2380.jpg" alt="弱电箱"></p><p>接下来是 UBNT UAP-AC LITE，产品包装同样很简洁，飞碟型的造型也很漂亮。家用的话买 LITE 也就足够了，尺寸比较小巧一点。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2376.jpg" alt="吸顶天线"></p><p>安装后的效果，别问我为什么吸顶天线不吸顶，因为天花板上没有预留网线，就那么简单。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2385.jpg" alt="吸顶天线安装"></p><p>最后一个出场的就是 UBNT UAP-AC-IW，它是 Ubnt 的一款新产品，以前 Ubnt 也有一款入墙式无线 AP，但是那货不支持国内的 86 盒，所以没法用。这个面板有三部分组成，安装底座、AP 本体和外盖板。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2401.jpg" alt="面板外包装"></p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2402.jpg" alt="面板"></p><p>先将面板底座装到 86 盒上</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2403.jpg" alt="面板底座"></p><p>接好线，盖上面板后的效果</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2405.jpg" alt="面板安装完成"></p><p>一切安装就绪后，就可以用 UniFi Controller 来配置网络了。</p><h1 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h1><p>先到 Ubnt 官方网站将 UniFi Controller 软件下载好，并在电脑上安装。安装后，启动控制器，就可以开始配置网络了。刚开始需要配置时区信息。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/setup-timezoom.png" alt="配置时区"></p><p>然后下一页就能看见设备上线了。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/ap-online.png" alt="选择设备"></p><p>设置好 Wi-Fi 信息</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/ap-online.png" alt="设置Wi-Fi"></p><p>接下来设置好软件登陆信息就可以进入软件主界面了</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/login-page.png" alt="主页"></p><p><img src="/assets/images/2017-04-30-new-home-network-structure/home-page.png" alt="主页"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整套产品安装部署过程还是比较简单的，通过 UniFi Controller 可以集中管理网络中的 UniFi 设备，包括 AP 和交换机，省去了单独登陆各个设备单独进行配置的麻烦。两个 AP 在覆盖方面的表现也非常棒，房间中再也没有信号死角，而且设备在房间中移动也再也没有之前那种网络闪断的情况，这让我非常满意。</p><p><img src="/assets/images/2017-04-30-new-home-network-structure/IMG_2415.jpg" alt="覆盖情况"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;家里的无线网络覆盖一直有些问题，虽然说已经在家里部署了两个无线AP，但是还是一些小问题，首先信号覆盖还是有一些死角，比如说，卫生间，一进卫生间，信号强度瞬间掉到只有一格；其次就是两个 AP 之间相互协作好像有点问题，经常出现终端在 AP 1 的旁边，却连接到了 AP 2 上，只能手动断开 Wi-Fi，并重新连接。虽然说，这不是什么大问题，但对于一个有强迫症的 IT 男来说，这就像背痒一样，不挠一下不舒服。于是，我就打算把家里的无线网络改造一下。&lt;/p&gt;
    
    </summary>
    
      <category term="网络技术" scheme="http://allenn.cn/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Ubnt" scheme="http://allenn.cn/tags/Ubnt/"/>
    
      <category term="Wi-Fi" scheme="http://allenn.cn/tags/Wi-Fi/"/>
    
      <category term="无线覆盖" scheme="http://allenn.cn/tags/%E6%97%A0%E7%BA%BF%E8%A6%86%E7%9B%96/"/>
    
  </entry>
  
  <entry>
    <title>Fetch Size 与 JDBC 内存管理</title>
    <link href="http://allenn.cn/articles/2016-12/2016-12-13-fetchsize-jdbc-memory/"/>
    <id>http://allenn.cn/articles/2016-12/2016-12-13-fetchsize-jdbc-memory/</id>
    <published>2016-12-13T08:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>接触到 JDBC 的 Fetch Size 这个属性缘起一个性能问题，项目中需要将一个有千万级数据量的表中的记录导出到文件中去。按照正常的路数，先初始化连接；接着写好 SQL 语句，比如<code>SELECT * FROM DIM_USERS</code>；然后启动查询，拿到 ResultSet，最后遍历 ResultSet 将每行记录输出到文件中去。可在接下来的测试中，发现性能并不理想，在表中数据量小的时候，执行速度尚可接受，可是在进行大数据量压力测试的时候，发现代码往往要执行40分钟以上，这在实际生产环境上是万万不可接受的。</p><a id="more"></a><p>通过定位，发现性能瓶颈出现在从数据库中读取数据的时候，大概消耗了90%以上的时间。也就是说如果什么事情都不干，单纯对一个千万级数据量的 ResultSet 进行一次遍历就需要耗时35分钟以上。这样一来，问题就变得让人有点费解了，因为在同一套环境上，服务器向数据库写入数据的速率可以达到3万+/秒，为何查询变得如此低效？正在我百思不得其解的时候，一个大神走过来拍怕我的肩膀说：“小伙子，试试把 Fetch Size 调整一下。”</p><h2 id="Fetch-Size"><a href="#Fetch-Size" class="headerlink" title="Fetch Size"></a>Fetch Size</h2><p>在 JDBC 中 Fetch Size 是 Statement 上的一个属性，先看下<a href="https://docs.oracle.com/cd/E11882_01/java.112/e16548/resltset.htm#JJDBC28621" target="_blank" rel="noopener">Oracle 的帮助文档</a>对它是怎么定义的：</p><blockquote><p>By default, when Oracle JDBC executes a query, it receives the result set 10 rows at a time from the database cursor. This is the default Oracle row-prefetch value. You can change the number of rows retrieved with each trip to the database cursor by changing the row-prefetch value</p></blockquote><p>简单的说，这个属性控制了 JDBC 每次读取数据的行数，由于 JDBC 每次都要通过网络去读取数据，如果这个值配置得太小，那么就意味着在遍历 ResultSet 的时候 JDBC 需要频繁的通过网络读取数据，这就导致了读取数据时性能低下。那接下来的问题就简单了，就是将这个属性调大。可是调整到多少合适呢？1K、2K？还是1W、2W？要知道 JDBC 每次读取的数据是会缓存在内存中的，如果这个属性设置大了，就会使程序出现 OOM。</p><h2 id="JDBC-Memory"><a href="#JDBC-Memory" class="headerlink" title="JDBC Memory"></a>JDBC Memory</h2><p>接下来就得聊聊 JDBC 的内存管理了（这里特指 Oracle JDBC，别的厂商也许实现机制不是这样的）。JDBC 解析 SQL 语句后，为每个 Statement（包括 PreparedStatement 和 CallableStatement）分配了两个 Buffer 来缓存数据，<code>byte[]</code>和<code>char[]</code>。字符类型的数据（CHAR,<br>VARCHAR2, NCHAR, etc. ）缓存在<code>char[]</code>中，其他类型的数据缓存在<code>byte[]</code>中。在 SQL 语句解析后，语句所查询的列的数据类型就已经确定了，JDBC 会根据这些信息和 Fetch Size 一起计算出缓存的大小，并分配内存。所以如果不需要查询某张表的所以列时，使用<code>SELECT * FROM XXX</code>是一种浪费内存的行为，特别是表的列数多且数据量大的时候，很容易造成 OOM。</p><h3 id="数据类型与内存占用"><a href="#数据类型与内存占用" class="headerlink" title="数据类型与内存占用"></a>数据类型与内存占用</h3><p>前面说了，JDBC 会根据查询语句中列的数据类型来计算缓存的大小那么每种数据类型大致占多少空间呢？请看下表。</p><table><thead><tr><th>数据类型</th><th style="text-align:center">大小（byte）</th><th>备注</th></tr></thead><tbody><tr><td>VARCHAR2</td><td style="text-align:center">2</td><td>每个字符占用2byte</td></tr><tr><td>BFILE</td><td style="text-align:center">4K</td><td></td></tr><tr><td>BLOB</td><td style="text-align:center">4K</td><td></td></tr><tr><td>CLOB</td><td style="text-align:center">4K</td><td></td></tr><tr><td>Other</td><td style="text-align:center">22</td><td>其他类型占用空间比较小，可以大致估算为22byte</td></tr></tbody></table><p>让我们来举个栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE TAB (ID NUMBER(10), NAME VARCHAR2(40), DOB DATE)</span><br><span class="line">ResultSet r = stmt.executeQuery(“SELECT * FROM TAB”);</span><br></pre></td></tr></table></figure><p>当 JDBC 解析查询语句时，数据库会告知 JDBC 结果会包含三列，NUMBER(10)、VARCHAR2(40) 和 DATE，第一列大概需要22 bytes，第二列包含了40个字符，所以需要<code>2 * 40</code>bytes，第三列也是大概需要22 bytes。因此，本次查询每条记录大致需要<code>22 + (40 * 2) + 22 = 124</code>bytes，如果 Fetch Size设置为10，那么缓存就需要分配1240 bytes 的空间。</p><h2 id="如何正确设置Fetch-Size"><a href="#如何正确设置Fetch-Size" class="headerlink" title="如何正确设置Fetch Size"></a>如何正确设置Fetch Size</h2><p>上面说了那么多无非就是想说明一个问题，就是 Fetch Size 的大小是要根据实际情况来设置，设置小了性能不好，设置大了内存会有问题。总之一个原则就是，在保证内存够用的情况下，尽量把 Fetch Size 设置得大一点。如果你拿不准设置多少，可以先试下下面的方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 * 1024 * 1024 / sum(所读取的列的数据长度)</span><br></pre></td></tr></table></figure><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ul><li><a href="http://www.oracle.com/technetwork/database/enterprise-edition/memory.pdf" target="_blank" rel="noopener">Oracle JDBC Memory Management</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触到 JDBC 的 Fetch Size 这个属性缘起一个性能问题，项目中需要将一个有千万级数据量的表中的记录导出到文件中去。按照正常的路数，先初始化连接；接着写好 SQL 语句，比如&lt;code&gt;SELECT * FROM DIM_USERS&lt;/code&gt;；然后启动查询，拿到 ResultSet，最后遍历 ResultSet 将每行记录输出到文件中去。可在接下来的测试中，发现性能并不理想，在表中数据量小的时候，执行速度尚可接受，可是在进行大数据量压力测试的时候，发现代码往往要执行40分钟以上，这在实际生产环境上是万万不可接受的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://allenn.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="JDBC" scheme="http://allenn.cn/tags/JDBC/"/>
    
      <category term="数据库" scheme="http://allenn.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="内存管理" scheme="http://allenn.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spark 的惰性运算</title>
    <link href="http://allenn.cn/articles/2016-10/2016-10-26-spark-is-lazy/"/>
    <id>http://allenn.cn/articles/2016-10/2016-10-26-spark-is-lazy/</id>
    <published>2016-10-26T08:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>今天在检视项目代码的时候，无意中发现了下面一段代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RddTransformer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doTransform</span></span>(data: <span class="type">RDD</span>[<span class="type">Data</span>]): <span class="type">RDD</span>[<span class="type">NewData</span>]=&#123;</span><br><span class="line">    <span class="keyword">val</span> newDataRdd = data.flatmap(<span class="type">DataTransformer</span>.doTransform)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="type">DataTransformer</span>.exceptionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      logger.error(<span class="string">s"There are some illegal data, count: <span class="subst">$&#123;DataTransformer.exceptionCount&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newDataRdd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataTransformer</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> exceptionCount:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doTransform</span></span>(data: <span class="type">Data</span>): <span class="type">Option</span>[<span class="type">NewData</span>]=&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.isIllegal)&#123;</span><br><span class="line">      exceptionCount += <span class="number">1</span></span><br><span class="line">      <span class="type">None</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// do something transform data to new data</span></span><br><span class="line">      .....</span><br><span class="line"></span><br><span class="line">      <span class="type">Some</span>(newData)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>作者的意图很简单，就是将RDD中的数据转换为新的数据格式，并统计非法数据的个数。咋一看代码，似乎没有什么问题，可是，这段代码真的能得到正确的结果么？答案是否定的，事实上，不管RDD中包含多少非法数据，<code>if(DataTransformer.exceptionCount &gt; 0)</code>这个条件永远都不会为真。为什么？你现在肯定充满了疑惑，让我们先来看看 Spark 的文档上对 RDD 操作的解释：</p><blockquote><p>All transformations in Spark are lazy, in that they do not compute their results right away. Instead, they just remember the transformations applied to some base dataset (e.g. a file). The transformations are only computed when an action requires a result to be returned to the driver program. (<a href="http://spark.apache.org/docs/latest/programming-guide.html#rdd-operations" target="_blank" rel="noopener">RDD Operations</a>)</p></blockquote><blockquote><p>在 Spark 中，所有的 transformation() 类型操作都是延迟计算的，Spark 只是记录了将要对数据集进行的操作。只有需要数据集将数据返回到 Driver 程序时（即触发 Action 类型操作），所有已记录的 transformation() 才会执行。</p></blockquote><p>回到上面的代码，由于针对<code>RDD[Data]</code>的<code>flatmap</code>操作属于 transformation() 类型操作，所以<code>val newDataRdd = data.flatmap(DataTransformer.doTransform)</code>这段代码只是记录了一下对 RDD 的操作，并没有真正的去执行<code>DataTransformer.doTransform</code>方法中的代码。我们可以尝试在 Spark Shell 中实验一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> var counter = 0</span></span><br><span class="line">counter: Int = 0</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> var rdd = sc.parallelize(Seq(1,2,3,4,5,6)).map(x =&gt; counter += x)</span></span><br><span class="line">rdd: spark.RDD[Int] = spark.MappedRDD@2ee9b6e3</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> counter</span></span><br><span class="line">counter: Int = 0</span><br></pre></td></tr></table></figure><p>显然累加操作并没有被执行，根据 Shell 终端的输出，Spark 似乎只是记录了一下我们的操作，并返回了一个新的 RDD。当对 RDD 进行 transformation() 操作的时候，在 Spark 内部究竟发生了什么？在解释这个问题之前，先来看看 Spark 作业的执行逻辑。</p><h2 id="Spark-Job-执行逻辑"><a href="#Spark-Job-执行逻辑" class="headerlink" title="Spark Job 执行逻辑"></a>Spark Job 执行逻辑</h2><p><img src="/assets/images/2016-10-26-spark-is-lazy/GeneralLogicalPlan.png" alt="GeneralLogicalPlan"></p><p>典型的 Spark Job 逻辑执行图如下所示，Spark Job 经过下面四个步骤可以得到最终执行结果：</p><ul><li>从数据源（可以是本地 file，内存数据结构， HDFS，HBase 等）读取数据创建最初的 RDD。上一段代码中的 parallelize() 相当于 createRDD()。</li><li>对 RDD 进行一系列的 transformation() 操作，每一个 transformation() 会产生一个或多个包含不同类型 T 的 RDD[T]。T 可以是 Scala 里面的基本类型或数据结构，不限于 (K, V)。但如果是 (K, V)，K 不能是 Array 等复杂类型（因为难以在复杂类型上定义 partition 函数）。</li><li>对最后的 final RDD 进行 action() 操作，每个 partition 计算后产生结果 result。</li><li>将 result 回送到 driver 端，进行最后的 f(list[result]) 计算。例子中的 count() 实际包含了action() 和 sum() 两步计算。</li></ul><p>Spark 在每次 transformation() 的时候使用了新产生的 RDD 来记录计算逻辑，这样就把作用在 RDD 上的所有计算逻辑串起来形成了一个链条，逻辑执行图上表示的实际上就是是 Spark Job 的计算链。当然某些 transformation() 比较复杂，会包含多个子 transformation()，因而会生成多个 RDD。这就是实际 RDD 个数会比我们想象的多一些的原因。当对 RDD 进行 action() 时，Spark 会调用在计算链条末端最后一个 RDD 的<code>compute()</code>方法，这个方法会接收它上一个 RDD 或者数据源的 input records，并执行自身定义的计算逻辑，从而输出结果。一句话总结 Spark 执行 action() 的流程就是：从计算链的最后一个 RDD 开始，依次从上一个 RDD 获取数据并执行计算逻辑，最后输出结果。</p><h2 id="数据计算过程"><a href="#数据计算过程" class="headerlink" title="数据计算过程"></a>数据计算过程</h2><p>下面的代码段，展现了<code>RDD.flatmap()</code>和<code>MapPartitionsRDD</code>的实现，在代码中，我们看到，当调用<code>RDD</code>的<code>map</code>并传入一个函数<code>f</code>的时候，Spark 并没有做什么运算，而是用<code>f</code>作为一个入参创建了一个叫<code>MapPartitionsRDD</code>的对象并返回给调用者。而在<code>MapPartitionsRDD.scala</code>中，我们也看到只有当<code>compute</code>方法被调用的时候，我们之前传入的函数<code>f</code>才会真正的被执行</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// RDD.scala</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return a new RDD by applying a function to all elements of this RDD.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatmap</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">    <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.map(cleanF))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MapPartitionsRDD.scala</span></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">MapPartitionsRDD</span>[<span class="type">U</span>: <span class="type">ClassTag</span>, <span class="type">T</span>: <span class="type">ClassTag</span>](<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    var prev: <span class="type">RDD</span>[<span class="type">T</span>],</span></span></span><br><span class="line"><span class="class"><span class="params">    f: (<span class="type">TaskContext</span>, <span class="type">Int</span>, <span class="type">Iterator</span>[<span class="type">T</span>]</span>) <span class="title">=&gt;</span> <span class="title">Iterator</span>[<span class="type">U</span>],  <span class="title">//</span> (<span class="params"><span class="type">TaskContext</span>, partition index, iterator</span>)</span></span><br><span class="line"><span class="class">    <span class="title">preservesPartitioning</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">extends</span> <span class="type">RDD</span>[<span class="type">U</span>](prev) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> partitioner = <span class="keyword">if</span> (preservesPartitioning) firstParent[<span class="type">T</span>].partitioner <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartitions</span></span>: <span class="type">Array</span>[<span class="type">Partition</span>] = firstParent[<span class="type">T</span>].partitions</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">U</span>] =</span><br><span class="line">    f(context, split.index, firstParent[<span class="type">T</span>].iterator(split, context))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">clearDependencies</span></span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.clearDependencies()</span><br><span class="line">    prev = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际计算过程大概是这样的：</p><ol><li>根据动作操作来将一个应用程序划分成多个作业。</li><li>一个作业经历 DAG 调度和任务调度之后，被划分成一个一个的任务，对应 Task 类。</li><li>任务被分配到不同核心去执行，执行 Task.run。</li><li>Task.run 会调用阶段末 RDD 的 iterator 方法，获取该 RDD 某个分区内的数据记录，而 iterator 方法有可能会调用 RDD 类的 compute 方法来负责父 RDD 与子 RDD 之间的计算逻辑。</li></ol><p>整个过程会比较复杂，在此不进行展开，我们只需要知道 Apache Spark 最终会调用 RDD 的 iterator 和 compute 方法来计算分区数据即可。</p><h3 id="compute-方法"><a href="#compute-方法" class="headerlink" title="compute 方法"></a>compute 方法</h3><p>在 RDD 中，<code>compute()</code>被定义为抽象方法，要求其所有子类都必须实现，该方法接受的参数之一是一个<code>Partition</code>对象，目的是计算该分区中的数据。以之前<code>flatmap</code>操作生成得到的<code>MapPartitionsRDD</code>类为例。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">U</span>] =</span><br><span class="line">  f(context, split.index, firstParent[<span class="type">T</span>].iterator(split, context))</span><br></pre></td></tr></table></figure><p>其中，<code>firstParent</code>在 RDD 中定义。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Returns the first parent RDD */</span></span><br><span class="line"><span class="keyword">protected</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">firstParent</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>] = &#123;</span><br><span class="line">  dependencies.head.rdd.asInstanceOf[<span class="type">RDD</span>[<span class="type">U</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapPartitionsRDD</code>类的<code>compute</code>方法调用当前 RDD 内的第一个父 RDD 的<code>iterator</code>方法，该方的目的是拉取父 RDD 对应分区内的数据，它返回一个迭代器对象，迭代器内部存储的每个元素即父 RDD 对应分区内已经计算完毕的数据记录。得到的迭代器作为<code>f</code>方法的一个参数。<code>compute</code>方法会将迭代器中的记录一一输入<code>f</code>方法，得到的新迭代器即为所求分区中的数据。</p><h3 id="iterator方法"><a href="#iterator方法" class="headerlink" title="iterator方法"></a>iterator方法</h3><p><code>iterator</code>方法的实现在 RDD 类中。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Internal method to this RDD; will read from cache if applicable, or otherwise compute it.</span></span><br><span class="line"><span class="comment"> * This should ''not'' be called by users directly, but is available for implementors of custom</span></span><br><span class="line"><span class="comment"> * subclasses of RDD.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">  <span class="keyword">if</span> (storageLevel != <span class="type">StorageLevel</span>.<span class="type">NONE</span>) &#123;</span><br><span class="line">    <span class="type">SparkEnv</span>.get.cacheManager.getOrCompute(<span class="keyword">this</span>, split, context, storageLevel)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    computeOrReadCheckpoint(split, context)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iterator</code>方法首先检查当前 RDD 的存储级别，如果存储级别不为<code>None</code>，说明分区的数据要么已经存储在文件系统当中，要么当前 RDD 曾经执行过<code>cache</code>、<code>persise</code>等持久化操作，因此需要想办法把数据从存储介质中提取出来。<code>iterator</code>方法继续调用<code>CacheManager</code>的<code>getOrCompute</code>方法。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Gets or computes an RDD partition. Used by RDD.iterator() when an RDD is cached. */</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getOrCompute</span></span>[<span class="type">T</span>](</span><br><span class="line">     rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">     partition: <span class="type">Partition</span>,</span><br><span class="line">     context: <span class="type">TaskContext</span>,</span><br><span class="line">     storageLevel: <span class="type">StorageLevel</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">   <span class="keyword">val</span> key = <span class="type">RDDBlockId</span>(rdd.id, partition.index)</span><br><span class="line">   blockManager.get(key) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(blockResult) =&gt;</span><br><span class="line">        <span class="comment">// Partition is already materialized, so just return its values</span></span><br><span class="line">        context.taskMetrics.inputMetrics = <span class="type">Some</span>(blockResult.inputMetrics)</span><br><span class="line">        <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, blockResult.data.asInstanceOf[<span class="type">Iterator</span>[<span class="type">T</span>]])    </span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        <span class="comment">// 省略部分源码</span></span><br><span class="line">        <span class="keyword">val</span> computedValues = rdd.computeOrReadCheckpoint(partition, context)</span><br><span class="line">        <span class="keyword">val</span> cachedValues = putInBlockManager(key, computedValues, storageLevel, updatedBlocks)</span><br><span class="line">        <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, cachedValues)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 省略部分源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getOrCompute</code>方法会根据 RDD 编号与分区编号计算得到当前分区在存储层对应的块编号，通过存储层提供的数据读取接口提取出块的数据。这时候会有两种可能情况发生：</p><ul><li>数据之前已经存储在存储介质当中，可能是数据本身就在存储介质（如读取 HDFS 中的文件创建得到的 RDD）当中，也可能是 RDD 经过持久化操作并经历了一次计算过程。这时候就能成功提取得到数据并将其返回。</li><li>数据不在存储介质当中，可能是数据已经丢失，或者 RDD 经过持久化操作，但是是当前分区数据是第一次被计算，因此会出现拉取得到数据为 None 的情况。这就意味着我们需要计算分区数据，继续调用 RDD 类 computeOrReadCheckpoint 方法来计算数据，并将计算得到的数据缓存到存储介质中，下次就无需再重复计算。</li><li>如果当前RDD的存储级别为 None，说明为未经持久化的 RDD，需要重新计算 RDD 内的数据，这时候调用 RDD 类的 computeOrReadCheckpoint 方法，该方法也在持久化 RDD 的分区获取数据失败时被调用。</li></ul><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compute an RDD partition or read it from a checkpoint if the RDD is checkpointing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">computeOrReadCheckpoint</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">  <span class="keyword">if</span> (isCheckpointed) firstParent[<span class="type">T</span>].iterator(split, context) <span class="keyword">else</span> compute(split, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>computeOrReadCheckpoint</code>方法会检查当前 RDD 是否已经被标记成检查点，如果未被标记成检查点，则执行自身的<code>compute</code>方法来计算分区数据，否则就直接拉取父 RDD 分区内的数据。</p><h2 id="如何正确的获取计算结果"><a href="#如何正确的获取计算结果" class="headerlink" title="如何正确的获取计算结果"></a>如何正确的获取计算结果</h2><p>说了那么多理论，我们回到问题本身，怎么才是获取运算结果的正确方法？你也许会说，既然 transformation() 操作是惰性的，那么在之后马上触发一个 action() 操作就 OK 了。但这也是不正确的，这就涉及到了 Spark 的另外一个重要概念：分布式，在这里就不展开讲了，有兴趣可以参考官方文档：<a href="http://spark.apache.org/docs/latest/programming-guide.html#understanding-closures-a-nameclosureslinka" target="_blank" rel="noopener">Understanding closures </a>。</p><p>下面是一个正确的实现：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RddTransformer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doTransform</span></span>(data: <span class="type">RDD</span>[<span class="type">Data</span>]): <span class="type">RDD</span>[<span class="type">NewData</span>]=&#123;</span><br><span class="line">    <span class="keyword">val</span> newDataRdd = data.flatmap(<span class="type">DataTransformer</span>.doTransform).cache()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> exceptionCount = newDataRdd.filter(_.isEmpty).count()</span><br><span class="line">    <span class="keyword">if</span>(exceptionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      logger.error(<span class="string">s"There are some illegal data, count: <span class="subst">$&#123;DataTransformer.exceptionCount&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newDataRdd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataTransformer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doTransform</span></span>(data: <span class="type">Data</span>): <span class="type">Option</span>[<span class="type">NewData</span>]=&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.isIllegal)&#123;</span><br><span class="line">      <span class="type">None</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// do something transform data to new data</span></span><br><span class="line">      .....</span><br><span class="line"></span><br><span class="line">      <span class="type">Some</span>(newData)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在检视项目代码的时候，无意中发现了下面一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RddTransformer&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doTransform&lt;/span&gt;&lt;/span&gt;(data: &lt;span class=&quot;type&quot;&gt;RDD&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Data&lt;/span&gt;]): &lt;span class=&quot;type&quot;&gt;RDD&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;NewData&lt;/span&gt;]=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; newDataRdd = data.flatmap(&lt;span class=&quot;type&quot;&gt;DataTransformer&lt;/span&gt;.doTransform)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;DataTransformer&lt;/span&gt;.exceptionCount &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      logger.error(&lt;span class=&quot;string&quot;&gt;s&quot;There are some illegal data, count: &lt;span class=&quot;subst&quot;&gt;$&amp;#123;DataTransformer.exceptionCount&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    newDataRdd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataTransformer&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; exceptionCount:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doTransform&lt;/span&gt;&lt;/span&gt;(data: &lt;span class=&quot;type&quot;&gt;Data&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Option&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;NewData&lt;/span&gt;]=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(data.isIllegal)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      exceptionCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// do something transform data to new data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      .....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Some&lt;/span&gt;(newData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://allenn.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="http://allenn.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"/>
    
    
      <category term="Spark" scheme="http://allenn.cn/tags/Spark/"/>
    
      <category term="Scala" scheme="http://allenn.cn/tags/Scala/"/>
    
      <category term="函数式编程" scheme="http://allenn.cn/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="惰性计算" scheme="http://allenn.cn/tags/%E6%83%B0%E6%80%A7%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>使用 EdgeMax 路由器自动翻墙</title>
    <link href="http://allenn.cn/articles/2016-10/2016-10-20-edgemax-ss-tutorial/"/>
    <id>http://allenn.cn/articles/2016-10/2016-10-20-edgemax-ss-tutorial/</id>
    <published>2016-10-20T14:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.805Z</updated>
    
    <content type="html"><![CDATA[<p>作为肉身在墙内的计算机科学技术人员，不能上google实在是一件很遗憾的事情。</p><blockquote><p>什么？你说用百度？你站出来，我是你老板我肯定会开除你。</p></blockquote><p> 百度搜索简直是垃圾中的战斗机，在使用百度时，你不得不忍受他的各种广告，各种竞价排名，而且英文资料极少。很多领先的开源作品、解决方案、论文什么的基本都是国外的。这些资料你查不到，你说什么与国际先进技术接轨？总之，没用过 Google 之前，你可能没什么感觉，但是用过了之后再用”某度”，你会抱怨，这搜的是些什么破玩意儿。。。但是，因为众所周知的原因，我们无法直接访问 Google，不能访问一些很优秀的国外网站，比如 slideshare（里面有很多优秀的PPT、文档）等等。那么怎么办？答案就是：翻墙！</p> <a id="more"></a><blockquote><p>网监同志，我知道你在盯着我，我写这个纯粹是为了方便技术人员查阅资料，作为爱党爱国的四有青年，我翻墙出去后保证不受反动思想的荼毒，努力在墙外为祖国占领舆论高地</p></blockquote><p> 翻墙的姿势有很多，什么 VPN，代理，自由门等等，本人也尝试过不少，目前来说用得最稳定的当属<a href="https://shadowsocks.org" target="_blank" rel="noopener">Shadowsocks</a>。刚开始的时候只是在一个 Shadowsocks 服务提供商处购买了一个账号，在我的 Macbook 上试用，后面发现翻墙速度快且稳定，就萌生了在路由器上安装 Shadowsocks 的想法，正好家中的主路由器是 EdgeRouter Lite 3（Unix 架构，完美！），于是：Let’s do it!</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在搜索引擎中输入<code>Shadowsocks+路由器</code>关键字，可以搜索出很多安装教程，采用的方案也不尽相同，建议不想太折腾的话就买一个可以刷 OpenWRT 的路由器，按照这个博客（<a href="https://cokebar.info/archives/978" target="_blank" rel="noopener">https://cokebar.info/archives/978</a>）的教程安装配置就可以了。如果你和我一样入了 EdgeRouter 的坑，那我们继续~。</p><p>我采用的方案是使用 Shadowsocks + ChinaDNS + DNSMasq + iptables 来实现路由器智能翻墙，即国内流量走正常网络，国外流量走 Shadowsocks 代理，总体流程如下图：</p><p><img src="/assets/images/2016-10-20-edgemas-ss-tutorial/proxy-flow.png" alt="流程图"></p><h2 id="所需软件"><a href="#所需软件" class="headerlink" title="所需软件"></a>所需软件</h2><h3 id="shadowsocks-libev"><a href="#shadowsocks-libev" class="headerlink" title="shadowsocks-libev"></a>shadowsocks-libev</h3><p>项目地址：<a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-libev</a>，可下载源码在路由器上进行编译，或者直接下载<a href="https://www.onlyos.com/wp-content/uploads/2015/08/shadowsocks-libev_2.2.4-1_mips.zip" target="_blank" rel="noopener">安装包</a>，请注意这个安装包只适用于 EdgeRouter Lite 3，其他 EdgeMax 产品需要自行编译。</p><h3 id="ChinaDNS"><a href="#ChinaDNS" class="headerlink" title="ChinaDNS"></a>ChinaDNS</h3><p>项目地址：<a href="https://github.com/shadowsocks/ChinaDNS" target="_blank" rel="noopener">https://github.com/shadowsocks/ChinaDNS</a>，可下载源码在路由器上进行编译，或者直接下载<a href="https://www.onlyos.com/wp-content/uploads/2015/08/chinadns-1.3.2.zip" target="_blank" rel="noopener">安装包</a>，请注意这个安装包只适用于 EdgeRouter Lite 3，其他 EdgeMax 产品需要自行编译。</p><h3 id="DNSMasq"><a href="#DNSMasq" class="headerlink" title="DNSMasq"></a>DNSMasq</h3><p>EdgeMax 中已经集成了 DNSMasq 无需另外安装。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="shadowsocks-libev-1"><a href="#shadowsocks-libev-1" class="headerlink" title="shadowsocks-libev"></a>shadowsocks-libev</h3><p>shadowsocks-libev 安装好后，会在<code>/etc/init.d/</code>中安装一个启动脚本：<code>shadowsock-libev</code>，在路由器启动时会默认启动<code>ss-redir</code>服务，如果需要重启 Shadowsocks，可以使用命令：<code>sudo /etc/init.d/shadowsock-libev [start|stop|restart]</code>。Shadowsocks 的配置在文件<code>/etc/shadowsocks-libev/config.json</code>中，在这个文件中配置 Shadowsocks 需要链接的服务器信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">&quot;server_port&quot;:8388,</span><br><span class="line">&quot;local_address&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">&quot;local_port&quot;:1080,</span><br><span class="line">&quot;password&quot;:&quot;barfoo!&quot;,</span><br><span class="line">&quot;timeout&quot;:60,</span><br><span class="line">&quot;method&quot;:null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，<code>sudo /etc/init.d/shadowsock-libev restart</code>，这样 Shadowsocks 就在你的路由器上运行了。</p><h3 id="ChinaDNS-1"><a href="#ChinaDNS-1" class="headerlink" title="ChinaDNS"></a>ChinaDNS</h3><p>使用源码编译后，会生成一个二进制文件：chinadns，可以将这个文件复制到<code>/usr/bin</code>中方便后面使用。ChinaDNS 需要一个文件来标识哪些 IP 属于国内，这个文件可以从<a href="http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest" target="_blank" rel="noopener">这里下载</a>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载 ip 列表到： /tmp/chnroute.txt</span><br><span class="line">curl &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | grep ipv4 | grep CN | awk -F| ‘&#123; printf(“%s/%dn”, $4, 32-log($5)/log(2)) &#125;’ &gt; /tmp/chnroute.txt</span><br></pre></td></tr></table></figure><p>下载完成后，将文件移动到<code>/etc/chinadns/chnroute.txt</code>，接着我们就可以尝试启动 ChinaDNS 了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chinadns -s 223.5.5.5,223.6.6.6,127.0.0.1:5300 -c /etc/chinadns/chnroute.txt -p 35353 -m</span><br></pre></td></tr></table></figure><p>需要注意的是<code>-s</code>参数后面的<code>127.0.0.1:5300</code>，这个代表将<code>ss-tunnel</code>转发的国外可信DNS站点作为上游DNS服务器。</p><h4 id="ChinaDNS参数详解"><a href="#ChinaDNS参数详解" class="headerlink" title="ChinaDNS参数详解"></a>ChinaDNS参数详解</h4><ul><li>-l：虚假IP列表：默认值：/etc/chinadns_iplist.txt</li></ul><p>是GFW常见的DNS污染用IP列表，解析出列表中的IP结果时候，ChinaDNS会自动抛弃，保留默认即可；</p><ul><li>-c：chnroute文件：默认值：/etc/chinadns_chnroute.txt</li></ul><p>此文件标识哪些IP属于国内。用于ChinaDNS判断解析结果。ChinaDNS要求解析结果与DNS要匹配，国内网站采用国内DNS解析的结果，国外网站采用国外DNS解析结果，等等规则；确保以上两个文件内容完整无误，否则会造成无法启动；</p><ul><li>-p：本地端口：默认值：5353</li></ul><p>ChinaDNS所监听的端口。根据实际情况更改，注意不能和其他服务的端口重复（特别是DNSMasq和shadowsocks）；</p><ul><li>-s: 上游服务器：默认值：114.114.114.114,8.8.8.8</li></ul><p>可填入一系列的上游DNS服务器，根据实际情况来，可以保留默认，格式为”DNS_IP:PORT,DNS_IP:PORT”注意逗号后面不能有空格。有些ISP会封杀公共DNS，此时请将114DNS改为ISP的DNS；此处必须至少填入一个国内IP的DNS和一个国外IP的DNS，否则会造成ChinaDNS启动失败。额外的用法：ChinaDNS添加可信DNS避免一些异常</p><ul><li>-y：等待时间： 默认值：0.3</li></ul><p>为防止GFW的DNS污染抢答，而设置一个等待时间，请根据自己填写的国外DNS延迟值来填写，留下一定的裕度。GoogleDNS在国内延迟一般在100-200ms，留0.3比较合适。过大的值会造成DNS解析较大的延迟时间，过小的值可能导致无法接收正确的解析结果。</p><ul><li>-d：双向过滤： 默认：开启</li></ul><p>勾选时，当国外DNS服务器返回的查询结果是国内IP，或者当国内DNS服务器返回的查询结果是国外IP，则过滤掉这个结果（较为严格的模式）；去掉勾选的话只是过滤国内DNS的国外IP结果。</p><ul><li>-m：启用压缩指针： 默认：不开启</li></ul><p>利用GFW遇到压缩指针时的一个bug来精确识别来自GFW的抢答污染，从而极大提高识别的准确性和识别的效率，推荐启用，启用后，IPList和等待时间将禁用（因为用不到了）。 （已强制开启）</p><h3 id="ss-tunnel"><a href="#ss-tunnel" class="headerlink" title="ss-tunnel"></a>ss-tunnel</h3><p>ss-tunnel 是 Shadowsocks 的一个模块，可以用于 UDP 转发，为了防止 GFW 的 DNS 污染，我们用它来转发国外 DNS，可以通过下面命令来启动 ss-tunnel：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ss-tunnel -c /etc/shadowsocks-libev/config.json -u -b 0.0.0.0 -l 5300 -L 8.8.8.8:53</span><br></pre></td></tr></table></figure><p>为了让 ss-tunnel 在每次重启路由器的时候自动重启，我们可以写个脚本放在<code>/config/scripts/post-config.d</code>目录下。</p><h3 id="DNSMasq-1"><a href="#DNSMasq-1" class="headerlink" title="DNSMasq"></a>DNSMasq</h3><p>首先需要将系统的 DNS 服务器设置为本地</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configure</span><br><span class="line"># 停止通过pppoe更新dns设置，如果pppoe绑定在其他网口上，eth0需要变更为对应网口</span><br><span class="line">set interfaces ethernet eth0 pppoe 0 name-server none</span><br><span class="line"></span><br><span class="line"># 设置 DNSMasq 使用 ChinaDNS</span><br><span class="line"># 需要注意的是，这里无法设置服务器端口，只能先这样设置后，再手工变更配置文件</span><br><span class="line">edit service dns forwarding</span><br><span class="line">set name-server 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 告诉路由器使用本地 DNSMasq 来解析域名</span><br><span class="line">set system name-server 127.0.0.1</span><br><span class="line"></span><br><span class="line">commit</span><br><span class="line">save</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>修改<code>/etc/dnsmasq.conf</code>，去除你之前自定义的规则，在最后加入<code>conf-dir=/etc/dnsmasq.d</code>，并将<code>server=127.0.0.1</code>修改为<code>server=127.0.0.1#35353</code>。新建并进入目录<code>/etc/dnsmasq.d</code>，下载 <a href="https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.conf" target="_blank" rel="noopener">accelerated-domains.china.conf</a> 和<a href="http://pan.baidu.com/s/1eQB7ACi" target="_blank" rel="noopener">foreign_list.conf</a>两个文件后复制两个文件到<code>/etc/dnsmasq.d</code>目录。这两个文件都会有更新，建议隔段时间更新一下。分别修改两个文件，将<code>accelerated-domains.china.conf</code>（ChinaList）文件中所有的的114.114.114.114修改为自己ISP的DNS或者其他效果更好的国内DNS的IP地址（也可以保留114DNS），格式为：<code>server=/0-6.com/IP</code>；将<code>foreign_list.conf</code>（GFWList）文件中所有的 127.0.0.1#5300 修改为自己所用国外DNS，格式为：<code>server=/.lsxszzg.com/IP#PORT</code>，如果你使用shadowsocks的UDP转发来提供国外DNS解析，UDP转发的端口号为5300，那么就是默认的 127.0.0.1#5300 ，如果你使用一个非标端口的国外DNS服务，如3.4.5.6，端口5353，那么就改为 3.4.5.6#5353 。注意不要使用国外公共DNS，因为会被污染！最后重启 dnsmasq：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/dnsmasq restart</span><br></pre></td></tr></table></figure><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>上面所做的一切都是为了防止 GFW 的 DNS 污染，从而拿到正确的 IP 地址，那么拿到 IP 地址后，又如何将国外的流量转发到 Shadowsocks 呢？现在该 iptables 登场了，使用下面的代码设置 iptables 转发规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Setup the ipset</span><br><span class="line">ipset -N chnroute hash:net maxelem 65536</span><br><span class="line"></span><br><span class="line">for ip in $(cat &apos;/etc/chinadns/chnroute.txt&apos;); do</span><br><span class="line">  ipset add chnroute $ip</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 其他请求：</span><br><span class="line"># shadowsocks</span><br><span class="line">iptables -t nat -N SHADOWSOCKS</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp --dport 23596 -j RETURN</span><br><span class="line"># 23596 是 ss 代理服务器的端口，即远程 shadowsocks 服务器提供服务的端口，如果你有多个 ip 可用,但端口一致，就设置这个</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 123.456.789.111 -j RETURN</span><br><span class="line"># 123.456.789.111 是 ss 代理服务器的 ip, 如果你只有一个 ss服务器的 ip，却能选择不同端口,就设置此条</span><br><span class="line"></span><br><span class="line"># ignore internal ip</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN</span><br><span class="line"></span><br><span class="line"># ignore asia ip</span><br><span class="line"></span><br><span class="line"># Allow connection to chinese IPs</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp -m set --match-set chnroute dst -j RETURN</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports 1080</span><br><span class="line">iptables -t nat -I PREROUTING -p tcp -j SHADOWSOCKS</span><br></pre></td></tr></table></figure><p>iptables 配置完后，你应该可以再浏览器中正常的打开 Google 首页了。</p><h3 id="一键式-DNS-配置脚本"><a href="#一键式-DNS-配置脚本" class="headerlink" title="一键式 DNS 配置脚本"></a>一键式 DNS 配置脚本</h3><p>使用下面的脚本可以在重启路由器时（需要将脚本放在<code>/config/scripts/post-config.d</code>目录下）更新<code>foreign_list.conf</code>和<code>accelerated-domains.china.conf</code>两个文件，并配置好 iptables：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">deleteFile() &#123;</span><br><span class="line">  local filePath=$1</span><br><span class="line">  if [ -f &quot;$filePath&quot; ]; then</span><br><span class="line">   rm &quot;$filePath&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"># get chinadns ignore list</span><br><span class="line">updateChnroute() &#123;</span><br><span class="line">  deleteFile /tmp/chnroute.txt</span><br><span class="line"></span><br><span class="line">  curl &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | grep ipv4 | grep CN | awk -F\| &apos;&#123; printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) &#125;&apos; &gt;  /tmp/chnroute.txt</span><br><span class="line">  mv -f /tmp/chnroute.txt /etc/chinadns/</span><br><span class="line">  chmod 644 /etc/chinadns/chnroute.txt</span><br><span class="line"></span><br><span class="line">  if pidof chinadns&gt;/dev/null; then</span><br><span class="line">      /etc/init.d/chinadns restart</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateDnsmasqConf() &#123;</span><br><span class="line">  deleteFile /tmp/accelerated-domains.china.conf</span><br><span class="line">  # download accelerated-domains.china.conf</span><br><span class="line">  local DNS=223.5.5.5</span><br><span class="line">  curl &apos;https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.conf&apos; &gt; /tmp/accelerated-domains.china.conf</span><br><span class="line">  sed -i &quot;s|^\(server.*\)/[^/]*$|\1/$DNS|&quot;  /tmp/accelerated-domains.china.conf</span><br><span class="line">  mv -f /tmp/accelerated-domains.china.conf /etc/dnsmasq.d/</span><br><span class="line">  chmod 644 /etc/dnsmasq.d/accelerated-domains.china.conf</span><br><span class="line"></span><br><span class="line">  # download foreign_list.conf</span><br><span class="line">  python ../gfwlist2dnsmasq_noipset.py</span><br><span class="line"></span><br><span class="line">  if pidof dnsmasq&gt;/dev/null; then</span><br><span class="line">      /etc/init.d/dnsmasq restart</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">configIptables() &#123;</span><br><span class="line">  # Setup the ipset</span><br><span class="line">  ipset -N chnroute hash:net maxelem 65536</span><br><span class="line"></span><br><span class="line">  for ip in $(cat &apos;/etc/chinadns/chnroute.txt&apos;); do</span><br><span class="line">    ipset add chnroute $ip</span><br><span class="line">  done</span><br><span class="line"></span><br><span class="line">  # 其他请求：</span><br><span class="line">  # shadowsocks</span><br><span class="line">  iptables -t nat -N SHADOWSOCKS</span><br><span class="line"></span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -p tcp --dport 33348 -j RETURN</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -d 103.192.224.122 -j RETURN</span><br><span class="line"></span><br><span class="line">  # ignore internal ip</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN</span><br><span class="line"></span><br><span class="line">  # ignore asia ip</span><br><span class="line"></span><br><span class="line">  # Allow connection to chinese IPs</span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -p tcp -m set --match-set chnroute dst -j RETURN</span><br><span class="line"></span><br><span class="line">  iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports 1080</span><br><span class="line">  iptables -t nat -I PREROUTING -p tcp -j SHADOWSOCKS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateChnroute</span><br><span class="line">updateDnsmasqConf</span><br><span class="line">configIptables</span><br></pre></td></tr></table></figure><p>gfwlist2dnsmasq_noipset.py：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#coding=utf-8</span><br><span class="line">#</span><br><span class="line"># Generate a list of dnsmasq rules with ipset for gfwlist</span><br><span class="line">#</span><br><span class="line"># Copyright (C) 2014 http://www.shuyz.com</span><br><span class="line"># Ref https://code.google.com/p/autoproxy-gfwlist/wiki/Rules</span><br><span class="line"></span><br><span class="line">import urllib2</span><br><span class="line">import re</span><br><span class="line">import os</span><br><span class="line">import datetime</span><br><span class="line">import base64</span><br><span class="line">import shutil</span><br><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">mydnsip = &apos;127.0.0.1&apos;</span><br><span class="line">mydnsport = &apos;5300&apos;</span><br><span class="line"># Extra Domain;</span><br><span class="line">EX_DOMAIN=[ \</span><br><span class="line">&apos;.google.com&apos;, \</span><br><span class="line">&apos;.google.com.hk&apos;, \</span><br><span class="line">&apos;.google.com.tw&apos;, \</span><br><span class="line">&apos;.google.com.sg&apos;, \</span><br><span class="line">&apos;.google.co.jp&apos;, \</span><br><span class="line">&apos;.google.co.kr&apos;, \</span><br><span class="line">&apos;.blogspot.com&apos;, \</span><br><span class="line">&apos;.blogspot.sg&apos;, \</span><br><span class="line">&apos;.blogspot.hk&apos;, \</span><br><span class="line">&apos;.blogspot.jp&apos;, \</span><br><span class="line">&apos;.blogspot.kr&apos;, \</span><br><span class="line">&apos;.gvt1.com&apos;, \</span><br><span class="line">&apos;.gvt2.com&apos;, \</span><br><span class="line">&apos;.gvt3.com&apos;, \</span><br><span class="line">&apos;.1e100.net&apos;, \</span><br><span class="line">&apos;.blogspot.tw&apos; \</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># the url of gfwlist</span><br><span class="line">baseurl = &apos;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&apos;</span><br><span class="line"># match comments/title/whitelist/ip address</span><br><span class="line">comment_pattern = &apos;^\!|\[|^@@|^\d+\.\d+\.\d+\.\d+&apos;</span><br><span class="line">domain_pattern = &apos;([\w\-\_]+\.[\w\.\-\_]+)[\/\*]*&apos;</span><br><span class="line">ip_pattern = re.compile(r&apos;\b\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\b&apos;)</span><br><span class="line">tmpfile = &apos;/tmp/gfwlisttmp&apos;</span><br><span class="line"># do not write to router internal flash directly</span><br><span class="line">outfile = &apos;/tmp/dnsmasq_list.conf&apos;</span><br><span class="line">rulesfile = &apos;/etc/dnsmasq.d/foreign_list.conf&apos;</span><br><span class="line"></span><br><span class="line">fs =  file(outfile, &apos;w&apos;)</span><br><span class="line">fs.write(&apos;# gfw list ipset rules for dnsmasq\n&apos;)</span><br><span class="line">fs.write(&apos;# updated on &apos; + datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) + &apos;\n&apos;)</span><br><span class="line">fs.write(&apos;#\n&apos;)</span><br><span class="line"></span><br><span class="line">print &apos;fetching list...&apos;</span><br><span class="line">if hasattr(ssl, &apos;_create_unverified_context&apos;):</span><br><span class="line">truessl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line">content = urllib2.urlopen(baseurl, timeout=15).read().decode(&apos;base64&apos;)</span><br><span class="line"></span><br><span class="line"># write the decoded content to file then read line by line</span><br><span class="line">tfs = open(tmpfile, &apos;w&apos;)</span><br><span class="line">tfs.write(content)</span><br><span class="line">tfs.close()</span><br><span class="line">tfs = open(tmpfile, &apos;r&apos;)</span><br><span class="line"></span><br><span class="line">print &apos;page content fetched, analysis...&apos;</span><br><span class="line"></span><br><span class="line"># remember all blocked domains, in case of duplicate records</span><br><span class="line">domainlist = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for line in tfs.readlines():</span><br><span class="line">trueif re.findall(comment_pattern, line):</span><br><span class="line">truetrueprint &apos;this is a comment line: &apos; + line</span><br><span class="line">truetrue#fs.write(&apos;#&apos; + line)</span><br><span class="line">trueelse:</span><br><span class="line">truetruedomain = re.findall(domain_pattern, line)</span><br><span class="line">truetrueif domain:</span><br><span class="line">truetruetruetry:</span><br><span class="line">truetruetruetruefound = domainlist.index(domain[0])</span><br><span class="line">truetruetruetrueprint domain[0] + &apos; exists.&apos;</span><br><span class="line">truetruetrueexcept ValueError:</span><br><span class="line">truetruetruetrueif ip_pattern.match(domain[0]):</span><br><span class="line">truetruetruetruetrueprint &apos;skipping ip: &apos; + domain[0]</span><br><span class="line">truetruetruetruetruecontinue</span><br><span class="line">truetruetruetrueprint &apos;saving &apos; + domain[0]</span><br><span class="line">truetruetruetruedomainlist.append(domain[0])</span><br><span class="line">truetruetruetruefs.write(&apos;server=/.%s/%s#%s\n&apos;%(domain[0],mydnsip,mydnsport))</span><br><span class="line">truetrueelse:</span><br><span class="line">truetruetrueprint &apos;no valid domain in this line: &apos; + line</span><br><span class="line"></span><br><span class="line">tfs.close()</span><br><span class="line"></span><br><span class="line">for each in EX_DOMAIN:</span><br><span class="line">truefs.write(&apos;server=/%s/%s#%s\n&apos;%(each,mydnsip,mydnsport))</span><br><span class="line"></span><br><span class="line">print &apos;write extra domain done&apos;</span><br><span class="line"></span><br><span class="line">fs.close();</span><br><span class="line">print &apos;moving generated file to dnsmasg directory&apos;</span><br><span class="line">shutil.move(outfile, rulesfile)</span><br><span class="line"></span><br><span class="line">print &apos;done!&apos;</span><br></pre></td></tr></table></figure><h2 id="一键式安装包"><a href="#一键式安装包" class="headerlink" title="一键式安装包"></a>一键式安装包</h2><p>现在风声紧，一键安装就不提供了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为肉身在墙内的计算机科学技术人员，不能上google实在是一件很遗憾的事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么？你说用百度？你站出来，我是你老板我肯定会开除你。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 百度搜索简直是垃圾中的战斗机，在使用百度时，你不得不忍受他的各种广告，各种竞价排名，而且英文资料极少。很多领先的开源作品、解决方案、论文什么的基本都是国外的。这些资料你查不到，你说什么与国际先进技术接轨？总之，没用过 Google 之前，你可能没什么感觉，但是用过了之后再用”某度”，你会抱怨，这搜的是些什么破玩意儿。。。但是，因为众所周知的原因，我们无法直接访问 Google，不能访问一些很优秀的国外网站，比如 slideshare（里面有很多优秀的PPT、文档）等等。那么怎么办？答案就是：翻墙！&lt;/p&gt;
    
    </summary>
    
      <category term="网络技术" scheme="http://allenn.cn/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="GFW" scheme="http://allenn.cn/tags/GFW/"/>
    
      <category term="防火墙" scheme="http://allenn.cn/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
      <category term="EdgeMax" scheme="http://allenn.cn/tags/EdgeMax/"/>
    
      <category term="路由器" scheme="http://allenn.cn/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>全面学习GFW</title>
    <link href="http://allenn.cn/articles/2016-10/2016-10-20-learn-gfw/"/>
    <id>http://allenn.cn/articles/2016-10/2016-10-20-learn-gfw/</id>
    <published>2016-10-20T08:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.805Z</updated>
    
    <content type="html"><![CDATA[<p>摘自：<a href="https://docs.google.com/document/d/1mmMiMYbviMxJ-DhTyIGdK7OOg581LSD1CZV4XY1OMG8/edit#heading=h.qgojh5xsppyz" target="_blank" rel="noopener">翻墙路由器的实现与原理</a></p><p>注：本文只供研究学习网络技术使用，请阅读者在24小时内忘记本文内容，谢绝网监请喝茶。</p><p>GFW会是一个长期的存在。要学会与之共存，必须先了解GFW是什么。做为局外人，学习GFW有六个角度。渐进的来看分别是：</p><p>首先我们学习到的是WHAT和WHEN。比如说，你经常听到人的议论是“昨天”，“github”被封了。其中的昨天就是WHEN，github就是WHAT。这是学习GFW的最天然，最朴素的角度。在这个方面做得非常极致的是一个叫做<a href="https://en.greatfire.org/" target="_blank" rel="noopener">greatfire</a>的网站。这个网站长期监控成千上万个网站和关键词。通过长期监控，不但可以掌握WHAT被封锁了，还可以知道WHEN被封的，WHEN被解封的。</p><a id="more"></a><p>接下来的角度是WHO。比如说，“方校长”这个人名就经常和GFW同时出现。但是如果仅仅是掌握一个两个人名，然后像某位同志那样天天在twitter上骂一遍那样，除了把这个人名骂成名人之外，没有什么特别的积极意义。我更看好这篇文章“通过分析论文挖掘防火长城(GFW)的技术人员”的思路。通过网络上的公开信息，掌握GFW的哪些方面与哪些人有关系，这些合作者之间又有什么联系。除了大家猜测的将来可以鞭尸之外，对现在也是有积极的意义的。比如关注这些人的研究动态和思想发展，可以猜测GFW的下一步发展方向。比如阅读过去发表的论文，可以了解GFW的技术演进历史，可以从历史中找到一些技术或者管理体制上的缺陷。</p><p>再接下来就是WHY了。github被封之后就常听人说，github这样的技术网站你封它干啥？是什么原因促成了一个网站的被封与解封的？我们做为局外人，真正的原因当然是无从得知的。但是我们可以猜测。基于猜测，可以把不同网站被封，与网络上的舆情时间做关联和分类。我们知道，方校长对于网路舆情监控是有很深入研究的。有一篇<a href="https://docs.google.com/file/d/0B3q8z0KnC5z6Zjc4VzdfOVN3RzA/edit?usp=sharing" target="_blank" rel="noopener">论文</a>（Whiskey, Weed, and Wukan on the World Wide Web: On Measuring Censors’ Resources and Motivations）专门讨论监管者的动机的。观测触发被封的事件与实际被封之间的时间关系，也可以推测出一些有趣的现象。比如有人报告，OpenVPN触发的封端口和封IP这样的事情一般都发生在中国的白天。也就是说，GFW背后不光是机器，有一些组件是血肉构成的。</p><p>剩下的两个角度就是对如何翻墙穿墙最有价值的两个角度了：HOW和WHERE。HOW是非常好理解的，就是在服务器和客户端两边抓包，看看一个正常的网络通信，GFW做为中间人，分别给两端在什么时候发了什么包或者过滤掉了什么包。而这些GFW做的动作，无论是过滤还是发伪包又是如何干扰客户端与服务器之间的正常通信的。WHERE是在知道了HOW之后的进一步发展，不但要了解客户端与服务器这两端的情况，更要了解GFW是挂在两端中间的哪一级路由器上做干扰的。在了解到GFW的关联路由器的IP的基础上，可以根据不同的干扰行为，不同的运营商归属做分组，进一步了解GFW的整体部署情况。</p><p>整体上来说，对GFW的研究都是从WHAT和WHEN开始，让偏人文的就去研究WHO和WHY，像我们这样偏工程的就会去研究HOW和WHERE。以上就是全面了解GFW的主体脉络。接下来，我们就要以HOW和WHERE这两个角度去看一看GFW的原理。</p><h1 id="GFW的原理"><a href="#GFW的原理" class="headerlink" title="GFW的原理"></a>GFW的原理</h1><p>要与GFW对抗不能仅仅停留在什么不能访问了，什么可以访问之类的表面现象上。知道youtube不能访问了，对于翻墙来说并无帮助。但是知道GFW是如何让我们不能访问youtube的，则对下一步的翻墙方案的选择和实施具有重大意义。所以在讨论如何翻之前，先要深入原理了解GFW是如何封的。</p><p>总的来说，GFW是一个分布式的入侵检测系统，并不是一个严格意义上的防火墙。不是说每个出入国境的IP包都需要先经过GFW的首可。做为一个入侵检测系统，GFW把你每一次访问facebook都看做一次入侵，然后在检测到入侵之后采取应对措施，也就是常见的连接重置。整个过程一般话来说就是：</p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-1.png" alt="learn-gfw-1"></p><p>检测有两种方式。一种是人工检测，一种是机器检测。你去国新办网站举报，就是参与了人工检测。在人工检测到不和谐的网站之后，就会采取一些应对方式来防止国内的网民访问该网站。对于这类的封锁，规避检测就不是技术问题了，只能从GFW采取的应对方式上采取反制措施。另外一类检测是机器检测，其检测过程又可以再进一步细分：</p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-2.png" alt="learn-gfw-2"></p><h2 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h2><p>重建是指GFW从网络上监听过往的IP包，然后分析其中的TCP协议，最后重建出一个完整的字节流。分析是在这个重建的字节流上分析具体的应用协议，比如HTTP协议。然后在应用协议中查找是不是有不和谐的内容，然后决定采用何种应对方式。</p><p>所以，GFW机器检测的第一步就是重建出一个字节流。那么GFW是如何拿到原始的IP包的呢？真正的GFW部署方式，外人根本无从得知。据猜测，GFW是部署在国家的出口路由器的旁路上，用“分光”的方式把IP包复制一份到另外一根光纤上，从而拿到所有进出国境的IP包。下图引在gfwrev.blogspot.com：</p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-3.png" alt="learn-gfw-3"></p><p>但是Google在北京有自己的机房。所以聪明的网友就使用Google的北京机房提供的GAE服务，用Goagent软件达到高速翻墙的目的。但是有网友证实（<a href="https://twitter.com/chengr28/status/260970749190365184" target="_blank" rel="noopener">https://twitter.com/chengr28/status/260970749190365184</a>），即便是北京的机房也会被骨干网丢包。事实上Google在北京的谷翔机房有一个独立的AS（BGP的概念）。这个AS与谷歌总部有一条IPV6的直连线路，所以通过这个机房可以用IPV6不受墙的限制出去。但是这个AS无论是连接国内还是国外都是要经过GFW的。所以机房在北京也不能保证国内访问不被墙。GFW通过配置骨干网的BGP路由规则，是可以让国内的机房也经过它的。另外一个例子是当我们访问被封的网站触发连接重置的时候，往往收到两个RST包，但是TTL不同。还有一个例子是对于被封的IP，访问的IP包还没有到达国际出口就已经被丢弃。所以GFW应该在其他地方也部署有设备，据推测是在省级骨干路由的位置。</p><p>对于GFW到底在哪这个话题，最近又有国外友人表达了兴趣（<a href="https://github.com/mothran/mongol" target="_blank" rel="noopener">https://github.com/mothran/mongol</a>）。笔者在前人的基础上写了一个更完备的<a href="https://github.com/fqrouter/qiang" target="_blank" rel="noopener">探测工具</a>。其原理是基于一个IP协议的特性叫TTL。TTL是Time to Live的简写。IP包在没经过一次路由的时候，路由器都会把IP包的TTL减去1。如果TTL到零了，路由器就不会再把IP包发给下一级路由。然后我们知道GFW会在监听到不和谐的IP包之后发回RST包来重置TCP连接。那么通过设置不同的TTL就可以知道从你的电脑，到GFW之间经过了几个路由器。比如说TTL设置成9不触发RST，但是10就触发RST，那么到GFW就是经过了10个路由器。另外一个IP协议的特性是当TTL耗尽的时候，路由器应该发回一个TTL EXCEEDED的ICMP包，并把自己的IP地址设置成SRC（来源）。结合这两点，就可以探测出IP包是到了IP地址为什么的路由器之后才被GFW检测到。有了IP地址之后，再结合IP地址地理位置的数据库就可以知道其地理位置。据说，得出的位置大概是这样的：</p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-4.jpg" alt="learn-gfw-4"></p><p>但是这里检测出来的IP到底是GFW的还是骨干路由器的？更有可能的是骨干路由器的IP。GFW做为一个设备用“分光”的方式挂在主干路由器旁边做入侵检测。无论如何，GFW通过某种神奇的方式，可以拿到你和国外服务器之间来往的所有的IP包，这点是肯定的。更严谨的理论研究有：<a href="http://pam2011.gatech.edu/papers/pam2011--Xu.pdf" target="_blank" rel="noopener">Internet Censorship in China: Where Does the Filtering Occur?</a></p><p>GFW在拥有了这些IP包之后，要做一个艰难的决定，那就是到底要不要让你和服务器之间的通信继续下去。GFW不能太过于激进，毕竟全国性的不能访问国外的网站是违反GFW自身存在价值的。GFW就需要在理解了IP包背后代表的含义之后，再来决定是不是可以安全的阻断你和国外服务器之间的连接。这种理解就要建立了前面说的“重建”这一步的基础上。大概用图表达一下重建是在怎么一回事：</p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-5.png" alt="learn-gfw-5"></p><p>重建需要做的事情就是把IP包1中的GET /inde和IP包2中的x.html H和IP包3中的TTP/1.1拼到一起变成GET /index.html HTTP/1.1。拼出来的数据可能是纯文本的，也可能是二进制加密的协议内容。具体是什么是你和服务器之间约定好的。GFW做为窃听者需要猜测才知道你们俩之间的交谈内容。对于HTTP协议就非常容易猜测了，因为HTTP的协议是标准化的，而且是未加密的。所以GFW可以在重建之后很容易的知道，你使用了HTTP协议，访问的是什么网站。</p><p>重建这样的字节流有一个难点是如何处理巨大的流量？这个问题在这篇<a href="http://gfwrev.blogspot.tw/2010/02/gfw.html" target="_blank" rel="noopener">博客</a>中已经讲得很明白了。其原理与网站的负载均衡器一样。对于给定的来源和目标，使用一个HASH算法取得一个节点值，然后把所有符合这个来源和目标的流量都往这个节点发。所以在一个节点上就可以重建一个TCP会话的单向字节流。</p><p>最后为了讨论完整，再提两点。虽然GFW的重建发生在旁路上是基于分光来实现的，但并不代表整个GFW的所有设备都在旁路。后面会提到有一些GFW应对形式必须是把一些GFW的设备部署在了主干路由上，比如对Google的HTTPS的间歇性丢包，也就是GFW是要参与部分IP的路由工作的。另外一点是，重建是单向的TCP流，也就是GFW根本不在乎双向的对话内容，它只根据监听到的一个方向的内容然后做判断。但是监听本身是双向的，也就是无论是从国内发到国外，还是从国外发到国内，都会被重建然后加以分析。所以一个TCP连接对于GFW来说会被重建成两个字节流。具体的证据会在后面谈如何直穿GFW中详细讲解。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分析是GFW在重建出字节流之后要做的第二步。对于重建来说，GFW主要处理IP协议，以及上一层的TCP和UDP协议就可以了。但是对于分析来说，GFW就需要理解各种各样的应用层的稀奇古怪的协议了。甚至，我们也可以自己发明新的协议。</p><p>总的来说，GFW做协议分析有两个相似，但是不同的目的。第一个目的是防止不和谐内容的传播，比如说使用Google搜索了“不该”搜索的关键字。第二个目的是防止使用翻墙工具绕过GFW的审查。下面列举一些已知的GFW能够处理的协议。</p><p>对于GFW具体是怎么达到目的一，也就是防止不和谐内容传播的就牵涉到对HTTP协议和DNS协议等几个协议的明文审查。大体的做法是这样的。</p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-6.png" alt="learn-gfw-6"></p><p>像HTTP这样的协议会有非常明显的特征供检测，所以第一步就没什么好说的了。当GFW发现了包是HTTP的包之后就会按照HTTP的协议规则拆包。这个拆包过程是GFW按照它对于协议的理解来做的。比如说，从HTTP的GET请求中取得请求的URL。然后GFW拿到这个请求的URL去与关键字做匹配，比如查找Twitter是否在请求的URL中。为什么有拆包这个过程？首先，拆包之后可以更精确的打击，防止误杀。另外可能预先做拆包，比全文匹配更节省资源。其次，xiaoxia和liruqi同学的<a href="https://github.com/liruqi/jjproxy" target="_blank" rel="noopener">jjproxy</a>的核心就是基于GFW的一个HTTP拆包的漏洞，当然这个bug已经被修复了。其原理就是GFW在拆解HTTP包的时候没有处理有多出来的rn这样的情况，但是你访问的google.com却可以正确处理额外的rn的情况。从这个例子中可以证明，GFW还是先去理解协议，然后才做关键字匹配的。关键字匹配应该就是使用了一些高效的正则表达式算法，没有什么可以讨论的。</p><p>HTTP代理和SOCKS代理，这两种明文的代理都可以被GFW识别。之前笔者认为GFW可以在识别到HTTP代理和SOCKS代理之后，再拆解其内部的HTTP协议的正文。也就是做两次拆包。但是分析发现，HTTP代理的关键字列表和HTTP的关键字列表是不一样的，所以笔者现在认为HTTP代理协议和SOCKS代理协议是当作单独的协议来处理的，并不是拆出载荷的HTTP请求再进行分析的。</p><p>目前已知的GFW会做的协议分析如下：</p><h3 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h3><p>GFW可以分析53端口的UDP协议的DNS查询。如果查询的域名匹配关键字则会被DNS劫持。可以肯定的是，这个匹配过程使用的是类似正则的机制，而不仅仅是一个黑名单，因为子域名实在太多了。证据是：2012年11月9日下午3点半开始，防火长城对Google的泛域名 .google.com 进行了大面积的污染，所有以 .google.com 结尾的域名均遭到污染而解析错误不能正常访问，其中甚至包括不存在的域名（来源：<a href="http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81</a>）</p><p>目前为止53端口之外的查询也没有被劫持。但是TCP的DNS查询已经可以被TCP RST切断了，表明了GFW具有这样的能力，只是不屑于大规模部署。而且TCP查询的关键字比UDP劫持的域名要少的多。目前只有dl.dropbox.com会触发TCP RST。相关的研究论文有：</p><ul><li><p><a href="http://corelabs.coresecurity.com/index.php?module=Wiki&amp;action=attachment&amp;type=researcher&amp;page=Ezequiel_Gutesman&amp;file=publication/Predicting_attacker_tools_risk_assessment/gutesman-abstract-4pgs.pdf" target="_blank" rel="noopener">Hold-On: Protecting Against On-Path DNS Poisoning</a></p></li><li><p><a href="http://cs.nyu.edu/~pcw216/work/nds/final.pdf" target="_blank" rel="noopener">The Great DNS Wall of China</a></p></li></ul><h3 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h3><p>GFW可以识别出HTTP协议，并且检查GET的URL与HOST。如果匹配了关键字则会触发TCP RST阻断。前面提到了jjproxy使用的构造特殊的HTTP GET请求欺骗GFW的做法已经失效，现在GFW只要看到rn就直接TCP RST阻断了（来源u/0/108661470402896863593/posts/6U6Q492M3yY）。相关的研究论文有：</p><ul><li><p><a href="http://www.internetfreedom.org/files/WhitePaper/ChinaGreatFirewallRevealed.pdf" target="_blank" rel="noopener">The Great Firewall Revealed</a></p></li><li><p><a href="http://www.cl.cam.ac.uk/~rnc1/ignoring.pdf" target="_blank" rel="noopener">Ignoring the Great Firewall of China</a></p></li><li><p><a href="http://gfwrev.blogspot.com/2010/03/http-url.html" target="_blank" rel="noopener">HTTP URL/深度关键字检测</a></p></li><li><p><a href="http://www.csd.uoc.gr/~hy558/papers/conceptdoppler.pdf" target="_blank" rel="noopener">ConceptDoppler: A Weather Tracker for Internet Censorship</a></p></li></ul><h3 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h3><p>GFW除了会分析上行的HTTP GET请求，对于HTTP返回的内容也会做全文关键字检查。这种检查与对请求的关键字检查不是由同一设备完成的，而且对GFW的资源消耗也更大。相关的研究论文有：</p><ul><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.191.206&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Empirical Study of a National-Scale Distributed Intrusion Detection System: Backbone-Level Filtering of HTML Responses in China</a></li></ul><h3 id="HTTP代理协议"><a href="#HTTP代理协议" class="headerlink" title="HTTP代理协议"></a>HTTP代理协议</h3><p>TODO</p><h3 id="SOCKS4-5代理协议"><a href="#SOCKS4-5代理协议" class="headerlink" title="SOCKS4/5代理协议"></a>SOCKS4/5代理协议</h3><p>TODO</p><h3 id="SMTP-协议"><a href="#SMTP-协议" class="headerlink" title="SMTP 协议"></a>SMTP 协议</h3><p>因为有很多翻墙软件都是以邮件索取下载地址的方式发布的，所以GFW有针对性的封锁了SMTP协议，阻止这样的邮件往来。</p><p>封锁有三种表现方式（<a href="http://fqrouter.tumblr.com/post/43400982633/gfw-smtp" target="_blank" rel="noopener">http://fqrouter.tumblr.com/post/43400982633/gfw-smtp</a>），简单概要的说就是看邮件是不是发往上了黑名单的邮件地址的（比如<a href="mailto:xiazai@upup.info" target="_blank" rel="noopener">xiazai@upup.info</a>就是一个上了黑名单的邮件地址），如果发现了就立马用TCP RST包切断连接。</p><h3 id="电驴-ed2k-协议"><a href="#电驴-ed2k-协议" class="headerlink" title="电驴(ed2k)协议"></a>电驴(ed2k)协议</h3><p>GFW还会过滤电驴（ed2k）协议中的查询内容。因为ed2k还有一个混淆模式，会加密往来的数据包，GFW会切断所有使用混淆模式的ed2k连接，迫使客户端使用明文与服务器通讯（<a href="http://fqrouter.tumblr.com/post/43490772120/gfw-ed2k" target="_blank" rel="noopener">http://fqrouter.tumblr.com/post/43490772120/gfw-ed2k</a>）。然后如果客户端发起了搜索请求，查找的关键字中包含敏感词的话就会被用TCP RST包切断连接。</p><h3 id="对翻墙流量的分析识别"><a href="#对翻墙流量的分析识别" class="headerlink" title="对翻墙流量的分析识别"></a>对翻墙流量的分析识别</h3><p>GFW的第二个目的是封杀翻墙软件。为了达到这个目的GFW采取的手段更加暴力。原因简单，对于HTTP协议的封杀如果做不好会影响互联网的正常运作，GFW与互联网是共生的关系，它不会做威胁自己存在的事情。但是对于TOR这样的几乎纯粹是为翻墙而存在的协议，只要检测出来就是格杀勿论的了。GFW具体是如何封杀各种翻墙协议的，我也不是很清楚，事态仍然在不断更新中。但是举两个例子来证明GFW的高超技术。</p><p>第一个例子是GFW对TOR的自动封杀，体现了GFW尽最大努力去理解协议本身。根据这篇<a href="https://blog.torproject.org/blog/knock-knock-knockin-bridges-doors" target="_blank" rel="noopener">博客</a>。使用中国的IP去连接一个美国的TOR网桥，会被GFW发现。然后GFW回头（15分钟之后）会亲自假装成客户端，用TOR的协议去连接那个网桥。如果确认是TOR的网桥，则会封当时的那个端口。换了端口之后，可以用一段时间，然后又会被封。这表现出了GFW对于协议的高超检测能力，可以从国际出口的流量中敏锐地发现你连接的TOR网桥。据TOR的同志说是因为TOR协议中的握手过程具有太明显的特征了。另外一点就表现了GFW的不辞辛劳，居然会自己伪装成客户端过去连连看。</p><p>第二个例子表现了GFW根本不在乎加密的流量中的具体内容是不是有敏感词。只要疑似翻墙，特别是提供商业服务给多个翻墙，就会被封杀。根据这个<a href="http://www.v2ex.com/t/55531" target="_blank" rel="noopener">帖子</a>，使用的ShadowSocks协议。预先部署密钥，没有明显的握手过程仍然被封。据说是GFW已经升级为能够机器识别出哪些加密的流量是疑似翻墙服务的。</p><p>关于GFW是如何识别与封锁翻墙服务器的，最近写了一篇文章提出我的猜想，大家可以去看看：<a href="http://fqrouter.tumblr.com/post/45969604783/gfw" target="_blank" rel="noopener">http://fqrouter.tumblr.com/post/45969604783/gfw</a>。</p><p>最近发现GFW对OpenVPN和SSL证书已经可以做到准实时的封IP（端口）。原理应该是离线做的深包分析，然后提取出可疑的IP列表，经过人工确认之后封IP。因为OpenVPN有显著的协议的特征，而且基本不用于商业场景所以很容易确认是翻墙服务。但是SSL也就是HTTPS用的加密协议也能基于“证书”做过滤不得不令人感到敬畏了。Shadowsocks的作者Clowwindy为此专门撰文:<a href="https://gist.github.com/clowwindy/5947691" target="_blank" rel="noopener">为什么不应该用SSL翻墙</a>。</p><p>总结起来就是，GFW已经基本上完成了目的一的所有工作。明文的协议从HTTP到SMTP都可以分析然后关键字检测，甚至电驴这样不是那么大众的协议GFW都去搞了。从原理上来说也没有什么好研究的，就是明文，拆包，关键字。GFW显然近期的工作重心在分析网络流量上，从中识别出哪些是翻墙的流量。这方面的研究还比较少，而且一个显著的特征是自己用没关系，大规模部署就容易出问题。我目前没有在GFW是如何封翻墙工具上有太多研究，只能是道听途说了。</p><h1 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h1><p>GFW的应对措施是三步中最明显的，因为它最直接。GFW的重建过程和协议分析的过程需要耐心的试探才能大概推测出GFW是怎么实现的。但是GFW的应对手段我们每天都可以见到，比如连接重置。GFW的应对目前可以感受到的只有一个目的就是阻断。但是从广义上来说，应对方式应该不限于阻断。比如说记录下日志，然后做统计分析，秋后算账什么的也可以算是一种应对。就阻断方式而言，其实并不多，那么我们一个个来列举吧。</p><h2 id="封IP"><a href="#封IP" class="headerlink" title="封IP"></a>封IP</h2><p>一般常见于人工检测之后的应对。还没有听说有什么方式可以直接使得GFW的机器检测直接封IP。一般常见的现象是GFW机器检测，然后用TCP RST重置来应对。过了一段时间才会被封IP，而且没有明显的时间规律。所以我的推测是，全局性的封IP应该是一种需要人工介入的。注意我强调了全局性的封IP，与之相对的是部分封IP，比如只对你访问那个IP封个3分钟，但是别人还是可以访问这样的。这是一种完全不同的封锁方式，虽然现象差不多，都是ping也ping不通。要观摩的话ping twitter.com就可以了，都封了好久了。</p><p>其实现方式是把无效的路由黑洞加入到主干路由器的路由表中，然后让这些主干网上的路由器去帮GFW把到指定IP的包给丢弃掉。路由器的路由表是动态更新的，使用的协议是BGP协议。GFW只需要维护一个被封的IP列表，然后用BGP协议广播出去就好了。然后国内主干网上的路由器都好像变成了GFW的一份子那样，成为了帮凶。</p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-7.png" alt="learn-gfw-7"></p><p>如果我们使用traceroute去检查这种被全局封锁的IP就可以发现，IP包还没有到GFW所在的国际出口就已经被电信或者联通的路由器给丢弃了。这就是BGP广播的作用了。</p><h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><p>这也是一种常见的人工检测之后的应对。人工发现一个不和谐网站，然后就把这个网站的域名给加到劫持列表中。其原理是基于DNS与IP协议的弱点，DNS与IP这两个协议都不验证服务器的权威性，而且DNS客户端会盲目地相信第一个收到的答案。所以你去查询facebook.com的话，GFW只要在正确的答案被返回之前抢答了，然后伪装成你查询的DNS服务器向你发错误的答案就可以了。</p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-8.png" alt="learn-gfw-8"></p><h2 id="TCP-RST阻断"><a href="#TCP-RST阻断" class="headerlink" title="TCP RST阻断"></a>TCP RST阻断</h2><p>TCP协议规定，只要看到RST包，连接立马被中断。从浏览器里来看就是连接已经被重置。我想对于这个错误大家都不陌生。据我个人观感，这种封锁方式是GFW目前的主要应对手段。大部分的RST是条件触发的，比如URL中包含某些关键字。目前享受这种待遇的网站就多得去了，著名的有facebook。还有一些网站，会被无条件RST。也就是针对特定的IP和端口，无论包的内容就会触发RST。比较著名的例子是https的wikipedia。GFW在TCP层的应对是利用了IPv4协议的弱点，也就是只要你在网络上，就假装成任何人发包。所以GFW可以很轻易地让你相信RST确实是Google发的，而让Google相信RST是你发的。</p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-9.png" alt="learn-gfw-9"></p><h2 id="封端口"><a href="#封端口" class="headerlink" title="封端口"></a>封端口</h2><p>GFW除了自身主体是挂在骨干路由器旁路上的入侵检测设备，利用分光技术从这个骨干路由器抓包下来做入侵检测 (所谓 IDS)，除此之外这个路由器还会被用来封端口 (所谓 IPS)。GFW在检测到入侵之后可以不仅仅可以用TCP RST阻断当前这个连接，而且利用骨干路由器还可以对指定的IP或者端口进行从封端口到封IP，设置选择性丢包的各种封禁措施。可以理解为骨干路由器上具有了类似“iptables”的能力（网络层和传输层的实时拆包，匹配规则的能力）。这个iptables的能力在CISCO路由器上叫做ACL Based Forwarding (ABF)。而且规则的部署是全国同步的，一台路由器封了你的端口，全国的挂了GFW的骨干路由器都会封。一般这种封端口都是针对翻墙服务器的，如果检测到服务器是用SSH或者VPN等方式提供翻墙服务。GFW会在全国的出口骨干路由上部署这样的一条ACL规则，来封你这个服务器+端口的下行数据包。也就是如果包是从国外发向国内的，而且src（源ip）是被封的服务器ip，sport（源端口）是被封的端口，那么这个包就会被过滤掉。这样部署的规则的特点是，上行的数据包是可以被服务器收到的，而下行的数据包会被过滤掉。</p><p>如果被封端口之后服务器采取更换端口的应对措施，很快会再次被封。而且多次尝试之后会被封IP。初步推断是，封端口不是GFW的自动应对行为，而是采取黑名单加人工过滤地方式实现的。一个推断的理由就是网友报道，封端口都是发生在白天工作时间。</p><p>在进入了封端口阶段之后，还会有继发性的临时性封其他端口的现象，但是这些继发性的封锁具有明显的超时时间，触发了之后（触发条件不是非常明确）会立即被封锁，然后过了一段时间就自动解封。目前对于这一波封SSH/OPENVPN采用的以封端口为明显特征的封锁方式研究尚不深入。可以参考我最近写的一篇<a href="http://fqrouter.tumblr.com/post/45969604783/gfw" target="_blank" rel="noopener">文章</a></p><p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-10.png" alt="learn-gfw-10"></p><h2 id="HTTPS间歇性丢包"><a href="#HTTPS间歇性丢包" class="headerlink" title="HTTPS间歇性丢包"></a>HTTPS间歇性丢包</h2><p>对于Google的HTTPS服务，GFW不愿意让其完全不能访问。所以采取的办法是对于Google的某些IP的443端口采取间歇性丢包的措施。其原理应该类似于封端口，是在骨干路由器上做的丢包动作。但是触发条件并不只是看IP和端口，加上了时间间隔这样一个条件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘自：&lt;a href=&quot;https://docs.google.com/document/d/1mmMiMYbviMxJ-DhTyIGdK7OOg581LSD1CZV4XY1OMG8/edit#heading=h.qgojh5xsppyz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;翻墙路由器的实现与原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：本文只供研究学习网络技术使用，请阅读者在24小时内忘记本文内容，谢绝网监请喝茶。&lt;/p&gt;
&lt;p&gt;GFW会是一个长期的存在。要学会与之共存，必须先了解GFW是什么。做为局外人，学习GFW有六个角度。渐进的来看分别是：&lt;/p&gt;
&lt;p&gt;首先我们学习到的是WHAT和WHEN。比如说，你经常听到人的议论是“昨天”，“github”被封了。其中的昨天就是WHEN，github就是WHAT。这是学习GFW的最天然，最朴素的角度。在这个方面做得非常极致的是一个叫做&lt;a href=&quot;https://en.greatfire.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;greatfire&lt;/a&gt;的网站。这个网站长期监控成千上万个网站和关键词。通过长期监控，不但可以掌握WHAT被封锁了，还可以知道WHEN被封的，WHEN被解封的。&lt;/p&gt;
    
    </summary>
    
      <category term="网络技术" scheme="http://allenn.cn/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="GFW" scheme="http://allenn.cn/tags/GFW/"/>
    
      <category term="防火墙" scheme="http://allenn.cn/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
      <category term="研究" scheme="http://allenn.cn/tags/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>解决mac升级10.11后，出现的 xcrun: error: invalid active developer path, missing xcrun 错误</title>
    <link href="http://allenn.cn/articles/2016-09/after-update-macosx-git-failed/"/>
    <id>http://allenn.cn/articles/2016-09/after-update-macosx-git-failed/</id>
    <published>2016-09-24T05:50:39.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>前天把小mac升级到了10.11，结果今天在终端里使用git的时候，弹出一行莫名其妙的错误：<code>xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</code>。去google了一圈，找到了一个github上homebrew issues里很老的帖子，按着里面说的，重装了一下xcode command line，结果就正常了……</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>不过看帖子里并不是所有人重装都能解决问题，有些人似乎还要手动切换下xcode的路径才能解决。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo xcode-select -switch /</span><br></pre></td></tr></table></figure><p>因为帖子标题说是在升级到“冲浪湾”时遇到了这问题，所以看来这问题属于每次升级时候都会碰到的月经型问题了OTL。问题解决后，我又去各处翻了下问题出现的原因，可惜没有找到。个人推断可能是因为git所需的lib关联到了command line tools，升级时改动了lib的路径所致吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前天把小mac升级到了10.11，结果今天在终端里使用git的时候，弹出一行莫名其妙的错误：&lt;code&gt;xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), mi
      
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mac OS X" scheme="http://allenn.cn/tags/Mac-OS-X/"/>
    
      <category term="git" scheme="http://allenn.cn/tags/git/"/>
    
      <category term="升级" scheme="http://allenn.cn/tags/%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Sed 命令详解</title>
    <link href="http://allenn.cn/articles/2016-09/sed-usage/"/>
    <id>http://allenn.cn/articles/2016-09/sed-usage/</id>
    <published>2016-09-17T11:27:03.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p><h2 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed [option] 'command' input_file</span><br></pre></td></tr></table></figure><p>常用的option有如下几种：</p><ul><li><code>-n</code> 使用安静(silent)模式。默认条件下，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有在脚本中使用<code>p</code>，被匹配的行才会被列出来，比如：<code>sed -n &#39;/&lt;HTML&gt;/p&#39;</code>（仅显示<html>这一行）；</html></li><li><code>-e</code> 用于执行多个编辑命令，如：<code>sed -e &#39;1,3s/my/your/g&#39; -e &#39;3,$s/This/That/g&#39; my.txt</code>；</li><li><code>-f</code> 从 script-file 中读取 sed 编辑命令，可以将多个编辑命令写在文件中，使用<code>sed -f script-file ...</code>读取；</li><li><code>-r</code> 让sed命令支持扩展的正则表达式(默认是基础正则表达式)；</li><li><code>-i</code> 直接修改读取的文件内容，默认下，sed 不会直接修改文件，当提供<code>-i</code>选项时 sed 会直接修改文件内容。</li></ul><a id="more"></a><p>常用的命令有以下几种：</p><ul><li><code>a \</code>： 在匹配的行下新起一行，追加字符串，<code>a \</code>的后面跟上字符串(多行字符串可以用<code>\n</code>分隔)；</li><li><code>c \</code>： 取代/替换字符串，<code>c \</code>后面跟上字符串s(多行字符串可以用<code>\n</code>分隔)，会将当前选中的行替换成字符串s；</li><li><code>d</code>： delete即删除，该命令会将当前选中的行删除；</li><li><code>i \</code>： insert即插入字符串，<code>i \</code>后面跟上字符串s(多行字符串可以用\n分隔)，则会在当前选中的行的前面都插入字符串s；</li><li><code>p</code>： print即打印，该命令会打印当前选择的行到屏幕上，通常同<code>-n</code>一起使用，打印选中的行；</li><li><code>s</code>： 替换，通常s命令的用法是这样的：s/old/new/g，将old字符串替换成new字符串</li></ul><h2 id="多个匹配"><a href="#多个匹配" class="headerlink" title="多个匹配"></a>多个匹配</h2><p>有时我们需要一次进行多次匹配，可参考下面的示例：（第一个模式把第一行到第三行的my替换成your，第二个则把第3行以后的This替换成了That）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &apos;1,3s/my/your/g; 3,$s/This/That/g&apos; my.txt</span><br><span class="line">This is your cat, your cat&apos;s name is betty</span><br><span class="line">This is your dog, your dog&apos;s name is frank</span><br><span class="line">That is your fish, your fish&apos;s name is george</span><br><span class="line">That is my goat, my goat&apos;s name is adam</span><br></pre></td></tr></table></figure><p>上面的命令等价于：（注：下面使用的是sed的-e命令行参数）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -e &apos;1,3s/my/your/g&apos; -e &apos;3,$s/This/That/g&apos; my.txt</span><br></pre></td></tr></table></figure><p>我们可以使用&amp;来当做被匹配的变量，然后可以在基本左右加点东西。如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &apos;s/my/[&amp;]/g&apos; my.txt</span><br><span class="line">This is [my] cat, [my] cat&apos;s name is betty</span><br><span class="line">This is [my] dog, [my] dog&apos;s name is frank</span><br><span class="line">This is [my] fish, [my] fish&apos;s name is george</span><br><span class="line">This is [my] goat, [my] goat&apos;s name is adam</span><br></pre></td></tr></table></figure><h2 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h2><p>假设有一个本地文件test.txt，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat test.txt</span></span><br><span class="line"></span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br><span class="line">this is fourth line</span><br><span class="line">this fifth line</span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本节将使用该文件详细演示每一个命令的用法。</p><h3 id="a命令"><a href="#a命令" class="headerlink" title="a命令"></a>a命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'1a \add one'</span> test.txt</span></span><br><span class="line">this is first line</span><br><span class="line">add one</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br><span class="line">this is fourth line</span><br><span class="line">this is fifth line</span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本例命令部分中的1表示第一行，同样的第二行写成2，第一行到第三行写成<code>1,3</code>，用<code>$</code>表示最后一行，比如<code>2,$</code>表示第二行到最后一行中间所有的行(包含第二行和最后一行)。<br>本例的作用是在第一行之后增加字符串”add one”，从输出可以看到具体效果。需要注意的是在 Mac OS X 系统上，<code>a \</code>后的追加文本需要另起一行写，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &apos;1a \</span><br><span class="line">&gt;add one&apos; test.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'1,$a \add one'</span> test.txt</span></span><br><span class="line">this is first line</span><br><span class="line">add one</span><br><span class="line">this is second line</span><br><span class="line">add one</span><br><span class="line">this is third line</span><br><span class="line">add one</span><br><span class="line">this is fourth line</span><br><span class="line">add one</span><br><span class="line">this is fifth line</span><br><span class="line">add one</span><br><span class="line">happy everyday</span><br><span class="line">add one</span><br><span class="line">end</span><br><span class="line">add one</span><br></pre></td></tr></table></figure><p>本例表示在第一行和最后一行所有的行后面都加上”add one”字符串，从输出可以看到效果。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'/first/a \add one'</span> test.txt</span></span><br><span class="line">this is first line</span><br><span class="line">add one</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br><span class="line">this is fourth line</span><br><span class="line">this is fifth line</span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本例表示在包含”first”字符串的行的后面加上字符串”add one”，从输出可以看到第一行包含first，所以第一行之后增加了”add one”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &apos;/^ha.*day$/a \add one&apos; test.txt</span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br><span class="line">this is fourth line</span><br><span class="line">this is fifth line</span><br><span class="line">happy everyday</span><br><span class="line">add one</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本例使用正则表达式匹配行，<code>^ha.*day$</code>表示以ha开头，以day结尾的行，则可以匹配到文件的”happy everyday”这样，所以在该行后面增加了”add one”字符串。</p><h3 id="i命令"><a href="#i命令" class="headerlink" title="i命令"></a>i命令</h3><p>i命令使用方法和a命令一样的，只不过是在匹配的行的前面插入字符串，所以直接将上面a命令的示例的a替换成i即可，在此就不啰嗦了。</p><h3 id="c命令"><a href="#c命令" class="headerlink" title="c命令"></a>c命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'$c \add one'</span> test.txt</span></span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br><span class="line">this is fourth line</span><br><span class="line">this is     fifth line</span><br><span class="line">happy everyday</span><br><span class="line">add one</span><br></pre></td></tr></table></figure><p>本例表示将最后一行替换成字符串”add one”，从输出可以看到效果。同<code>a</code>命令一样在 Mac OS X 系统上，<code>c \</code>后文本需要另起一行写，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &apos;$c \</span><br><span class="line">&gt;add one&apos; test.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'4,$c \add one'</span> test.txt</span></span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br><span class="line">add one</span><br></pre></td></tr></table></figure><p>本例将第四行到最后一行的内容替换成字符串”add one”。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'/^ha.*day$/c \replace line'</span> test.txt</span></span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br><span class="line">this is fourth line</span><br><span class="line">this is fifth line</span><br><span class="line">replace line</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本例将以ha开头，以day结尾的行替换成”replace line”。</p><h3 id="d命令"><a href="#d命令" class="headerlink" title="d命令"></a>d命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'/^ha.*day$/d'</span> test.txt</span></span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br><span class="line">this is fourth line</span><br><span class="line">this is fifth line</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本例删除以<code>ha</code>开头，以<code>day</code>结尾的行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'4,$d'</span> test.txt</span></span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br></pre></td></tr></table></figure><p>本例删除第四行到最后一行中的内容。</p><h3 id="p命令"><a href="#p命令" class="headerlink" title="p命令"></a>p命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed -n <span class="string">'4,$p'</span> test.txt</span></span><br><span class="line">this is fourth line</span><br><span class="line">this is fifth line</span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本例在屏幕上打印第四行到最后一行的内容，p命令一般和-n选项一起使用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed -n <span class="string">'/^ha.*day$/p'</span> test.txt</span></span><br><span class="line">happy everyday</span><br></pre></td></tr></table></figure><p>本例打印以<code>ha</code>开始，以<code>day</code>结尾的行。</p><h3 id="s命令"><a href="#s命令" class="headerlink" title="s命令"></a>s命令</h3><p>实际运用中s命令式最常使用到的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/line/text/g'</span> test.txt</span></span><br><span class="line">this is first text</span><br><span class="line">this is second text</span><br><span class="line">this is third text</span><br><span class="line">this is fourth text</span><br><span class="line">this is fifth text</span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本例将文件中的所有line替换成text，最后的<code>g</code>是global的意思，也就是全局替换，如果不加g，则只会替换本行的第一个line。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'/^ha.*day$/s/happy/very happy/g'</span> test.txt</span></span><br><span class="line">this is first line</span><br><span class="line">this is second line</span><br><span class="line">this is third line</span><br><span class="line">this is fourth line</span><br><span class="line">this is fifth line</span><br><span class="line">very happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>本例首先匹配以ha开始，以day结尾的行，本例中匹配到的行是”happy everyday”这样，然后再将该行中的happy替换成very happy。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/\(.*\)line$/\1/g'</span> test.txt</span></span><br><span class="line">this is first</span><br><span class="line">this is second</span><br><span class="line">this is third</span><br><span class="line">this is fourth</span><br><span class="line">this is fifth</span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这个例子有点复杂，先分解一下。首先s命令的模式是s/old/new/g这样的，所以本例的old部分即<code>\(.*\)line$</code>，sed命令中使用<code>\(\)</code>包裹的内容表示正则表达式的第n部分，序号从1开始计算，本例中只有一个<code>\(\)</code>所以<code>\(.*\)</code>表示正则表达式的第一部分，这部分匹配任意字符串，所以<code>\(.*\)line$</code>匹配的就是以line结尾的任何行。然后将匹配到的行替换成正则表达式的第一部分（本例中相当于删除line部分），使用<code>\1</code>表示匹配到的第一部分，同样<code>\2</code>表示第二部分，<code>\3</code>表示第三部分，可以依次这样引用。比如下面的例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'s/\(.*\)is\(.*\)line/\1\2/g'</span> test.txt</span></span><br><span class="line">this  first</span><br><span class="line">this  second</span><br><span class="line">this  third</span><br><span class="line">this  fourth</span><br><span class="line">this  fifth</span><br><span class="line">happy everyday</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>正则表达式中is两边的部分可以用<code>\1</code>和<code>\2</code>表示，该例子的作用其实就是删除中间部分的is。</p><h2 id="一些关于-sed-的基础知识"><a href="#一些关于-sed-的基础知识" class="headerlink" title="一些关于 sed 的基础知识"></a>一些关于 sed 的基础知识</h2><p>前面通过实例说完了 sed 的运用，下面来说一些和 sed 相关的基础知识</p><h3 id="Pattern-Space"><a href="#Pattern-Space" class="headerlink" title="Pattern Space"></a>Pattern Space</h3><p>什么是Pattern Space，Pattern space相当于车间sed把流内容在这里处理，你可以将pattern space看成是一个流水线，所有的动作都是在“流水线”上执行的。不理解？没关系，我们来看看 sed 的伪代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foreach line in file &#123;</span><br><span class="line">    //放入把行Pattern_Space</span><br><span class="line">    Pattern_Space &lt;= line;</span><br><span class="line"></span><br><span class="line">    // 对每个pattern space执行sed命令</span><br><span class="line">    Pattern_Space &lt;= EXEC(sed_cmd, Pattern_Space);</span><br><span class="line"></span><br><span class="line">    // 如果没有指定 -n 则输出处理后的Pattern_Space</span><br><span class="line">    if (sed option hasn&apos;t &quot;-n&quot;)  &#123;</span><br><span class="line">       print Pattern_Space</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/images/sed-usage/pattern-space.png" alt="sed 执行流程图"></p><h3 id="Hold-Space"><a href="#Hold-Space" class="headerlink" title="Hold Space"></a>Hold Space</h3><p>什么是Hold Space？Hold space相当于仓库，加工的半成品在这里临时储存。由于各种各样的原因，比如用户希望在某个条件下脚本中的某个命令被执行，或者希望模式空间得到保留以便下一次的处理，都有可能使得sed在处理文件的时候不按照正常的流程来进行。这个时候，sed设置了一些高级命令来满足用户的要求。</p><ul><li>g：[address[,address]]g 将hold space中的内容拷贝到pattern space中，原来pattern space里的内容清除</li><li>G：[address[,address]]G 将hold space中的内容append到pattern space后</li><li>h：[address[,address]]h 将pattern space中的内容拷贝到hold space中，原来的hold space里的内容被清除</li><li>H：[address[,address]]H 将pattern space中的内容append到hold space后</li><li>x： 交换pattern space和hold space的内容</li></ul><p>那么这些命令怎么用呢，我们来看些例子，示例文件如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat t.txt</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure></p><p>如果我需要使用 sed 完成文件倒序输出要怎么做呢？你可以这样写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &apos;1!G;h;$!d&apos; t.txt</span><br></pre></td></tr></table></figure><p>其中的 ‘1!G;h;$!d’ 可拆解为三个命令</p><ul><li><code>1!G</code> —— 只有第一行不执行G命令，将hold space中的内容append回到pattern space</li><li><code>h</code> —— 第一行都执行h命令，将pattern space中的内容拷贝到hold space中</li><li><code>$!d</code> —— 除了最后一行不执行d命令，其它行都执行d命令，删除当前行</li></ul><p><img src="/assets/images/sed-usage/sed_demo.jpg" alt="执行序列"></p><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>通过 Address 可以指定 Sed 地址/操作范围，Address 可以是一个数字，也可以是一个模式。用逗号分割两个 Address 表示匹配两个 Address 的区间：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[address[,address]][!]&#123;cmd&#125;</span><br></pre></td></tr></table></figure><p>其中的!表示匹配成功后是否执行命令，Address 也可以使用相对位置，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 其中的+3表示后面连续3行</span><br><span class="line">$ sed &apos;/dog/,+3s/^/# /g&apos; pets.txt</span><br><span class="line">This is my cat</span><br><span class="line">  my cat&apos;s name is betty</span><br><span class="line"># This is my dog</span><br><span class="line">#   my dog&apos;s name is frank</span><br><span class="line"># This is my fish</span><br><span class="line">#   my fish&apos;s name is george</span><br><span class="line">This is my goat</span><br><span class="line">  my goat&apos;s name is adam</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。&lt;/p&gt;
&lt;h2 id=&quot;使用语法&quot;&gt;&lt;a href=&quot;#使用语法&quot; class=&quot;headerlink&quot; title=&quot;使用语法&quot;&gt;&lt;/a&gt;使用语法&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed [option] &#39;command&#39; input_file&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;常用的option有如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt; 使用安静(silent)模式。默认条件下，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有在脚本中使用&lt;code&gt;p&lt;/code&gt;，被匹配的行才会被列出来，比如：&lt;code&gt;sed -n &amp;#39;/&amp;lt;HTML&amp;gt;/p&amp;#39;&lt;/code&gt;（仅显示&lt;html&gt;这一行）；&lt;/html&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; 用于执行多个编辑命令，如：&lt;code&gt;sed -e &amp;#39;1,3s/my/your/g&amp;#39; -e &amp;#39;3,$s/This/That/g&amp;#39; my.txt&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 从 script-file 中读取 sed 编辑命令，可以将多个编辑命令写在文件中，使用&lt;code&gt;sed -f script-file ...&lt;/code&gt;读取；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 让sed命令支持扩展的正则表达式(默认是基础正则表达式)；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; 直接修改读取的文件内容，默认下，sed 不会直接修改文件，当提供&lt;code&gt;-i&lt;/code&gt;选项时 sed 会直接修改文件内容。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://allenn.cn/tags/Linux/"/>
    
      <category term="Shell" scheme="http://allenn.cn/tags/Shell/"/>
    
      <category term="sed" scheme="http://allenn.cn/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>由 Java 到 Scala：如何优雅的跳出循环</title>
    <link href="http://allenn.cn/articles/2016-09/how-to-break-loop-scala/"/>
    <id>http://allenn.cn/articles/2016-09/how-to-break-loop-scala/</id>
    <published>2016-09-16T11:27:03.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，我们经常会遇到这样的需求：循环执行某个操作，当满足一定条件的时候循环终止。最常见的场景就是累加数组中的元素，一直到大于某个值，用伪代码来描述就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DO LOOP&#123;</span><br><span class="line">  DO SOME THING</span><br><span class="line">  IF SOME CONDITION</span><br><span class="line">    BREAK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果我们使用 Java 来完成这样的需求，我们会这样完成我们的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List[1,2,3,4,5,6]</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i ++)&#123;</span><br><span class="line">  sum += list.get(i);</span><br><span class="line">  <span class="keyword">if</span>(sum &gt; <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中，我们用一个<code>break</code>语句，就完成的从循环中跳出的工作。但在 Scala 中我们应该怎么做呢？要知道 Scala 特地没有在内置控制结构中包含 break 和 continue 是因为这两个控制结构和函数式编程有点格格不入。那么下面我将介绍几种在 Scala 中跳出循环的方法。</p><h3 id="使用Return语句"><a href="#使用Return语句" class="headerlink" title="使用Return语句"></a>使用Return语句</h3><p>没有<code>break</code>语句，那么作为 Java 的开发人员，第一时间就会想到<code>return</code>，还好 Scala 支持<code>return</code></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List[1,2,3,4,5,6]</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">list.foreach(i =&gt;&#123;</span><br><span class="line">  sum += i</span><br><span class="line">  <span class="keyword">if</span>(sum &gt; <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用Breaks"><a href="#使用Breaks" class="headerlink" title="使用Breaks"></a>使用Breaks</h3><p>在 Scala 2.8以上版本中，Scala 增加了<code>scala.util.control.Breaks</code>包，通过导入这个包，你可以在 Scala 中写出和 Java 中相似的带<code>break</code>语句的循环。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>._</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">breakable &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) &#123;</span><br><span class="line">   sum += i</span><br><span class="line">   <span class="keyword">if</span> (sum &gt;= <span class="number">4</span>) <span class="keyword">break</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这并不代表 Scala 从 2.8 版本开始支持<code>break</code>语句，它的实现实际是通过抛出异常给上级调用函数来达到控制循环的目的。<code>Breaks</code>的关键代码如下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breakable</span></span>(op: =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    op</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ex: <span class="type">BreakControl</span> =&gt;</span><br><span class="line">      <span class="keyword">if</span> (ex ne breakException) <span class="keyword">throw</span> ex</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，使用<code>Breaks</code>就等价于下面的代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AllDone</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) &#123; sum += i; <span class="keyword">if</span> (sum&gt;=<span class="number">4</span>) <span class="keyword">throw</span> <span class="type">AllDone</span> &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">AllDone</span> =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些优雅的方法"><a href="#一些优雅的方法" class="headerlink" title="一些优雅的方法"></a>一些优雅的方法</h2><p>上面的方法虽然可以达到我们的目的，但和优雅还是差点距离，下面就回到我们的主题：如何优雅的跳出循环。</p><h3 id="使用-Stream"><a href="#使用-Stream" class="headerlink" title="使用 Stream"></a>使用 Stream</h3><p>Stream 是个很有意思的结构，它和列表相似，只不过它会延迟计算下一个元素，仅当需要的时候才会去计算。运用 Stream 的这个特性，我们可以用一种优雅的方式达到我们跳出循环的目的</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">(<span class="number">0</span> to <span class="number">6</span>).toStream.takeWhile(_ =&gt; sum &lt; <span class="number">4</span>).foreach(i =&gt; sum+=i)</span><br></pre></td></tr></table></figure><p>你可能会觉得这个程序有 Bug，因为咋一看<code>takeWhile</code>中并没有进行累加，只比较了<code>sum &lt; 4</code>，而累加是在<code>foreach</code>中做的，<code>takeWhile</code>的条件应该永远为<code>true</code>，导致最后的结果是错误的。那么到底会不会这样呢？答案是：不会。因为 Stream 是 Lazy 的，它会延迟计算下一个元素，在这个例子中，<code>takeWhile(_ =&gt; sum &lt; 4)</code>只会在每次<code>foreach</code>需要取 Stream 中的一个元素出来累加的时候才会执行一次，这就保证了判断条件的有效性。大致的执行序列如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// List[1,2,3,4,5,6]</span><br><span class="line">var sum = 0</span><br><span class="line">takeWhile(_ =&gt; 0 &lt; 4)</span><br><span class="line">foreach(1 =&gt; 0+=1)</span><br><span class="line">var sum = 1</span><br><span class="line">takeWhile(_ =&gt; 1 &lt; 4)</span><br><span class="line">foreach(2 =&gt; 1+=2)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="使用递归代替循环"><a href="#使用递归代替循环" class="headerlink" title="使用递归代替循环"></a>使用递归代替循环</h3><p>还有一种方法就是使用递归代替循环</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTo</span></span>(i: <span class="type">Int</span>, max: <span class="type">Int</span>) &#123;</span><br><span class="line">  sum += i; <span class="keyword">if</span> (sum &lt; max) addTo(i+<span class="number">1</span>,max)</span><br><span class="line">&#125;</span><br><span class="line">addTo(<span class="number">0</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中，我们经常会遇到这样的需求：循环执行某个操作，当满足一定条件的时候循环终止。最常见的场景就是累加数组中的元素，一直到大于某个值，用伪代码来描述就是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DO LOOP&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  DO SOME THING&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  IF SOME CONDITION&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BREAK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Scala" scheme="http://allenn.cn/tags/Scala/"/>
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="跳出循环" scheme="http://allenn.cn/tags/%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>为什么java.util.concurrent 包里没有并发的ArrayList实现？</title>
    <link href="http://allenn.cn/articles/2016-09/why-not-concurrency-arraylist/"/>
    <id>http://allenn.cn/articles/2016-09/why-not-concurrency-arraylist/</id>
    <published>2016-09-07T11:27:03.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>问：JDK 5在 java.util.concurrent 里引入了 ConcurrentHashMap，在需要支持高并发的场景，我们可以使用它代替 HashMap。但是为什么没有 ArrayList 的并发实现呢？难道在多线程场景下我们只有 Vector 这一种线程安全的数组实现可以选择么？为什么在 java.util.concurrent 没有一个类可以代替 Vector 呢？</p><p>答：我认为在 java.util.concurrent 包中没有加入并发的 ArrayList 实现的主要原因是：很难去开发一个通用并且没有并发瓶颈的线程安全的 List。像 ConcurrentHashMap 这样的类的真正价值（The real point / value of classes）并不是它们保证了线程安全。而在于它们在保证线程安全的同时不存在并发瓶颈。举个例子，ConcurrentHashMap 采用了锁分段技术和弱一致性的Map迭代器去规避并发瓶颈。所以问题在于，像“Array List”这样的数据结构，你不知道如何去规避并发的瓶颈。拿contains() 这样一个操作来说，当你进行搜索的时候如何避免锁住整个 list？另一方面，Queue 和 Deque (基于Linked List)有并发的实现是因为他们的接口相比List的接口有更多的限制，这些限制使得实现并发成为可能。CopyOnWriteArrayList 是一个有趣的例子，它规避了只读操作（如 get/contains）并发的瓶颈，但是它为了做到这点，在修改操作中做了很多工作和修改可见性规则。 此外，修改操作还会锁住整个List，因此这也是一个并发瓶颈。所以从理论上来说，CopyOnWriteArrayList 并不算是一个通用的并发 List。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问：JDK 5在 java.util.concurrent 里引入了 ConcurrentHashMap，在需要支持高并发的场景，我们可以使用它代替 HashMap。但是为什么没有 ArrayList 的并发实现呢？难道在多线程场景下我们只有 Vector 这一种线程安全的
      
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://allenn.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://allenn.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>玩花招的PowerMock</title>
    <link href="http://allenn.cn/articles/2016-09/play-trick-with-powermock/"/>
    <id>http://allenn.cn/articles/2016-09/play-trick-with-powermock/</id>
    <published>2016-09-01T15:31:03.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载至：<a href="http://agiledon.github.io/blog/2013/11/21/play-trick-with-powermock/" target="_blank" rel="noopener">逸言</a>，感谢原作者的精彩分享</p><p>当我们面对一个遗留系统时，常见的问题是没有测试。正如Michael Feathers在Working Effectively with Legacy Code一书中对“遗留代码”的定义。他将其简单归纳为“没有测试的代码”。真是太贴切了！正是因为没有测试，使得我们对遗留代码的任何重构都有些战战兢兢，甚至成为开发人员抵制重构的借口。从收益与成本的比例来看，对于这样的系统，我一贯认为不要盲目进行重构。因为重构的真正适用场景其实是发生在开发期间，而非维护期间。当然，提升自己的重构能力，尤其学会运用IDE提供的自动重构工具，可以在一定程度上保障重构的质量。然而，安全的做法，还是需要为其编写测试。</p><a id="more"></a><p>测试是分层的，即使是针对自动化测试。面对遗留系统，成本相对较低的是针对功能特性编写的功能测试（或者说是验收测试），这可以运用一些BDD框架如Cucumber、JBehave等。由于它的测试粒度较粗，可以以较少的测试用例覆盖系统的主要功能。然而，它的缺点同样存在，那就是反馈周期相对较长。这就好像你置身一个陌生的城市，在找不到路的情况下，只是跟着感觉走。走了数十公里之后，方才幡然醒悟，想起要翻一翻带在手上的地图。倘若发现方向走错，再要回转就已经晚了。反馈周期最短的自然是单元测试。同样根据Michael Feather的定义，单元测试一定要快，一定要不依赖于外部资源。单元测试的粒度自然是最小的，但不要直观地认为单元测试就是针对方法。若只是针对方法来编写单元测试，就会陷入为测试而测试的怪圈。即使是位于技术象限的单元测试，我们仍然要按照业务规则来编写。一个测试方法应该对应一个粒度最小的原子功能。</p><p>要让单元测试跑得快，还要不吃草（依赖外部资源），应该怎么办？答案呼之欲出，那就是Mock。Mock当然不是万能的，记得胡凯写过一篇文章，提及Mock不是银弹。我知道他仅仅是为了强调这个观点，避免太多人过于依赖Mock，因为Brooks早就发表过论断，在软件行业，其实根本就“没有银弹”。关于Mock的争论由来已久，对此，我准备避而不谈。至少在我看来，如下几点基本已成定论：</p><p>1、是Mock行为，而非Mock数据；如果是针对数据，则应该属于Stub的范畴；</p><p>2、Mock通常发生在三种情况（让我们假设被测试对象为消费者，它要协作的对象为服务，此时需要Mock服务）：服务的行为只有定义，还未实现；服务需要访问外部资源（这意味着它可能很慢，也意味着它需要依赖外部资源）；服务的行为结果不确定（例如天气服务，股票服务）。</p><p>自然，我们不需要自己写Mock，有许多现成的好用框架，例如Java平台下的Mockito与EasyMock，.NET平台下的Moq，以及C++下的Google Mock和MockCpp。</p><p>然而，问题依然存在。考虑这样两种情况：</p><p>1、当我们要Mock的服务，其实是Utils的静态方法时，应该怎么办？</p><p>2、当我们要测试的方法内部直接实例化了协作的服务对象，又该怎么办？</p><p>显然，这是设计和代码的坏味道，它明显违背了DIP原则，即它不应该依赖于细节，而应该依赖于抽象。换言之，它产生了对服务对象的具体依赖。若要遵循DIP，就应该在被测对象的外部来注入依赖。这种紧耦合酿成了我们设计的类不具备良好的可测试性。</p><p>一个蠢蠢欲动的声音在说：让我们重构吧！且住，先让我们把这苛求的眼光放柔和一点。当你视所有丑陋的代码为“蝼蚁”时，那是因为你站在了足够的高度。可是站得太高，往往摔得更惨。现在，还是脚踏实地，先设身处地地考虑这样的场景：这是一个代码行数超过1000万行的软件系统，一共有十余个开发团队，一百多名开发人员在这个团队中工作。这个系统几乎没有测试，而系统的Jar包则达到上千个。这些Utils的静态方法被数十乃至上百个类调用，牵涉到的模块也有多个甚至十余个。而且，这个系统并没有引入任何一个IoC容器。有了这样一个背景，让我们再把柔和的眼光变得锐利一点，分析分析重构的可行性。要消除前面提到的坏味道，就需要将这些静态方法修改为实例方法，并通过依赖注入的方式注入。这个变化带来的是对整个系统的全局影响，即使我们有一些自动化重构的手段，仍然不认为这种重构一定就是可行的。</p><p>这就是我要谈PowerMock的前提！</p><p>现在，轮到玩花招的PowerMock出场了。有了它，什么静态方法，方法内部实例，乃至私有方法，统统都是浮云。而且，它对Mockito与EasyMock的扩展，使得我们更容易熟悉它的语法。要使用它很简单，需先设置对它的依赖。我选择了PowerMock针对Mockito的扩展：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>powermock-api-mockito<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>powermock-module-junit4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>让我先给出如下的一份奇奇怪怪的设计，它主要是为了迎合之前提到的代码臭味。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTableUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Employee&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (existed(employee.getId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExistedEmployeeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//insert employee</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (employee == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullEmployeeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (existed(employee.getId())) &#123;</span><br><span class="line">            <span class="comment">//delete employee</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">existed</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EmployeeTableUtil tableUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmployeeTableUtil().count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EmployeeTableUtil.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tableUtil.insert(employee);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExistedEmployeeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EmployeeTableUtil.update(employee);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullEmployeeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tableUtil.delete(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">bonus</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employee.getSalary() * <span class="number">0.1</span>d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTableUtil</span><span class="params">(EmployeeTableUtil tableUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tableUtil = tableUtil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我要针对EmployeeRepository编写测试，它协作的服务类为EmployeTableUtil，主要承担了访问数据库的职责。在测试EmployeeRepository时，我们需要去Mock协作对象EmployeeTableUtil的行为。</p><p>在使用PowerMock编写测试时，首先需要在测试类上运用框架提供的Annotation：@PrepareForTest，以及一个Runner：PowerMockRunner。因为我们要Mock的对象为EmployeeTableUtil，故而测试类的定义为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PrepareForTest</span>(EmployeeTableUtil.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        repository = <span class="keyword">new</span> EmployRepository();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我要使用PowerMock去Mock静态方法，如EmployeeTableUtil的findAll()方法，至于要测试的方法则为EmployeeRepository的findAll()方法。则编写的单元测试为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_mock_static_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employee = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">    employee.add(<span class="keyword">new</span> Employee(<span class="string">"1"</span>));</span><br><span class="line">    employee.add(<span class="keyword">new</span> Employee(<span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line">    PowerMockito.mockStatic(EmployeeTableUtil.class);</span><br><span class="line">    when(EmployeeTableUtil.findAll()).thenReturn(employee);</span><br><span class="line"></span><br><span class="line">    List&lt;Employee&gt; employees = repository.findAll();</span><br><span class="line">    assertThat(employees.size(), is(<span class="number">2</span>));</span><br><span class="line">    assertThat(employees.get(<span class="number">0</span>).getId(), is(<span class="string">"1"</span>));</span><br><span class="line">    assertThat(employees.get(<span class="number">1</span>).getId(), is(<span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line">    PowerMockito.verifyStatic();</span><br><span class="line">    EmployeeTableUtil.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Mock静态方法的关键是先要调用框架定义的PowerMockito类的mockStatic()方法（针对EasyMock有相似的类）。方法接收的参数就是我们要Mock的类的类型。接下来就可以调用Mockito框架的方法，对我们要模拟的方法findAll()进行模拟，这里主要的工作是为模拟方法的返回值设置一个stub。之后就是单元测试的验证逻辑。如果需要验证被Mock的方法是否被调用，则需要调用PowerMockito.verifyStatic()方法，紧随其后的是被mock的方法。</p><p>如果要Mock的方法是一个命令方法（即没有返回值的方法），做法又有不同。倘若熟悉Mockito，可以看出PowerMock完全沿袭了Mockito的风格（当然，针对EasyMock的扩展则会沿袭EasyMock的风格，这是PowerMock体贴人的地方）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_mock_exception_for_command_method_in_mock_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        PowerMockito.mockStatic(EmployeeTableUtil.class);</span><br><span class="line">        PowerMockito.doThrow(<span class="keyword">new</span> NullEmployeeException()).when(EmployeeTableUtil.class);</span><br><span class="line">        EmployeeTableUtil.update(employee);</span><br><span class="line"></span><br><span class="line">        assertThat(repository.update(employee), is(<span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">PowerMock还可以Mock私有方法，当然只能是实例的私有方法。这主要发生在当我们不希望Mock服务的公开方法时（例如，公开方法的逻辑没有Mock的必要），但这些公开方法的内部又调用了自己的私有方法，而私有方法却需要Mock。例如，EmployeeTableUtil的insert()和delete()方法调用了私有的existed()方法。假设insert()和delete()方法不需要我们Mock，此时就需要对私有方法existed()进行Mock。因为是实例方法，所以下面的测试方法通过调用setTableUtil()方法将被模拟的对象注入到EmployeeRepository对象中：</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_mock_private_method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        EmployeeTableUtil util = PowerMockito.spy(<span class="keyword">new</span> EmployeeTableUtil());</span><br><span class="line">        PowerMockito.when(util,<span class="string">"existed"</span>, anyString())</span><br><span class="line">                .thenReturn(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        repository.setTableUtil(util);</span><br><span class="line"></span><br><span class="line">        assertThat(repository.insert(employee), is(<span class="keyword">false</span>));</span><br><span class="line">        assertThat(repository.delete(employee), is(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>PowerMock顺带还提供了测试私有方法的便捷办法（注意是测试，而不是Mock）。例如，测试EmployeeReployee类的私有方法bonus()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_test_private_method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Employee employee = <span class="keyword">new</span> Employee(<span class="string">"1"</span>);</span><br><span class="line">    employee.setSalary(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = Whitebox.&lt;Double&gt;invokeMethod(repository, <span class="string">"bonus"</span>, employee);</span><br><span class="line">    assertThat(result, is(<span class="number">800</span>d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再来看看另外一种诡异的手段。假设我们要测试的方法其内部调用了协作对象的方法，而该协作对象不是在外部注入的，而是在方法中直接实例化。例如在前面例子中，EmployeeRepository的count()方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EmployeeTableUtil tableUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmployeeTableUtil().count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要针对这样一种情形进行Mock，做法有所不同。因为它实际针对的是待测类——即这里的EmployeeRepository——执行count()方法，这就需要在count()方法内部形成一个拦截点。因此，需要在@PrepareForTest标记中指向EmployeeRepository类的类型，而非我们要Mock的EmployeeTableUtil。故而，我们需要为这个测试定义一个新的测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PrepareForTest</span>(EmployeeRepository.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructionEmployeeRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_mock_construction_object</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EmployeeTableUtil util = mock(EmployeeTableUtil.class);</span><br><span class="line">        when(util.count()).thenReturn(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        PowerMockito.whenNew(EmployeeTableUtil.class).withNoArguments().thenReturn(util);</span><br><span class="line"></span><br><span class="line">        EmployeeRepository repository = <span class="keyword">new</span> EmployeeRepository();</span><br><span class="line">        assertThat(repository.count(), is(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，测试方法的前两行代码调用的mock()与when()方法都是Mockito提供的方法，与PowerMock无关。</p><p>我虽然没有看过PowerMock的源代码，但我猜测，当我们在使用PowerMock去Mock静态方法时，定然是结合反射与代理的方式来完成对该方法的调用，其中必然需要初始化该类。由于是静态方法，更多的是需要静态初始化。此外，还有一种情形时，你所要测试的类声明和初始化了一个静态的字段。这些都可能需要调用静态初始化。我们在开发中就碰到一种情形是，我们希望Mock的一个类，定义了一个static块，其中又调用了私有的静态方法。在这个私有静态方法中，依赖了其他的一些对象，这些对象还牵扯到服务容器的问题。即使以静态的方式Mock了该类，仍然逃不过运行static块的命运，换言之，仍然需要依赖服务容器。这时，又可以祭出PowerMock的杀器了。它提供了@SuppressStaticInitializationFor的标注，在该标注中需要传入字符串类型的目标类型的全名。假设EmployeeTableUtil有一个static块是我们需要绕过的，它的类全名为com.agiledon.powermock.EmployeeTableUtil：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PrepareForTest</span>(EmployeeTableUtil.class)</span><br><span class="line"><span class="meta">@SuppressStaticInitializationFor</span>(<span class="string">"com.agiledon.powermock.EmployeeTableUtil"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRepositoryTest</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>此外，对于@PrepareForTest以及@SuppressStaticInitializationFor标记而言，如果需要针对多个类型，则需要传入一个数组，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PrepareForTest</span>(&#123;MockedObjectA.class, MockObjectB.class&#125;)</span><br><span class="line"><span class="meta">@SuppressStaticInitializationFor</span>(&#123;<span class="string">"com.agiledon.powermock.MockedObjectA"</span>, <span class="string">"com.agiledon.powermock.MockedObjectB"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneTest</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>或许我已经变得像祥林嫂一般的唠叨，但我还是必须再次申明，以上Mock方式所针对的情形皆为设计与代码的坏味道。优先情况下，我们应该重构，使得它遵循DIP原则，解除对服务类的耦合，使其具有良好的可测试性；而不能因为有了强大的PowerMock而“姑息养奸”。换言之，让我们仅仅将PowerMock耍弄的种种花招，看做是压箱底的手段。实在走投无路了，再祭出你的杀手锏吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载至：&lt;a href=&quot;http://agiledon.github.io/blog/2013/11/21/play-trick-with-powermock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;逸言&lt;/a&gt;，感谢原作者的精彩分享&lt;/p&gt;
&lt;p&gt;当我们面对一个遗留系统时，常见的问题是没有测试。正如Michael Feathers在Working Effectively with Legacy Code一书中对“遗留代码”的定义。他将其简单归纳为“没有测试的代码”。真是太贴切了！正是因为没有测试，使得我们对遗留代码的任何重构都有些战战兢兢，甚至成为开发人员抵制重构的借口。从收益与成本的比例来看，对于这样的系统，我一贯认为不要盲目进行重构。因为重构的真正适用场景其实是发生在开发期间，而非维护期间。当然，提升自己的重构能力，尤其学会运用IDE提供的自动重构工具，可以在一定程度上保障重构的质量。然而，安全的做法，还是需要为其编写测试。&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="http://allenn.cn/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="单元测试" scheme="http://allenn.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="PowerMock" scheme="http://allenn.cn/tags/PowerMock/"/>
    
  </entry>
  
  <entry>
    <title>Allen&#39;s Blogs 创建历程（1）</title>
    <link href="http://allenn.cn/articles/2016-08/make-mine-blogs-1/"/>
    <id>http://allenn.cn/articles/2016-08/make-mine-blogs-1/</id>
    <published>2016-08-30T08:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.809Z</updated>
    
    <content type="html"><![CDATA[<p>很早很早以前我就开始玩博客，陆陆续续注册了很多平台，比如博客中国、cnblogs、javeeye（现在叫iteye）、csdn，也零零散散写了一些文章，不过没有坚持多久，工作忙起来后就不再更新，自我回顾一下好像还真没有什么干货，只算是给互联网里堆了一串01010101的数据罢了。那为什么最近又动了写 Blogs 的心思，原因是最近读了一本书，书名是：<a href="http://product.china-pub.com/4971248" target="_blank" rel="noopener">《软技能：代码之外的生存指南》</a>，里面<em>第二篇：自我营销</em>中讲到程序员自我营销的重要性，其中一点就提到了写 Blogs。总结来说，程序员写写 Blogs 不仅是自我营销的一种方式，还是一种很好的学习方式，不是说知识能说出来才算学到了么。</p><a id="more"></a><h2 id="Jekyll-amp-GitHub-Pages"><a href="#Jekyll-amp-GitHub-Pages" class="headerlink" title="Jekyll &amp; GitHub Pages"></a>Jekyll &amp; GitHub Pages</h2><p>自我总结一下，之前没有坚持下来很大一个原因就是一个字：“懒”，再加上之前的那些 Blogs 系统多多少少会有点不足。我也曾经尝试过购买 VPS 主机，自己搭建 Blogs，我甚至还为之购买了域名，可是后来发现，为何 VPS 是何等的费时费力。要安装软件，要安装数据库，还要防止被盗链导致流量不够用，哎，都是泪，不说了。到最近，无意中看到一篇译文，似乎是<a href="http://tom.preston-werner.com/2008/11/17/blogging-like-a-hacker.html" target="_blank" rel="noopener">《像黑客一样写博客》</a>，瞬间就被带上车了，开始使用 Jekyll 和 GitHub Pages 架设我的静态博客。</p><p>要在使用 GitHub Pages 服务，首先需要创建一个名字叫 “[你的用户名].github.io” 的项目：</p><p><img src="/assets/images/make-mine-blogs-1/user-repo@2x.png" alt="图片来自：GitHub"></p><p>接着把新建好的项目 Clone 下来，有两种方式 Clone 项目，一种是点击项目右上角的绿色“Set up in desktop”按钮使用 Github 客户端 Clone 项目；另外一种就是通过终端命令行来 Clone 项目。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> [you project addr] [your locale dir]</span><br></pre></td></tr></table></figure><p>Clone 完成后，需要在本地搭建 Jekyll 的写作环境，正式开启静态博客之旅。</p><h3 id="Jekyll-环境准备"><a href="#Jekyll-环境准备" class="headerlink" title="Jekyll 环境准备"></a>Jekyll 环境准备</h3><p>首先安装必要工具</p><ul><li>Ruby：Mac OS X 10.5以上都自带</li><li>RubyGems：Mac OS X 10.5以上都自带</li><li>Xcode Command-Line Tools： 安装Xcode会自动安装，检查Preferences → Downloads → Components是否有Command-Line Tools这项提供下载，如果没有说明已安装</li><li>git：命令行输入git –version检查是否已安装，下载地址：<a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">http://sourceforge.net/projects/git-osx-installer/</a></li></ul><p>在国内 gem 源地址可能已经被墙（万恶的 GFW），所以你可能需要将 gem 源替换为淘宝的镜像源：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 移除官方镜像源</span><br><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">// 添加淘宝镜像源，或者其他镜像地址</span><br><span class="line">$ gem sources -a http://ruby.taobao.org/</span><br><span class="line">// 验证是否替换成功</span><br><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure><p>如果终端中出现下面的显示则代表替换成功。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">http://ruby.taobao.org/</span><br></pre></td></tr></table></figure><p>接着开始安装 Jekyll</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 更新下 gem</span><br><span class="line">sudo gem update --system</span><br></pre></td></tr></table></figure><p>MAC 系统版本如果是 El Capitan 使用下面这个命令。这是因为 Apple 在 OS X El Capitan 中全面启用了名为 System Integrity Protection (SIP) 的系统完整性保护技术。受此影响，大部分系统文件即使在 root 用户下也无法直接进行修改，所以需要把安装路径替换为用户有写入权限的目录。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo gem update -n /usr/<span class="built_in">local</span>/bin --system</span><br></pre></td></tr></table></figure><p>如果你嫌每次都要打安装路径比较麻烦，你也可以把它变成默认配置，在用户根目录下创建一个名为<code>.gemrc</code>的文件，在里面写入<code>gem: -n/usr/local/bin</code>，并保存。或者使用下面的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;gem: -n/usr/local/bin&quot; &gt;&gt; ~/.gemrc</span><br></pre></td></tr></table></figure><p>接下来安装 Jekyll</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo gem install jekyll</span><br><span class="line">// 如果提示权限错误，请使用下面的命令</span><br><span class="line">$ sudo gem install jekyll -n /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>OK，这样 Jekyll 环境就安装完成了，接下来导入 Jekyll 后，就可以开始写作了。在网络上有很多漂亮的 Jekyll 主题可供你选择，你可以访问<a href="http://jekyllthemes.io/" target="_blank" rel="noopener">jekyllthemes.io</a>找到你喜欢的主题并下载下来，或者通过 Google 搜索，如果还不满意，你也可以选择自己创建一个主题。选择好你喜欢的 Jekyll 的主题后，将主题复制到前面从 Github 上 Clone 的项目文件夹中去。一个典型的 Jekyll Blogs 的目录结构应该如下面所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── _drafts</span><br><span class="line">|   ├── begin-with-the-crazy-ideas.textile</span><br><span class="line">|   └── on-simplicity-in-technology.markdown</span><br><span class="line">├── _includes</span><br><span class="line">|   ├── footer.html</span><br><span class="line">|   └── header.html</span><br><span class="line">├── _layouts</span><br><span class="line">|   ├── default.html</span><br><span class="line">|   └── post.html</span><br><span class="line">├── _posts</span><br><span class="line">|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile</span><br><span class="line">|   └── 2009-04-26-barcamp-boston-4-roundup.textile</span><br><span class="line">├── _data</span><br><span class="line">|   └── members.yml</span><br><span class="line">├── _site</span><br><span class="line">├── .jekyll-metadata</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure><p>在该目录下执行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ jekyll server // 简写 jekyll s</span><br></pre></td></tr></table></figure><p>在浏览器地址栏中输入：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以看到刚才新建的 Blog 长什么样子了。在这里新增、修改、删除文章都可以实时的看到，只需要刷新页面即可。你可以试着修改那篇默认文章看看效果。</p><h3 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h3><p>Jekyll 博客的配置全在 Blogs 根目录的<code>_config.yml</code>文件中，一般来说，只要没有什么特殊的需求，只需要修改诸如：博客名、所有者名字、email等信息即可，如果有更多的需求，请参考所用主题的说明和 Jekyll 的文档：<a href="https://jekyllrb.com/docs/configuration/" target="_blank" rel="noopener">https://jekyllrb.com/docs/configuration/</a>。我的 Blog 的基本配置如下，可以参考：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Allen</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Blogging</span> <span class="string">about</span> <span class="string">stuffs</span></span><br><span class="line"><span class="attr">meta_description:</span> <span class="string">"Allen's Blog"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">markdown:</span> <span class="string">krmark</span></span><br><span class="line"><span class="attr">redcarpet:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">highlighter:</span> <span class="string">pygments</span></span><br><span class="line"><span class="attr">logo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">paginate:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">baseurl:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">domain_name:</span> <span class="string">'http://allenn.cn/'</span></span><br><span class="line"><span class="attr">google_analytics:</span> <span class="string">'UA-XXXXXXXX-X'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Details for the RSS feed generator</span></span><br><span class="line"><span class="attr">url:</span>            <span class="string">'/rss.xml'</span></span><br><span class="line"><span class="attr">author:</span>         <span class="string">'Allen'</span></span><br></pre></td></tr></table></figure><p>好了，一切准备就绪，我们可以开始写作了。按照 Jekyll 的规范，文章是放在<code>_posts</code>目录下的，并且需要以时间戳开头，比如：<code>2007-10-29-why-every-programmer-should-play-nethack.md</code>，在文章的开头，需要增加一些描述性的东西，这样 Jekyll 才能正确的处理我们写的文章。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: post</span><br><span class="line">title:  &quot;在多线程构建场景下Powermockito无法在不同类中Mock同一个静态方法&quot;</span><br><span class="line">date:   2015-10-14 13:50:39</span><br><span class="line">comments: true</span><br><span class="line">categories: 软件技术</span><br><span class="line">tags: [Java, 单元测试]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>写好描述后，就可以开始愉快的写正文啦，当你洋洋洒洒的写完你的大作后，你可以使用下面的命令将你的文章提交到 Github 上，完成之后过几分钟应该就能看到新的文章已经在你的个人博客主页上了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">'xxxxx'</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，使用 GitHub Pages + Jekyll 搭建简单的静态博客是非常容易上手的，只要有一点编程基础应该都能搞得定，而且不用像自己搭建 VPS 那样要时不时去维护主机，当然了，Jekyll 也并非完美，下篇文章我将分享我用 Jekyll 时踩到的一些坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早很早以前我就开始玩博客，陆陆续续注册了很多平台，比如博客中国、cnblogs、javeeye（现在叫iteye）、csdn，也零零散散写了一些文章，不过没有坚持多久，工作忙起来后就不再更新，自我回顾一下好像还真没有什么干货，只算是给互联网里堆了一串01010101的数据罢了。那为什么最近又动了写 Blogs 的心思，原因是最近读了一本书，书名是：&lt;a href=&quot;http://product.china-pub.com/4971248&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《软技能：代码之外的生存指南》&lt;/a&gt;，里面&lt;em&gt;第二篇：自我营销&lt;/em&gt;中讲到程序员自我营销的重要性，其中一点就提到了写 Blogs。总结来说，程序员写写 Blogs 不仅是自我营销的一种方式，还是一种很好的学习方式，不是说知识能说出来才算学到了么。&lt;/p&gt;
    
    </summary>
    
      <category term="随便乱写" scheme="http://allenn.cn/categories/%E9%9A%8F%E4%BE%BF%E4%B9%B1%E5%86%99/"/>
    
    
      <category term="Blogs" scheme="http://allenn.cn/tags/Blogs/"/>
    
      <category term="Jekyll" scheme="http://allenn.cn/tags/Jekyll/"/>
    
      <category term="软件工程师的自我宣传" scheme="http://allenn.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E5%AE%A3%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Github的正确使用方法</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-24-how-to-use-github/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-24-how-to-use-github/</id>
    <published>2016-08-24T08:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.805Z</updated>
    
    <content type="html"><![CDATA[<p>在了解了Git的基本用法后（如果你还未了解 Git 的基本使用方法，建议你先话点时间阅读下《 Pro Git 》这本书），相信你已经开始跃跃欲试了，那么我就说下如何正确的使用 Github。下面的图描述了使用 Github 的基本流程：</p><p><img src="/assets/images/github-flow/github-flow.png" alt="Github Flow"></p><a id="more"></a><h3 id="第一步：Fork项目"><a href="#第一步：Fork项目" class="headerlink" title="第一步：Fork项目"></a>第一步：Fork项目</h3><p>Fork 项目其实就是在 Github 上拷贝一份他人项目的副本作为自己的项目。当你进入一个项目页面后，会在右上方看见一个<em>Fork</em>的按钮，点击它就可以 Fork 一个项目。</p><p><img src="/assets/images/github-flow/fork-project.jpg" alt="Fork Project"></p><p>需要注意的是Fork项目后，你自己的项目并不会和源项目保持自动同步，所以你需要手动进行更新，如何更新请看：<em>第五步：拉取源项目的更新</em>。</p><h3 id="第二步：Clone-到本地"><a href="#第二步：Clone-到本地" class="headerlink" title="第二步：Clone 到本地"></a>第二步：Clone 到本地</h3><p>Fork 项目后，我们就可以把代码 Clone 到本地以便我们修改。Github 提供两种 Clone 项目的方式，SSH/HTTPS。如果选用SSH模式，你需要先在本地生成一对SSH Key并上传到Github用于身份识别，具体请参考 Github 的帮助文档：<a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="noopener">Generating an SSH key</a>。如果选用HTTPS模式，在更新和提交时就要输入 Github 的用户名和密码。一般来说使用 SSH 模式，在一次配置后，就可以免输密码提交代码，比较方便，但使用 HTTPS 模式更具备通用性，所以各有利弊，随意选择~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 ssh clone 项目到本地</span><br><span class="line">$ git clone git@github.com:rvm/rvm.git</span><br><span class="line"></span><br><span class="line"># 使用 https clone 项目到本地</span><br><span class="line">$ git clone https://github.com/rvm/rvm.git</span><br></pre></td></tr></table></figure><h3 id="第三步：创建分支"><a href="#第三步：创建分支" class="headerlink" title="第三步：创建分支"></a>第三步：创建分支</h3><p>每次开发新功能，都应该新建一个单独的分支（这方面可以参考<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">《Git分支管理策略》</a>）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取主干最新代码</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line"># 新建一个开发分支myfeature</span><br><span class="line">$ git checkout -b myfeature</span><br></pre></td></tr></table></figure><h3 id="第四步：Commit-新代码"><a href="#第四步：Commit-新代码" class="headerlink" title="第四步：Commit 新代码"></a>第四步：Commit 新代码</h3><p>分支修改后，就可以提交commit了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add --all</span><br><span class="line">$ git status</span><br><span class="line">$ git commit --verbose</span><br></pre></td></tr></table></figure><ul><li>git add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。</li><li>git status 命令，用来查看发生变动的文件。</li><li>git commit 命令的verbose参数，会列出 diff 的结果。</li></ul><p>需要注意的是 Commit 代码必须给出简明扼要的提交信息，下面是一个范本，第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Present-tense summary under 50 characters</span><br><span class="line"></span><br><span class="line">* More information about commit (under 72 characters).</span><br><span class="line">* More information about commit (under 72 characters).</span><br><span class="line"></span><br><span class="line">http://project.management-system.com/ticket/123</span><br></pre></td></tr></table></figure><h3 id="第五步：拉取源项目的更新"><a href="#第五步：拉取源项目的更新" class="headerlink" title="第五步：拉取源项目的更新"></a>第五步：拉取源项目的更新</h3><p>当我们在修改代码的时候，源项目肯定也会发生变化，所以在我们向源项目推送代码之前，需要先将源项目的代码更新拉取下来。</p><p>先查看我们的 Remote 配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)</span><br><span class="line">origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)</span><br></pre></td></tr></table></figure><p>将源项目添加为 upstream</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</span><br></pre></td></tr></table></figure><p>检查配置是否生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)</span><br><span class="line">origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)</span><br><span class="line">upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)</span><br><span class="line">upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)</span><br></pre></td></tr></table></figure><p>拉取源项目的变更</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">remote: Counting objects: 75, done.</span><br><span class="line">remote: Compressing objects: 100% (53/53), done.</span><br><span class="line">remote: Total 62 (delta 27), reused 44 (delta 9)</span><br><span class="line">Unpacking objects: 100% (62/62), done.</span><br><span class="line">From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY</span><br><span class="line"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure><p>切换到 master 分支</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p>将源项目的修改合并到本地 master 分支</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure><h3 id="第六步：Rebase-本地分支并解决冲突"><a href="#第六步：Rebase-本地分支并解决冲突" class="headerlink" title="第六步：Rebase 本地分支并解决冲突"></a>第六步：Rebase 本地分支并解决冲突</h3><p>接着我们切换到之前的开发分支 myfeature，并同 master 分支进行同步</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout myfeature</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure><p>有时我们会和主干发生冲突，那么我们需要在本地把所有冲突解决掉后才能继续合入代码。如何解决冲突，请阅：<a href="https://help.github.com/articles/resolving-a-merge-conflict-from-the-command-line/" target="_blank" rel="noopener">Resolving a merge conflict from the command line</a></p><h3 id="第七步：Push到Github"><a href="#第七步：Push到Github" class="headerlink" title="第七步：Push到Github"></a>第七步：Push到Github</h3><p>同步好本地分支后，我们就可以将代码推送到Github了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin myfeature</span><br></pre></td></tr></table></figure><h3 id="第八步：发送Pull-Request"><a href="#第八步：发送Pull-Request" class="headerlink" title="第八步：发送Pull Request"></a>第八步：发送Pull Request</h3><p>点击项目页面上方的pull request按钮</p><p><img src="/assets/images/github-flow/create-pull-request-1.jpg" alt="pull request button"></p><p>我们自己的项目选择之前的开发分支，源项目选择 master 分支</p><p><img src="/assets/images/github-flow/create-pull-request-2.png" alt="pull request"></p><p>在下面的页面上填写上描述，然后点击发送即可，接着下来就是原作者的事儿了，如果他同意合入我们会在项目的 master 分支看到我们刚刚贡献的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解了Git的基本用法后（如果你还未了解 Git 的基本使用方法，建议你先话点时间阅读下《 Pro Git 》这本书），相信你已经开始跃跃欲试了，那么我就说下如何正确的使用 Github。下面的图描述了使用 Github 的基本流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/github-flow/github-flow.png&quot; alt=&quot;Github Flow&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Git" scheme="http://allenn.cn/tags/Git/"/>
    
      <category term="Github" scheme="http://allenn.cn/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>在公司内网如何更新IntelliJ的插件</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-19-resolve-java-app-ssl-error/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-19-resolve-java-app-ssl-error/</id>
    <published>2016-08-19T14:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.805Z</updated>
    
    <content type="html"><![CDATA[<p>最近小伙伴们更新IntelliJ后，发现没法安装或者更新插件了，每次尝试在线安装时总会提示SSL错误。特别是要玩Scala的小伙伴更是抓狂，因为本身IntelliJ并不自带Scala的支持，需要下载Scala插件。不得以，只能通过手动下载，但是这样就不能享受插件更新的新功能了，很是不爽。那么报SSL错误的原因是什么呢？其实是因为IntelliJ更新插件时使用了Https连接，在连接时，客户端和服务器是要相互校验证书的，一般来说，只要证书正确，客户端是可以和服务器正常交互的。但是，我们是在公司内网，用的是公司的Proxy连接外网。公司的代理服务器会将证书换成公司自己颁(wei)发(zao)的证书（满满的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">中间人攻击</a>的即视感，公司这样做是要干嘛？你懂的。。。），这时IntelliJ就无法同插件服务器正常通信了，那么怎么解决这个问题呢？那就是导入公司代理服务器的根证书，把公司颁(wei)发(zao)的证书变成可信任的证书。</p><a id="more"></a><p>OK, Let’s do it! 首先导出公司代理服务器的根证书，用浏览器即可，随便访问应该https的外网网站，点击地址栏上的小锁头。</p><p><img src="/assets/images/java-ssl-error/ie_url_bar-certificate-error.png" alt="ie_url_bar"></p><p>打开的窗口中,点击下一步即可,</p><p><img src="/assets/images/java-ssl-error/export_cert_1.png" alt="证书详细信息"></p><p>在正式编码格式中,选择指定的格式,点击下一步;</p><p><img src="/assets/images/java-ssl-error/export_cert_2.png" alt="证书导出向导"></p><p>指定生成证书文件的名称(此处为vbooking.cer)</p><p><img src="/assets/images/java-ssl-error/export_cert_3.png" alt="vbooking.cer"></p><p>接着，将证书导入java的cacerts证书库，切换到目录 ${JAVA_HOME}/jre/lib/security, 执行如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -import -alias vbooking -keystore cacerts -file $&#123;cert_file_path&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>-alias 指定别名(推荐和证书同名)</li><li>-keystore 指定存储文件(此处固定)</li><li>-file 指定证书文件全路径(证书文件所在的目录)</li></ul><p>此时命令行会提示你输入cacerts证书库的密码,敲入changeit即可,这是java中cacerts证书库的默认密码,当然也可自行修改。</p><p>最后，在系统中新建一个环境变量，IDEA_JDK（64位程序为IDEA_JDK_64），指向刚才导入根证书的JDK，不然IntelliJ会使用内置的JDK（详细见<a href="https://intellij-support.jetbrains.com/hc/en-us/articles/206544879-Selecting-the-JDK-version-the-IDE-will-run-under" target="_blank" rel="noopener">这里</a>），重启IntelliJ后即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近小伙伴们更新IntelliJ后，发现没法安装或者更新插件了，每次尝试在线安装时总会提示SSL错误。特别是要玩Scala的小伙伴更是抓狂，因为本身IntelliJ并不自带Scala的支持，需要下载Scala插件。不得以，只能通过手动下载，但是这样就不能享受插件更新的新功能了，很是不爽。那么报SSL错误的原因是什么呢？其实是因为IntelliJ更新插件时使用了Https连接，在连接时，客户端和服务器是要相互校验证书的，一般来说，只要证书正确，客户端是可以和服务器正常交互的。但是，我们是在公司内网，用的是公司的Proxy连接外网。公司的代理服务器会将证书换成公司自己颁(wei)发(zao)的证书（满满的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中间人攻击&lt;/a&gt;的即视感，公司这样做是要干嘛？你懂的。。。），这时IntelliJ就无法同插件服务器正常通信了，那么怎么解决这个问题呢？那就是导入公司代理服务器的根证书，把公司颁(wei)发(zao)的证书变成可信任的证书。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="IntelliJ" scheme="http://allenn.cn/tags/IntelliJ/"/>
    
      <category term="ssl" scheme="http://allenn.cn/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>Java核心API需要掌握的程度</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-14-java-api-need-to-know/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-14-java-api-need-to-know/</id>
    <published>2016-08-14T15:21:39.000Z</published>
    <updated>2018-05-11T15:05:19.805Z</updated>
    
    <content type="html"><![CDATA[<p>最近总结，发现自己没啥提升，准备开始练级，记下这个，给自己一个目标。Java的核心API是非常庞大的,这给开发者来说带来了很大的方便，经常人有评论,java让程序员变傻。但是一些内容我认为是必须掌握的，否则不可以熟练运用java，也不会使用就很难办了。</p><ol><li>java.lang包下的80％以上的类的功能的灵活运用。</li><li>java.util包下的80％以上的类的灵活运用，特别是集合类体系、正规表达式、时间、属性、和Timer.</li><li>java.io包下的60％以上的类的使用，理解IO体系的基于管道模型的设计思路以及常用IO类的特性和使用场合。</li><li>java.math包下的100％的内容。</li><li>java.net包下的60％以上的内容，对各个类的功能比较熟悉。</li><li>java.text包下的60％以上的内容，特别是各种格式化类。</li><li>熟练运用JDBC.</li><li>java.security包下40％以上的内容，如果对于安全没有接触的话根本就不可能掌握java.</li><li>AWT的基本内容，包括各种组件事件、监听器、布局管理器、常用组件、打印。</li><li>Swing的基本内容，和AWT的要求类似。</li><li>XML处理，熟悉SAX、DOM以及JDOM的优缺点并且能够使用其中的一种完成XML的解析及内容处理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近总结，发现自己没啥提升，准备开始练级，记下这个，给自己一个目标。Java的核心API是非常庞大的,这给开发者来说带来了很大的方便，经常人有评论,java让程序员变傻。但是一些内容我认为是必须掌握的，否则不可以熟练运用java，也不会使用就很难办了。&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="api" scheme="http://allenn.cn/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>25分钟改变你的工作效率：番茄工作法</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-12-intro-pomodoro-technique/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-12-intro-pomodoro-technique/</id>
    <published>2016-08-12T08:50:39.000Z</published>
    <updated>2018-05-11T15:05:19.805Z</updated>
    
    <content type="html"><![CDATA[<p>少年，你是不是每5分钟就会拿起一次手机？你是不是每天忙忙碌碌但最后好像什么也没干？你是不是日复一日的加班感觉身体被掏空？</p><p><img src="/assets/images/intro-pomodoro-technique/time-lack.png" alt="我真的很缺时间"></p><p>那么，你想变得更专注么？你想变得更有效率么？你想每天下班按时回家么？那么来试试这个番茄工作法吧！</p><a id="more"></a><p>番茄工作法？也许很多人对它还比较陌生，包括我，我也是在阅读了《软技能－代码之外的生存指南》（这是一本好书，推荐所有人阅读）后才了解到它。那么什么是番茄工作法呢？</p><blockquote><p>番茄工作法（英语：Pomodoro Technique）是一种时间管理法方法，在上世纪八十年代由Francesco Cirillo创立。该方法使用一个定时器来分割出一个一般为25分钟的工作时间和5分钟的休息时间，而那些时间段被称为pomodori，为意大利语单词 pomodoro（中文：番茄）之复数。以上来自<a href="https://zh.wikipedia.org/wiki/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95" target="_blank" rel="noopener">维基百科：番茄工作法</a></p></blockquote><p>简单来说就是把工作时间划分为一小节一小节的，每小节30分钟，其中包含了25分钟的工作时间和5分钟的休息时间。是不是很简单？</p><p>OK，那让我们来实践一下，请选择一件你觉得在25分钟内能完成的工作，在这25分钟的工作时间中，请把Email关掉，手机调整成静音，打好茶水。然后把手机的定时器打开，设置25分钟的倒计时，然后开始工作。</p><p><img src="/assets/images/intro-pomodoro-technique/25mins-get-it-done.png" alt="打开你的定时器"></p><p>OK,Time up，现在感觉怎么样？是不是找回了专注的感觉？<em>一次只专注做好一件事情</em>，这就是番茄工作法的精髓所在。我们都知道工作情境的切换特别耗费人的精力，你也许会有过这样的体验，当你在酝酿某种思路时，突然一个电话，你之前在大脑里构建的宏伟建筑顷刻就能灰飞烟灭。你只有一双脚，不能同时跳两场舞。</p><p><img src="/assets/images/intro-pomodoro-technique/two-dance.gif" alt="打开你的定时器"></p><h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><p>「番茄工作法」的使用主流程如下：</p><ol><li>每天早上到公司后，首先拿一张纸（或者是本子中的一页），用笔写下当天应该要做完的事情。</li><li>将这些事情按优先级排序，然后进行大致的估算后，拆分成若干个「番茄钟」，每个「番茄钟」是 25 分钟。</li><li>设置「番茄钟」倒计时，同时开始第一件事情的第一个「番茄钟」。</li><li>在「番茄钟」倒计时期间，集中精力只做事先安排好的事情。</li><li>在「番茄钟」结束后，休息 5 分钟，走动放松一下，然后继续下一个「番茄钟」，直到完成自己的任务。</li><li>每完成 4 个「番茄钟」（即 2 小时），休息 15-30 分钟。</li><li>每天回顾「番茄钟」完成的情况，回顾一下自己被打断的原因，看看哪些打断可以避免。</li></ol><p>在实际工作中你总会遇到一些疑问情况，因为你不是与世隔绝的，你是在一个团队中工作。番茄工作法也没有要求你做到与世隔绝，完全“两耳不闻窗外事”。那么如何处理这种“突发状况”呢：</p><ol><li>如果你被电话、交谈打断，这个「番茄钟」即宣告失败，可以简单休息 5 分钟，然后重启「番茄钟」。</li><li>如果你突然想到一件重要的事情，除非当前非做不可，否则应该在纸上将此事快速记录下来，然后继续你的「番茄钟」。</li></ol><p>下面用一张图来说明整个番茄工作法的流程，这张图来自<a href="https://www.amazon.cn/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E5%9B%BE%E8%A7%A3-%E7%AE%80%E5%8D%95%E6%98%93%E8%A1%8C%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95-%E8%AF%BA%E7%89%B9%E4%BC%AF%E6%A0%BC/dp/B004O9F71K" target="_blank" rel="noopener">《番茄工作法图解-简单易行的时间管理方法》</a>：</p><p><img src="/assets/images/intro-pomodoro-technique/overview.png" alt="工作流程"></p><h2 id="技巧和心得"><a href="#技巧和心得" class="headerlink" title="技巧和心得"></a>技巧和心得</h2><p>OK，上面说了那么多，相信你对番茄工作法已经有一定的了解了，那为什么我要推荐给你，因为我用了以后觉得好，就像成龙大哥说的那样：我用完之后是这样子，你们用完之后，也是这样子！</p><p><img src="/assets/images/intro-pomodoro-technique/duang.png" alt="duang"></p><ol><li>在进行「番茄钟」时，我们应该尽量想办法避开一些容易分神的信息源。例如：将手机的消息推送静音，关闭 QQ 和微信。相信我，你大多数时候并不需要立即响应聊天软件中的信息。使用「番茄钟」后，你的消息回复时间最坏情况下也就是晚 25 分钟。如果真的有人有急事，他会直接到你的办公桌来找你，或者直接给你打电话的。</li><li>刚开始的时候我建议你把「番茄钟」设定在25分钟，随着你的注意力控制越来越容易，你可以适当延长「番茄钟」的时间。就我的经验，延长到 45 - 50 分钟是完全没有问题的。其实你如果明白了「番茄钟」的原理，你甚至可以在心中假想一个「番茄钟」，然后让自己快速进入精力集中状态。</li><li>一天下来，回顾自己当天的「番茄钟」完成情况，看看主要的问题在于自己的精力无法集中，还是老是被别人打断。针对具体的问题可以做一些调整的尝试。比如，如果是精力无法集中，则看看是否是干扰源过多，尽量减少干扰。如果是老被打断，则可以和同事商量一些工作方式，比如让同事尽量用邮件和 QQ 找你，而不是当面打扰你。</li><li>我使用了一个内置番茄计时器的看板程序来追踪我每天的工作情况，<a href="https://kanbanflow.com" target="_blank" rel="noopener">Kanbanflow</a>，我每天会在开完早会后花一个番茄钟的时间来安排我一天的任务，并用它来作为我的「番茄钟」计时器。它还能输出一个报告，告诉你每天完成了多少个「番茄钟」，被打断了多少次，被打断的原因又是什么。我觉得不错，你可以去试试。</li></ol><p><img src="/assets/images/intro-pomodoro-technique/KanbanFlowBoard.png" alt="KanbanFlowBoard"></p><p>最后我想说的是，我们应该认识到，工作被打断是在所难免的，总会有一些临时的沟通工作无法被计划，并且是有价值的。所以，「番茄钟」失败后，不应该有过多的情绪，尽快重启一个「番茄钟」，你的工作应该很快就会进入状态。Try it，相信你也会有很大的收获。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;少年，你是不是每5分钟就会拿起一次手机？你是不是每天忙忙碌碌但最后好像什么也没干？你是不是日复一日的加班感觉身体被掏空？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/intro-pomodoro-technique/time-lack.png&quot; alt=&quot;我真的很缺时间&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么，你想变得更专注么？你想变得更有效率么？你想每天下班按时回家么？那么来试试这个番茄工作法吧！&lt;/p&gt;
    
    </summary>
    
      <category term="工作方法" scheme="http://allenn.cn/categories/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>CompletionService小技巧</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-10-java-CompletionService-tips/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-10-java-CompletionService-tips/</id>
    <published>2016-08-10T08:50:39.000Z</published>
    <updated>2018-05-11T15:05:19.805Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇blogs中，我详细的解释了<code>CompletionService</code>的使用方法和<code>ExecutorCompletionService</code>的详细实现，这篇blogs中，我就介绍使用它的一个小技巧，算是对上一篇blogs的一个补完。在开始之前我们先回顾一下它的实现。</p><a id="more"></a><p>首先，在初始化<code>ExecutorCompletionService</code>的时候我们需要传入一个<code>Executor</code>，作为<code>ExecutorCompletionService</code>执行任务的容器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">    [......]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span> </span>&#123;</span><br><span class="line">    [......]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，调用<code>submit</code>方法，向它提交任务。<code>submit</code>方法会将我们提交的任务包装成一个<code>QueueingFuture</code>并提交给<code>Executor</code>来执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    RunnableFuture&lt;V&gt; f = newTaskFor(task);  </span><br><span class="line">    executor.execute(<span class="keyword">new</span> QueueingFuture(f));  </span><br><span class="line">    <span class="keyword">return</span> f;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，<code>QueueingFuture</code>会在任务执行完成后把执行结果放到队列中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">        <span class="keyword">super</span>(task, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们通过<code>take</code>或者<code>poll</code>方法就能拿到任务执行的结果。</p><p>下面让我们设想一个场景，我需要从网络上下载几张图片和视频并最后把它们渲染到页面上去，由于下载图片和视频都比较耗时，所以我希望能以多线程的形式进行下载。但是由于资源有限，下载的并发度不能太大，所以需要限制线程池的并发线程大小。但如果将可用线程数平均分给下载图片和下载视频的线程池，当某线程池的所有任务执行完成后，另外一个线程池也无法获取到它所释放的资源。那怎么办呢？我们可以创建一个统一的线程池，然后把两个CompletionService绑定上去，让CompletionService作为一个句柄来使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ExecutorCompletionService&lt;Image&gt; imageCompletionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(pool);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> String site : imageSites) &#123;</span><br><span class="line">    completionService.submit(<span class="keyword">new</span> Callable&lt;Image&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> IOUtils.toString(<span class="keyword">new</span> URL(<span class="string">"http://"</span> + site), StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ExecutorCompletionService&lt;Video&gt; vidoeCompletionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(pool);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> String site : videoSites) &#123;</span><br><span class="line">    completionService.submit(<span class="keyword">new</span> Callable&lt;Video&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> IOUtils.toString(<span class="keyword">new</span> URL(<span class="string">"http://"</span> + site), StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Image&gt; images = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; topSites.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">final</span> Future&lt;String&gt; future = completionService.take();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        images.add(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        log.warn(<span class="string">"Error while downloading"</span>, e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Video&gt; videos = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; topSites.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">final</span> Future&lt;String&gt; future = completionService.take();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        videos.add(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        log.warn(<span class="string">"Error while downloading"</span>, e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... do process content</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇blogs中，我详细的解释了&lt;code&gt;CompletionService&lt;/code&gt;的使用方法和&lt;code&gt;ExecutorCompletionService&lt;/code&gt;的详细实现，这篇blogs中，我就介绍使用它的一个小技巧，算是对上一篇blogs的一个补完。在开始之前我们先回顾一下它的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://allenn.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
