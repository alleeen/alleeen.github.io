<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Allen&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://allenn.cn/"/>
  <updated>2017-04-06T16:00:05.643Z</updated>
  <id>http://allenn.cn/</id>
  
  <author>
    <name>Allen Zheng</name>
    <email>xudongzheng1225@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fetch Size 与 JDBC 内存管理</title>
    <link href="http://allenn.cn/articles/2016-12/2016-12-13-fetchsize-jdbc-memory/"/>
    <id>http://allenn.cn/articles/2016-12/2016-12-13-fetchsize-jdbc-memory/</id>
    <published>2016-12-13T08:21:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>接触到 JDBC 的 Fetch Size 这个属性缘起一个性能问题，项目中需要将一个有千万级数据量的表中的记录导出到文件中去。按照正常的路数，先初始化连接；接着写好 SQL 语句，比如<code>SELECT * FROM DIM_USERS</code>；然后启动查询，拿到 ResultSet，最后遍历 ResultSet 将每行记录输出到文件中去。可在接下来的测试中，发现性能并不理想，在表中数据量小的时候，执行速度尚可接受，可是在进行大数据量压力测试的时候，发现代码往往要执行40分钟以上，这在实际生产环境上是万万不可接受的。</p>
<a id="more"></a>
<p>通过定位，发现性能瓶颈出现在从数据库中读取数据的时候，大概消耗了90%以上的时间。也就是说如果什么事情都不干，单纯对一个千万级数据量的 ResultSet 进行一次遍历就需要耗时35分钟以上。这样一来，问题就变得让人有点费解了，因为在同一套环境上，服务器向数据库写入数据的速率可以达到3万+/秒，为何查询变得如此低效？正在我百思不得其解的时候，一个大神走过来拍怕我的肩膀说：“小伙子，试试把 Fetch Size 调整一下。”</p>
<h2 id="Fetch-Size"><a href="#Fetch-Size" class="headerlink" title="Fetch Size"></a>Fetch Size</h2><p>在 JDBC 中 Fetch Size 是 Statement 上的一个属性，先看下<a href="https://docs.oracle.com/cd/E11882_01/java.112/e16548/resltset.htm#JJDBC28621" target="_blank" rel="external">Oracle 的帮助文档</a>对它是怎么定义的：</p>
<blockquote>
<p>By default, when Oracle JDBC executes a query, it receives the result set 10 rows at a time from the database cursor. This is the default Oracle row-prefetch value. You can change the number of rows retrieved with each trip to the database cursor by changing the row-prefetch value</p>
</blockquote>
<p>简单的说，这个属性控制了 JDBC 每次读取数据的行数，由于 JDBC 每次都要通过网络去读取数据，如果这个值配置得太小，那么就意味着在遍历 ResultSet 的时候 JDBC 需要频繁的通过网络读取数据，这就导致了读取数据时性能低下。那接下来的问题就简单了，就是将这个属性调大。可是调整到多少合适呢？1K、2K？还是1W、2W？要知道 JDBC 每次读取的数据是会缓存在内存中的，如果这个属性设置大了，就会使程序出现 OOM。</p>
<h2 id="JDBC-Memory"><a href="#JDBC-Memory" class="headerlink" title="JDBC Memory"></a>JDBC Memory</h2><p>接下来就得聊聊 JDBC 的内存管理了（这里特指 Oracle JDBC，别的厂商也许实现机制不是这样的）。JDBC 解析 SQL 语句后，为每个 Statement（包括 PreparedStatement 和 CallableStatement）分配了两个 Buffer 来缓存数据，<code>byte[]</code>和<code>char[]</code>。字符类型的数据（CHAR,<br>VARCHAR2, NCHAR, etc. ）缓存在<code>char[]</code>中，其他类型的数据缓存在<code>byte[]</code>中。在 SQL 语句解析后，语句所查询的列的数据类型就已经确定了，JDBC 会根据这些信息和 Fetch Size 一起计算出缓存的大小，并分配内存。所以如果不需要查询某张表的所以列时，使用<code>SELECT * FROM XXX</code>是一种浪费内存的行为，特别是表的列数多且数据量大的时候，很容易造成 OOM。</p>
<h3 id="数据类型与内存占用"><a href="#数据类型与内存占用" class="headerlink" title="数据类型与内存占用"></a>数据类型与内存占用</h3><p>前面说了，JDBC 会根据查询语句中列的数据类型来计算缓存的大小那么每种数据类型大致占多少空间呢？请看下表。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:center">大小（byte）</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>VARCHAR2</td>
<td style="text-align:center">2</td>
<td>每个字符占用2byte</td>
</tr>
<tr>
<td>BFILE</td>
<td style="text-align:center">4K</td>
<td></td>
</tr>
<tr>
<td>BLOB</td>
<td style="text-align:center">4K</td>
<td></td>
</tr>
<tr>
<td>CLOB</td>
<td style="text-align:center">4K</td>
<td></td>
</tr>
<tr>
<td>Other</td>
<td style="text-align:center">22</td>
<td>其他类型占用空间比较小，可以大致估算为22byte</td>
</tr>
</tbody>
</table>
<p>让我们来举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE TAB (ID NUMBER(10), NAME VARCHAR2(40), DOB DATE)</div><div class="line">ResultSet r = stmt.executeQuery(“SELECT * FROM TAB”);</div></pre></td></tr></table></figure>
<p>当 JDBC 解析查询语句时，数据库会告知 JDBC 结果会包含三列，NUMBER(10)、VARCHAR2(40) 和 DATE，第一列大概需要22 bytes，第二列包含了40个字符，所以需要<code>2 * 40</code>bytes，第三列也是大概需要22 bytes。因此，本次查询每条记录大致需要<code>22 + (40 * 2) + 22 = 124</code>bytes，如果 Fetch Size设置为10，那么缓存就需要分配1240 bytes 的空间。</p>
<h2 id="如何正确设置Fetch-Size"><a href="#如何正确设置Fetch-Size" class="headerlink" title="如何正确设置Fetch Size"></a>如何正确设置Fetch Size</h2><p>上面说了那么多无非就是想说明一个问题，就是 Fetch Size 的大小是要根据实际情况来设置，设置小了性能不好，设置大了内存会有问题。总之一个原则就是，在保证内存够用的情况下，尽量把 Fetch Size 设置得大一点。如果你拿不准设置多少，可以先试下下面的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">4 * 1024 * 1024 / sum(所读取的列的数据长度)</div></pre></td></tr></table></figure>
<h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ul>
<li><a href="http://www.oracle.com/technetwork/database/enterprise-edition/memory.pdf" target="_blank" rel="external">Oracle JDBC Memory Management</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触到 JDBC 的 Fetch Size 这个属性缘起一个性能问题，项目中需要将一个有千万级数据量的表中的记录导出到文件中去。按照正常的路数，先初始化连接；接着写好 SQL 语句，比如&lt;code&gt;SELECT * FROM DIM_USERS&lt;/code&gt;；然后启动查询，拿到 ResultSet，最后遍历 ResultSet 将每行记录输出到文件中去。可在接下来的测试中，发现性能并不理想，在表中数据量小的时候，执行速度尚可接受，可是在进行大数据量压力测试的时候，发现代码往往要执行40分钟以上，这在实际生产环境上是万万不可接受的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://allenn.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="JDBC" scheme="http://allenn.cn/tags/JDBC/"/>
    
      <category term="数据库" scheme="http://allenn.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="内存管理" scheme="http://allenn.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spark 的惰性运算</title>
    <link href="http://allenn.cn/articles/2016-10/2016-10-26-spark-is-lazy/"/>
    <id>http://allenn.cn/articles/2016-10/2016-10-26-spark-is-lazy/</id>
    <published>2016-10-26T08:21:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>今天在检视项目代码的时候，无意中发现了下面一段代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RddTransformer</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doTransform</span></span>(data: <span class="type">RDD</span>[<span class="type">Data</span>]): <span class="type">RDD</span>[<span class="type">NewData</span>]=&#123;</div><div class="line">    <span class="keyword">val</span> newDataRdd = data.flatmap(<span class="type">DataTransformer</span>.doTransform)</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="type">DataTransformer</span>.exceptionCount &gt; <span class="number">0</span>) &#123;</div><div class="line">      logger.error(<span class="string">s"There are some illegal data, count: <span class="subst">$&#123;DataTransformer.exceptionCount&#125;</span>"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    newDataRdd</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataTransformer</span></span>&#123;</div><div class="line">  <span class="keyword">var</span> exceptionCount:<span class="type">Int</span> = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doTransform</span></span>(data: <span class="type">Data</span>): <span class="type">Option</span>[<span class="type">NewData</span>]=&#123;</div><div class="line">    <span class="keyword">if</span>(data.isIllegal)&#123;</div><div class="line">      exceptionCount += <span class="number">1</span></div><div class="line">      <span class="type">None</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">// do something transform data to new data</span></div><div class="line">      .....</div><div class="line"></div><div class="line">      <span class="type">Some</span>(newData)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>作者的意图很简单，就是将RDD中的数据转换为新的数据格式，并统计非法数据的个数。咋一看代码，似乎没有什么问题，可是，这段代码真的能得到正确的结果么？答案是否定的，事实上，不管RDD中包含多少非法数据，<code>if(DataTransformer.exceptionCount &gt; 0)</code>这个条件永远都不会为真。为什么？你现在肯定充满了疑惑，让我们先来看看 Spark 的文档上对 RDD 操作的解释：</p>
<blockquote>
<p>All transformations in Spark are lazy, in that they do not compute their results right away. Instead, they just remember the transformations applied to some base dataset (e.g. a file). The transformations are only computed when an action requires a result to be returned to the driver program. (<a href="http://spark.apache.org/docs/latest/programming-guide.html#rdd-operations" target="_blank" rel="external">RDD Operations</a>)</p>
<p>在 Spark 中，所有的 transformation() 类型操作都是延迟计算的，Spark 只是记录了将要对数据集进行的操作。只有需要数据集将数据返回到 Driver 程序时（即触发 Action 类型操作），所有已记录的 transformation() 才会执行。</p>
</blockquote>
<p>回到上面的代码，由于针对<code>RDD[Data]</code>的<code>flatmap</code>操作属于 transformation() 类型操作，所以<code>val newDataRdd = data.flatmap(DataTransformer.doTransform)</code>这段代码只是记录了一下对 RDD 的操作，并没有真正的去执行<code>DataTransformer.doTransform</code>方法中的代码。我们可以尝试在 Spark Shell 中实验一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">scala&gt; var counter = 0</div><div class="line">counter: Int = 0</div><div class="line"></div><div class="line">scala&gt; var rdd = sc.parallelize(Seq(1,2,3,4,5,6)).map(x =&gt; counter += x)</div><div class="line">rdd: spark.RDD[Int] = spark.MappedRDD@2ee9b6e3</div><div class="line"></div><div class="line">scala&gt; counter</div><div class="line">counter: Int = 0</div></pre></td></tr></table></figure>
<p>显然累加操作并没有被执行，根据 Shell 终端的输出，Spark 似乎只是记录了一下我们的操作，并返回了一个新的 RDD。当对 RDD 进行 transformation() 操作的时候，在 Spark 内部究竟发生了什么？在解释这个问题之前，先来看看 Spark 作业的执行逻辑。</p>
<h2 id="Spark-Job-执行逻辑"><a href="#Spark-Job-执行逻辑" class="headerlink" title="Spark Job 执行逻辑"></a>Spark Job 执行逻辑</h2><p><img src="/assets/images/2016-10-26-spark-is-lazy/GeneralLogicalPlan.png" alt="GeneralLogicalPlan"></p>
<p>典型的 Spark Job 逻辑执行图如下所示，Spark Job 经过下面四个步骤可以得到最终执行结果：</p>
<ul>
<li>从数据源（可以是本地 file，内存数据结构， HDFS，HBase 等）读取数据创建最初的 RDD。上一段代码中的 parallelize() 相当于 createRDD()。</li>
<li>对 RDD 进行一系列的 transformation() 操作，每一个 transformation() 会产生一个或多个包含不同类型 T 的 RDD[T]。T 可以是 Scala 里面的基本类型或数据结构，不限于 (K, V)。但如果是 (K, V)，K 不能是 Array 等复杂类型（因为难以在复杂类型上定义 partition 函数）。</li>
<li>对最后的 final RDD 进行 action() 操作，每个 partition 计算后产生结果 result。</li>
<li>将 result 回送到 driver 端，进行最后的 f(list[result]) 计算。例子中的 count() 实际包含了action() 和 sum() 两步计算。</li>
</ul>
<p>Spark 在每次 transformation() 的时候使用了新产生的 RDD 来记录计算逻辑，这样就把作用在 RDD 上的所有计算逻辑串起来形成了一个链条，逻辑执行图上表示的实际上就是是 Spark Job 的计算链。当然某些 transformation() 比较复杂，会包含多个子 transformation()，因而会生成多个 RDD。这就是实际 RDD 个数会比我们想象的多一些的原因。当对 RDD 进行 action() 时，Spark 会调用在计算链条末端最后一个 RDD 的<code>compute()</code>方法，这个方法会接收它上一个 RDD 或者数据源的 input records，并执行自身定义的计算逻辑，从而输出结果。一句话总结 Spark 执行 action() 的流程就是：从计算链的最后一个 RDD 开始，依次从上一个 RDD 获取数据并执行计算逻辑，最后输出结果。</p>
<h2 id="数据计算过程"><a href="#数据计算过程" class="headerlink" title="数据计算过程"></a>数据计算过程</h2><p>下面的代码段，展现了<code>RDD.flatmap()</code>和<code>MapPartitionsRDD</code>的实现，在代码中，我们看到，当调用<code>RDD</code>的<code>map</code>并传入一个函数<code>f</code>的时候，Spark 并没有做什么运算，而是用<code>f</code>作为一个入参创建了一个叫<code>MapPartitionsRDD</code>的对象并返回给调用者。而在<code>MapPartitionsRDD.scala</code>中，我们也看到只有当<code>compute</code>方法被调用的时候，我们之前传入的函数<code>f</code>才会真正的被执行</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"></div><div class="line">  <span class="comment">// RDD.scala</span></div><div class="line">  ...</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Return a new RDD by applying a function to all elements of this RDD.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatmap</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</div><div class="line">    <span class="keyword">val</span> cleanF = sc.clean(f)</div><div class="line">    <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.map(cleanF))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// MapPartitionsRDD.scala</span></div><div class="line">  <span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">MapPartitionsRDD</span>[<span class="type">U</span>: <span class="type">ClassTag</span>, <span class="type">T</span>: <span class="type">ClassTag</span>](<span class="params"></span></span></div><div class="line">    var prev: <span class="type">RDD</span>[<span class="type">T</span>],</div><div class="line">    f: (<span class="type">TaskContext</span>, <span class="type">Int</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) <span class="title">=&gt;</span> <span class="title">Iterator</span>[<span class="type">U</span>],  <span class="title">//</span> (<span class="params"><span class="type">TaskContext</span>, partition index, iterator</span>)</div><div class="line">    preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>)</div><div class="line">  <span class="keyword">extends</span> <span class="type">RDD</span>[<span class="type">U</span>](prev) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">val</span> partitioner = <span class="keyword">if</span> (preservesPartitioning) firstParent[<span class="type">T</span>].partitioner <span class="keyword">else</span> <span class="type">None</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartitions</span></span>: <span class="type">Array</span>[<span class="type">Partition</span>] = firstParent[<span class="type">T</span>].partitions</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">U</span>] =</div><div class="line">    f(context, split.index, firstParent[<span class="type">T</span>].iterator(split, context))</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">clearDependencies</span></span>() &#123;</div><div class="line">    <span class="keyword">super</span>.clearDependencies()</div><div class="line">    prev = <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际计算过程大概是这样的：</p>
<ol>
<li>根据动作操作来将一个应用程序划分成多个作业。</li>
<li>一个作业经历 DAG 调度和任务调度之后，被划分成一个一个的任务，对应 Task 类。</li>
<li>任务被分配到不同核心去执行，执行 Task.run。</li>
<li>Task.run 会调用阶段末 RDD 的 iterator 方法，获取该 RDD 某个分区内的数据记录，而 iterator 方法有可能会调用 RDD 类的 compute 方法来负责父 RDD 与子 RDD 之间的计算逻辑。</li>
</ol>
<p>整个过程会比较复杂，在此不进行展开，我们只需要知道 Apache Spark 最终会调用 RDD 的 iterator 和 compute 方法来计算分区数据即可。</p>
<h3 id="compute-方法"><a href="#compute-方法" class="headerlink" title="compute 方法"></a>compute 方法</h3><p>在 RDD 中，<code>compute()</code>被定义为抽象方法，要求其所有子类都必须实现，该方法接受的参数之一是一个<code>Partition</code>对象，目的是计算该分区中的数据。以之前<code>flatmap</code>操作生成得到的<code>MapPartitionsRDD</code>类为例。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">U</span>] =</div><div class="line">  f(context, split.index, firstParent[<span class="type">T</span>].iterator(split, context))</div></pre></td></tr></table></figure>
<p>其中，<code>firstParent</code>在 RDD 中定义。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** Returns the first parent RDD */</span></div><div class="line"><span class="keyword">protected</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">firstParent</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>] = &#123;</div><div class="line">  dependencies.head.rdd.asInstanceOf[<span class="type">RDD</span>[<span class="type">U</span>]]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MapPartitionsRDD</code>类的<code>compute</code>方法调用当前 RDD 内的第一个父 RDD 的<code>iterator</code>方法，该方的目的是拉取父 RDD 对应分区内的数据，它返回一个迭代器对象，迭代器内部存储的每个元素即父 RDD 对应分区内已经计算完毕的数据记录。得到的迭代器作为<code>f</code>方法的一个参数。<code>compute</code>方法会将迭代器中的记录一一输入<code>f</code>方法，得到的新迭代器即为所求分区中的数据。</p>
<h3 id="iterator方法"><a href="#iterator方法" class="headerlink" title="iterator方法"></a>iterator方法</h3><p><code>iterator</code>方法的实现在 RDD 类中。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Internal method to this RDD; will read from cache if applicable, or otherwise compute it.</div><div class="line"> * This should ''not'' be called by users directly, but is available for implementors of custom</div><div class="line"> * subclasses of RDD.</div><div class="line"> */</div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">if</span> (storageLevel != <span class="type">StorageLevel</span>.<span class="type">NONE</span>) &#123;</div><div class="line">    <span class="type">SparkEnv</span>.get.cacheManager.getOrCompute(<span class="keyword">this</span>, split, context, storageLevel)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    computeOrReadCheckpoint(split, context)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>iterator</code>方法首先检查当前 RDD 的存储级别，如果存储级别不为<code>None</code>，说明分区的数据要么已经存储在文件系统当中，要么当前 RDD 曾经执行过<code>cache</code>、<code>persise</code>等持久化操作，因此需要想办法把数据从存储介质中提取出来。<code>iterator</code>方法继续调用<code>CacheManager</code>的<code>getOrCompute</code>方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** Gets or computes an RDD partition. Used by RDD.iterator() when an RDD is cached. */</span></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getOrCompute</span></span>[<span class="type">T</span>](</div><div class="line">     rdd: <span class="type">RDD</span>[<span class="type">T</span>],</div><div class="line">     partition: <span class="type">Partition</span>,</div><div class="line">     context: <span class="type">TaskContext</span>,</div><div class="line">     storageLevel: <span class="type">StorageLevel</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</div><div class="line">   <span class="keyword">val</span> key = <span class="type">RDDBlockId</span>(rdd.id, partition.index)</div><div class="line">   blockManager.get(key) <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(blockResult) =&gt;</div><div class="line">        <span class="comment">// Partition is already materialized, so just return its values</span></div><div class="line">        context.taskMetrics.inputMetrics = <span class="type">Some</span>(blockResult.inputMetrics)</div><div class="line">        <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, blockResult.data.asInstanceOf[<span class="type">Iterator</span>[<span class="type">T</span>]])    </div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">        <span class="comment">// 省略部分源码</span></div><div class="line">        <span class="keyword">val</span> computedValues = rdd.computeOrReadCheckpoint(partition, context)</div><div class="line">        <span class="keyword">val</span> cachedValues = putInBlockManager(key, computedValues, storageLevel, updatedBlocks)</div><div class="line">        <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, cachedValues)</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 省略部分源码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getOrCompute</code>方法会根据 RDD 编号与分区编号计算得到当前分区在存储层对应的块编号，通过存储层提供的数据读取接口提取出块的数据。这时候会有两种可能情况发生：</p>
<ul>
<li>数据之前已经存储在存储介质当中，可能是数据本身就在存储介质（如读取 HDFS 中的文件创建得到的 RDD）当中，也可能是 RDD 经过持久化操作并经历了一次计算过程。这时候就能成功提取得到数据并将其返回。</li>
<li>数据不在存储介质当中，可能是数据已经丢失，或者 RDD 经过持久化操作，但是是当前分区数据是第一次被计算，因此会出现拉取得到数据为 None 的情况。这就意味着我们需要计算分区数据，继续调用 RDD 类 computeOrReadCheckpoint 方法来计算数据，并将计算得到的数据缓存到存储介质中，下次就无需再重复计算。</li>
<li>如果当前RDD的存储级别为 None，说明为未经持久化的 RDD，需要重新计算 RDD 内的数据，这时候调用 RDD 类的 computeOrReadCheckpoint 方法，该方法也在持久化 RDD 的分区获取数据失败时被调用。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Compute an RDD partition or read it from a checkpoint if the RDD is checkpointing.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">computeOrReadCheckpoint</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">if</span> (isCheckpointed) firstParent[<span class="type">T</span>].iterator(split, context) <span class="keyword">else</span> compute(split, context)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>computeOrReadCheckpoint</code>方法会检查当前 RDD 是否已经被标记成检查点，如果未被标记成检查点，则执行自身的<code>compute</code>方法来计算分区数据，否则就直接拉取父 RDD 分区内的数据。</p>
<h2 id="如何正确的获取计算结果"><a href="#如何正确的获取计算结果" class="headerlink" title="如何正确的获取计算结果"></a>如何正确的获取计算结果</h2><p>说了那么多理论，我们回到问题本身，怎么才是获取运算结果的正确方法？你也许会说，既然 transformation() 操作是惰性的，那么在之后马上触发一个 action() 操作就 OK 了。但这也是不正确的，这就涉及到了 Spark 的另外一个重要概念：分布式，在这里就不展开讲了，有兴趣可以参考官方文档：<a href="http://spark.apache.org/docs/latest/programming-guide.html#understanding-closures-a-nameclosureslinka" target="_blank" rel="external">Understanding closures </a>。</p>
<p>下面是一个正确的实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RddTransformer</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doTransform</span></span>(data: <span class="type">RDD</span>[<span class="type">Data</span>]): <span class="type">RDD</span>[<span class="type">NewData</span>]=&#123;</div><div class="line">    <span class="keyword">val</span> newDataRdd = data.flatmap(<span class="type">DataTransformer</span>.doTransform).cache()</div><div class="line"></div><div class="line">    <span class="keyword">val</span> exceptionCount = newDataRdd.filter(_.isEmpty).count()</div><div class="line">    <span class="keyword">if</span>(exceptionCount &gt; <span class="number">0</span>) &#123;</div><div class="line">      logger.error(<span class="string">s"There are some illegal data, count: <span class="subst">$&#123;DataTransformer.exceptionCount&#125;</span>"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    newDataRdd</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataTransformer</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doTransform</span></span>(data: <span class="type">Data</span>): <span class="type">Option</span>[<span class="type">NewData</span>]=&#123;</div><div class="line">    <span class="keyword">if</span>(data.isIllegal)&#123;</div><div class="line">      <span class="type">None</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">// do something transform data to new data</span></div><div class="line">      .....</div><div class="line"></div><div class="line">      <span class="type">Some</span>(newData)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在检视项目代码的时候，无意中发现了下面一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RddTransformer&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doTransform&lt;/span&gt;&lt;/span&gt;(data: &lt;span class=&quot;type&quot;&gt;RDD&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Data&lt;/span&gt;]): &lt;span class=&quot;type&quot;&gt;RDD&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;NewData&lt;/span&gt;]=&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; newDataRdd = data.flatmap(&lt;span class=&quot;type&quot;&gt;DataTransformer&lt;/span&gt;.doTransform)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;DataTransformer&lt;/span&gt;.exceptionCount &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      logger.error(&lt;span class=&quot;string&quot;&gt;s&quot;There are some illegal data, count: &lt;span class=&quot;subst&quot;&gt;$&amp;#123;DataTransformer.exceptionCount&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newDataRdd&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataTransformer&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; exceptionCount:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doTransform&lt;/span&gt;&lt;/span&gt;(data: &lt;span class=&quot;type&quot;&gt;Data&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Option&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;NewData&lt;/span&gt;]=&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(data.isIllegal)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      exceptionCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// do something transform data to new data&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      .....&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Some&lt;/span&gt;(newData)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://allenn.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="http://allenn.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"/>
    
    
      <category term="Spark" scheme="http://allenn.cn/tags/Spark/"/>
    
      <category term="Scala" scheme="http://allenn.cn/tags/Scala/"/>
    
      <category term="函数式编程" scheme="http://allenn.cn/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="惰性计算" scheme="http://allenn.cn/tags/%E6%83%B0%E6%80%A7%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>使用 EdgeMax 路由器自动翻墙</title>
    <link href="http://allenn.cn/articles/2016-10/2016-10-20-edgemax-ss-tutorial/"/>
    <id>http://allenn.cn/articles/2016-10/2016-10-20-edgemax-ss-tutorial/</id>
    <published>2016-10-20T14:21:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>作为肉身在墙内的计算机科学技术人员，不能上google实在是一件很遗憾的事情。</p>
<blockquote>
<p>什么？你说用百度？你站出来，我是你老板我肯定会开除你。</p>
</blockquote>
<p> 百度搜索简直是垃圾中的战斗机，在使用百度时，你不得不忍受他的各种广告，各种竞价排名，而且英文资料极少。很多领先的开源作品、解决方案、论文什么的基本都是国外的。这些资料你查不到，你说什么与国际先进技术接轨？总之，没用过 Google 之前，你可能没什么感觉，但是用过了之后再用”某度”，你会抱怨，这搜的是些什么破玩意儿。。。但是，因为众所周知的原因，我们无法直接访问 Google，不能访问一些很优秀的国外网站，比如 slideshare（里面有很多优秀的PPT、文档）等等。那么怎么办？答案就是：翻墙！</p>
 <a id="more"></a>
<blockquote>
<p>网监同志，我知道你在盯着我，我写这个纯粹是为了方便技术人员查阅资料，作为爱党爱国的四有青年，我翻墙出去后保证不受反动思想的荼毒，努力在墙外为祖国占领舆论高地</p>
</blockquote>
<p> 翻墙的姿势有很多，什么 VPN，代理，自由门等等，本人也尝试过不少，目前来说用得最稳定的当属<a href="https://shadowsocks.org" target="_blank" rel="external">Shadowsocks</a>。刚开始的时候只是在一个 Shadowsocks 服务提供商处购买了一个账号，在我的 Macbook 上试用，后面发现翻墙速度快且稳定，就萌生了在路由器上安装 Shadowsocks 的想法，正好家中的主路由器是 EdgeRouter Lite 3（Unix 架构，完美！），于是：Let’s do it!</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在搜索引擎中输入<code>Shadowsocks+路由器</code>关键字，可以搜索出很多安装教程，采用的方案也不尽相同，建议不想太折腾的话就买一个可以刷 OpenWRT 的路由器，按照这个博客（<a href="https://cokebar.info/archives/978" target="_blank" rel="external">https://cokebar.info/archives/978</a>）的教程安装配置就可以了。如果你和我一样入了 EdgeRouter 的坑，那我们继续~。</p>
<p>我采用的方案是使用 Shadowsocks + ChinaDNS + DNSMasq + iptables 来实现路由器智能翻墙，即国内流量走正常网络，国外流量走 Shadowsocks 代理，总体流程如下图：</p>
<p><img src="/assets/images/2016-10-20-edgemas-ss-tutorial/proxy-flow.png" alt="流程图"></p>
<h2 id="所需软件"><a href="#所需软件" class="headerlink" title="所需软件"></a>所需软件</h2><h3 id="shadowsocks-libev"><a href="#shadowsocks-libev" class="headerlink" title="shadowsocks-libev"></a>shadowsocks-libev</h3><p>项目地址：<a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks-libev</a>，可下载源码在路由器上进行编译，或者直接下载<a href="https://www.onlyos.com/wp-content/uploads/2015/08/shadowsocks-libev_2.2.4-1_mips.zip" target="_blank" rel="external">安装包</a>，请注意这个安装包只适用于 EdgeRouter Lite 3，其他 EdgeMax 产品需要自行编译。</p>
<h3 id="ChinaDNS"><a href="#ChinaDNS" class="headerlink" title="ChinaDNS"></a>ChinaDNS</h3><p>项目地址：<a href="https://github.com/shadowsocks/ChinaDNS" target="_blank" rel="external">https://github.com/shadowsocks/ChinaDNS</a>，可下载源码在路由器上进行编译，或者直接下载<a href="https://www.onlyos.com/wp-content/uploads/2015/08/chinadns-1.3.2.zip" target="_blank" rel="external">安装包</a>，请注意这个安装包只适用于 EdgeRouter Lite 3，其他 EdgeMax 产品需要自行编译。</p>
<h3 id="DNSMasq"><a href="#DNSMasq" class="headerlink" title="DNSMasq"></a>DNSMasq</h3><p>EdgeMax 中已经集成了 DNSMasq 无需另外安装。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="shadowsocks-libev-1"><a href="#shadowsocks-libev-1" class="headerlink" title="shadowsocks-libev"></a>shadowsocks-libev</h3><p>shadowsocks-libev 安装好后，会在<code>/etc/init.d/</code>中安装一个启动脚本：<code>shadowsock-libev</code>，在路由器启动时会默认启动<code>ss-redir</code>服务，如果需要重启 Shadowsocks，可以使用命令：<code>sudo /etc/init.d/shadowsock-libev [start|stop|restart]</code>。Shadowsocks 的配置在文件<code>/etc/shadowsocks-libev/config.json</code>中，在这个文件中配置 Shadowsocks 需要链接的服务器信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;server&quot;:&quot;127.0.0.1&quot;,</div><div class="line">&quot;server_port&quot;:8388,</div><div class="line">&quot;local_address&quot;: &quot;0.0.0.0&quot;,</div><div class="line">&quot;local_port&quot;:1080,</div><div class="line">&quot;password&quot;:&quot;barfoo!&quot;,</div><div class="line">&quot;timeout&quot;:60,</div><div class="line">&quot;method&quot;:null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置完成后，<code>sudo /etc/init.d/shadowsock-libev restart</code>，这样 Shadowsocks 就在你的路由器上运行了。</p>
<h3 id="ChinaDNS-1"><a href="#ChinaDNS-1" class="headerlink" title="ChinaDNS"></a>ChinaDNS</h3><p>使用源码编译后，会生成一个二进制文件：chinadns，可以将这个文件复制到<code>/usr/bin</code>中方便后面使用。ChinaDNS 需要一个文件来标识哪些 IP 属于国内，这个文件可以从<a href="http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest" target="_blank" rel="external">这里下载</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 下载 ip 列表到： /tmp/chnroute.txt</div><div class="line">curl &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | grep ipv4 | grep CN | awk -F| ‘&#123; printf(“%s/%dn”, $4, 32-log($5)/log(2)) &#125;’ &gt; /tmp/chnroute.txt</div></pre></td></tr></table></figure>
<p>下载完成后，将文件移动到<code>/etc/chinadns/chnroute.txt</code>，接着我们就可以尝试启动 ChinaDNS 了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">chinadns -s 223.5.5.5,223.6.6.6,127.0.0.1:5300 -c /etc/chinadns/chnroute.txt -p 35353 -m</div></pre></td></tr></table></figure>
<p>需要注意的是<code>-s</code>参数后面的<code>127.0.0.1:5300</code>，这个代表将<code>ss-tunnel</code>转发的国外可信DNS站点作为上游DNS服务器。</p>
<h4 id="ChinaDNS参数详解"><a href="#ChinaDNS参数详解" class="headerlink" title="ChinaDNS参数详解"></a>ChinaDNS参数详解</h4><ul>
<li>-l：虚假IP列表：默认值：/etc/chinadns_iplist.txt</li>
</ul>
<p>是GFW常见的DNS污染用IP列表，解析出列表中的IP结果时候，ChinaDNS会自动抛弃，保留默认即可；</p>
<ul>
<li>-c：chnroute文件：默认值：/etc/chinadns_chnroute.txt</li>
</ul>
<p>此文件标识哪些IP属于国内。用于ChinaDNS判断解析结果。ChinaDNS要求解析结果与DNS要匹配，国内网站采用国内DNS解析的结果，国外网站采用国外DNS解析结果，等等规则；确保以上两个文件内容完整无误，否则会造成无法启动；</p>
<ul>
<li>-p：本地端口：默认值：5353</li>
</ul>
<p>ChinaDNS所监听的端口。根据实际情况更改，注意不能和其他服务的端口重复（特别是DNSMasq和shadowsocks）；</p>
<ul>
<li>-s: 上游服务器：默认值：114.114.114.114,8.8.8.8</li>
</ul>
<p>可填入一系列的上游DNS服务器，根据实际情况来，可以保留默认，格式为”DNS_IP:PORT,DNS_IP:PORT”注意逗号后面不能有空格。有些ISP会封杀公共DNS，此时请将114DNS改为ISP的DNS；此处必须至少填入一个国内IP的DNS和一个国外IP的DNS，否则会造成ChinaDNS启动失败。额外的用法：ChinaDNS添加可信DNS避免一些异常</p>
<ul>
<li>-y：等待时间： 默认值：0.3</li>
</ul>
<p>为防止GFW的DNS污染抢答，而设置一个等待时间，请根据自己填写的国外DNS延迟值来填写，留下一定的裕度。GoogleDNS在国内延迟一般在100-200ms，留0.3比较合适。过大的值会造成DNS解析较大的延迟时间，过小的值可能导致无法接收正确的解析结果。</p>
<ul>
<li>-d：双向过滤： 默认：开启</li>
</ul>
<p>勾选时，当国外DNS服务器返回的查询结果是国内IP，或者当国内DNS服务器返回的查询结果是国外IP，则过滤掉这个结果（较为严格的模式）；去掉勾选的话只是过滤国内DNS的国外IP结果。</p>
<ul>
<li>-m：启用压缩指针： 默认：不开启</li>
</ul>
<p>利用GFW遇到压缩指针时的一个bug来精确识别来自GFW的抢答污染，从而极大提高识别的准确性和识别的效率，推荐启用，启用后，IPList和等待时间将禁用（因为用不到了）。 （已强制开启）</p>
<h3 id="ss-tunnel"><a href="#ss-tunnel" class="headerlink" title="ss-tunnel"></a>ss-tunnel</h3><p>ss-tunnel 是 Shadowsocks 的一个模块，可以用于 UDP 转发，为了防止 GFW 的 DNS 污染，我们用它来转发国外 DNS，可以通过下面命令来启动 ss-tunnel：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ss-tunnel -c /etc/shadowsocks-libev/config.json -u -b 0.0.0.0 -l 5300 -L 8.8.8.8:53</div></pre></td></tr></table></figure>
<p>为了让 ss-tunnel 在每次重启路由器的时候自动重启，我们可以写个脚本放在<code>/config/scripts/post-config.d</code>目录下。</p>
<h3 id="DNSMasq-1"><a href="#DNSMasq-1" class="headerlink" title="DNSMasq"></a>DNSMasq</h3><p>首先需要将系统的 DNS 服务器设置为本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">configure</div><div class="line"># 停止通过pppoe更新dns设置，如果pppoe绑定在其他网口上，eth0需要变更为对应网口</div><div class="line">set interfaces ethernet eth0 pppoe 0 name-server none</div><div class="line"></div><div class="line"># 设置 DNSMasq 使用 ChinaDNS</div><div class="line"># 需要注意的是，这里无法设置服务器端口，只能先这样设置后，再手工变更配置文件</div><div class="line">edit service dns forwarding</div><div class="line">set name-server 127.0.0.1</div><div class="line"></div><div class="line"># 告诉路由器使用本地 DNSMasq 来解析域名</div><div class="line">set system name-server 127.0.0.1</div><div class="line"></div><div class="line">commit</div><div class="line">save</div><div class="line">exit</div></pre></td></tr></table></figure>
<p>修改<code>/etc/dnsmasq.conf</code>，去除你之前自定义的规则，在最后加入<code>conf-dir=/etc/dnsmasq.d</code>，并将<code>server=127.0.0.1</code>修改为<code>server=127.0.0.1#35353</code>。新建并进入目录<code>/etc/dnsmasq.d</code>，下载 <a href="https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.conf" target="_blank" rel="external">accelerated-domains.china.conf</a> 和<a href="http://pan.baidu.com/s/1eQB7ACi" target="_blank" rel="external">foreign_list.conf</a>两个文件后复制两个文件到<code>/etc/dnsmasq.d</code>目录。这两个文件都会有更新，建议隔段时间更新一下。分别修改两个文件，将<code>accelerated-domains.china.conf</code>（ChinaList）文件中所有的的114.114.114.114修改为自己ISP的DNS或者其他效果更好的国内DNS的IP地址（也可以保留114DNS），格式为：<code>server=/0-6.com/IP</code>；将<code>foreign_list.conf</code>（GFWList）文件中所有的 127.0.0.1#5300 修改为自己所用国外DNS，格式为：<code>server=/.lsxszzg.com/IP#PORT</code>，如果你使用shadowsocks的UDP转发来提供国外DNS解析，UDP转发的端口号为5300，那么就是默认的 127.0.0.1#5300 ，如果你使用一个非标端口的国外DNS服务，如3.4.5.6，端口5353，那么就改为 3.4.5.6#5353 。注意不要使用国外公共DNS，因为会被污染！最后重启 dnsmasq：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo /etc/init.d/dnsmasq restart</div></pre></td></tr></table></figure>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>上面所做的一切都是为了防止 GFW 的 DNS 污染，从而拿到正确的 IP 地址，那么拿到 IP 地址后，又如何将国外的流量转发到 Shadowsocks 呢？现在该 iptables 登场了，使用下面的代码设置 iptables 转发规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Setup the ipset</div><div class="line">ipset -N chnroute hash:net maxelem 65536</div><div class="line"></div><div class="line">for ip in $(cat &apos;/etc/chinadns/chnroute.txt&apos;); do</div><div class="line">  ipset add chnroute $ip</div><div class="line">done</div><div class="line"></div><div class="line"># 其他请求：</div><div class="line"># shadowsocks</div><div class="line">iptables -t nat -N SHADOWSOCKS</div><div class="line"></div><div class="line">iptables -t nat -A SHADOWSOCKS -p tcp --dport 23596 -j RETURN</div><div class="line"># 23596 是 ss 代理服务器的端口，即远程 shadowsocks 服务器提供服务的端口，如果你有多个 ip 可用,但端口一致，就设置这个</div><div class="line">iptables -t nat -A SHADOWSOCKS -d 123.456.789.111 -j RETURN</div><div class="line"># 123.456.789.111 是 ss 代理服务器的 ip, 如果你只有一个 ss服务器的 ip，却能选择不同端口,就设置此条</div><div class="line"></div><div class="line"># ignore internal ip</div><div class="line">iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN</div><div class="line">iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN</div><div class="line">iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN</div><div class="line">iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN</div><div class="line">iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN</div><div class="line">iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN</div><div class="line">iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN</div><div class="line">iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN</div><div class="line"></div><div class="line"># ignore asia ip</div><div class="line"></div><div class="line"># Allow connection to chinese IPs</div><div class="line">iptables -t nat -A SHADOWSOCKS -p tcp -m set --match-set chnroute dst -j RETURN</div><div class="line"></div><div class="line">iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports 1080</div><div class="line">iptables -t nat -I PREROUTING -p tcp -j SHADOWSOCKS</div></pre></td></tr></table></figure>
<p>iptables 配置完后，你应该可以再浏览器中正常的打开 Google 首页了。</p>
<h3 id="一键式-DNS-配置脚本"><a href="#一键式-DNS-配置脚本" class="headerlink" title="一键式 DNS 配置脚本"></a>一键式 DNS 配置脚本</h3><p>使用下面的脚本可以在重启路由器时（需要将脚本放在<code>/config/scripts/post-config.d</code>目录下）更新<code>foreign_list.conf</code>和<code>accelerated-domains.china.conf</code>两个文件，并配置好 iptables：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">deleteFile() &#123;</div><div class="line">  local filePath=$1</div><div class="line">  if [ -f &quot;$filePath&quot; ]; then</div><div class="line">   rm &quot;$filePath&quot;</div><div class="line">  fi</div><div class="line">&#125;</div><div class="line"># get chinadns ignore list</div><div class="line">updateChnroute() &#123;</div><div class="line">  deleteFile /tmp/chnroute.txt</div><div class="line"></div><div class="line">  curl &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | grep ipv4 | grep CN | awk -F\| &apos;&#123; printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) &#125;&apos; &gt;  /tmp/chnroute.txt</div><div class="line">  mv -f /tmp/chnroute.txt /etc/chinadns/</div><div class="line">  chmod 644 /etc/chinadns/chnroute.txt</div><div class="line"></div><div class="line">  if pidof chinadns&gt;/dev/null; then</div><div class="line">      /etc/init.d/chinadns restart</div><div class="line">  fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">updateDnsmasqConf() &#123;</div><div class="line">  deleteFile /tmp/accelerated-domains.china.conf</div><div class="line">  # download accelerated-domains.china.conf</div><div class="line">  local DNS=223.5.5.5</div><div class="line">  curl &apos;https://raw.githubusercontent.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.conf&apos; &gt; /tmp/accelerated-domains.china.conf</div><div class="line">  sed -i &quot;s|^\(server.*\)/[^/]*$|\1/$DNS|&quot;  /tmp/accelerated-domains.china.conf</div><div class="line">  mv -f /tmp/accelerated-domains.china.conf /etc/dnsmasq.d/</div><div class="line">  chmod 644 /etc/dnsmasq.d/accelerated-domains.china.conf</div><div class="line"></div><div class="line">  # download foreign_list.conf</div><div class="line">  python ../gfwlist2dnsmasq_noipset.py</div><div class="line"></div><div class="line">  if pidof dnsmasq&gt;/dev/null; then</div><div class="line">      /etc/init.d/dnsmasq restart</div><div class="line">  fi</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">configIptables() &#123;</div><div class="line">  # Setup the ipset</div><div class="line">  ipset -N chnroute hash:net maxelem 65536</div><div class="line"></div><div class="line">  for ip in $(cat &apos;/etc/chinadns/chnroute.txt&apos;); do</div><div class="line">    ipset add chnroute $ip</div><div class="line">  done</div><div class="line"></div><div class="line">  # 其他请求：</div><div class="line">  # shadowsocks</div><div class="line">  iptables -t nat -N SHADOWSOCKS</div><div class="line"></div><div class="line">  iptables -t nat -A SHADOWSOCKS -p tcp --dport 33348 -j RETURN</div><div class="line">  iptables -t nat -A SHADOWSOCKS -d 103.192.224.122 -j RETURN</div><div class="line"></div><div class="line">  # ignore internal ip</div><div class="line">  iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN</div><div class="line">  iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN</div><div class="line">  iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN</div><div class="line">  iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN</div><div class="line">  iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN</div><div class="line">  iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN</div><div class="line">  iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN</div><div class="line">  iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN</div><div class="line"></div><div class="line">  # ignore asia ip</div><div class="line"></div><div class="line">  # Allow connection to chinese IPs</div><div class="line">  iptables -t nat -A SHADOWSOCKS -p tcp -m set --match-set chnroute dst -j RETURN</div><div class="line"></div><div class="line">  iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports 1080</div><div class="line">  iptables -t nat -I PREROUTING -p tcp -j SHADOWSOCKS</div><div class="line">&#125;</div><div class="line"></div><div class="line">updateChnroute</div><div class="line">updateDnsmasqConf</div><div class="line">configIptables</div></pre></td></tr></table></figure>
<p>gfwlist2dnsmasq_noipset.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line">#coding=utf-8</div><div class="line">#</div><div class="line"># Generate a list of dnsmasq rules with ipset for gfwlist</div><div class="line">#</div><div class="line"># Copyright (C) 2014 http://www.shuyz.com</div><div class="line"># Ref https://code.google.com/p/autoproxy-gfwlist/wiki/Rules</div><div class="line"></div><div class="line">import urllib2</div><div class="line">import re</div><div class="line">import os</div><div class="line">import datetime</div><div class="line">import base64</div><div class="line">import shutil</div><div class="line">import ssl</div><div class="line"></div><div class="line">mydnsip = &apos;127.0.0.1&apos;</div><div class="line">mydnsport = &apos;5300&apos;</div><div class="line"># Extra Domain;</div><div class="line">EX_DOMAIN=[ \</div><div class="line">&apos;.google.com&apos;, \</div><div class="line">&apos;.google.com.hk&apos;, \</div><div class="line">&apos;.google.com.tw&apos;, \</div><div class="line">&apos;.google.com.sg&apos;, \</div><div class="line">&apos;.google.co.jp&apos;, \</div><div class="line">&apos;.google.co.kr&apos;, \</div><div class="line">&apos;.blogspot.com&apos;, \</div><div class="line">&apos;.blogspot.sg&apos;, \</div><div class="line">&apos;.blogspot.hk&apos;, \</div><div class="line">&apos;.blogspot.jp&apos;, \</div><div class="line">&apos;.blogspot.kr&apos;, \</div><div class="line">&apos;.gvt1.com&apos;, \</div><div class="line">&apos;.gvt2.com&apos;, \</div><div class="line">&apos;.gvt3.com&apos;, \</div><div class="line">&apos;.1e100.net&apos;, \</div><div class="line">&apos;.blogspot.tw&apos; \</div><div class="line">]</div><div class="line"></div><div class="line"># the url of gfwlist</div><div class="line">baseurl = &apos;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&apos;</div><div class="line"># match comments/title/whitelist/ip address</div><div class="line">comment_pattern = &apos;^\!|\[|^@@|^\d+\.\d+\.\d+\.\d+&apos;</div><div class="line">domain_pattern = &apos;([\w\-\_]+\.[\w\.\-\_]+)[\/\*]*&apos;</div><div class="line">ip_pattern = re.compile(r&apos;\b\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\b&apos;)</div><div class="line">tmpfile = &apos;/tmp/gfwlisttmp&apos;</div><div class="line"># do not write to router internal flash directly</div><div class="line">outfile = &apos;/tmp/dnsmasq_list.conf&apos;</div><div class="line">rulesfile = &apos;/etc/dnsmasq.d/foreign_list.conf&apos;</div><div class="line"></div><div class="line">fs =  file(outfile, &apos;w&apos;)</div><div class="line">fs.write(&apos;# gfw list ipset rules for dnsmasq\n&apos;)</div><div class="line">fs.write(&apos;# updated on &apos; + datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) + &apos;\n&apos;)</div><div class="line">fs.write(&apos;#\n&apos;)</div><div class="line"></div><div class="line">print &apos;fetching list...&apos;</div><div class="line">if hasattr(ssl, &apos;_create_unverified_context&apos;):</div><div class="line">truessl._create_default_https_context = ssl._create_unverified_context</div><div class="line">content = urllib2.urlopen(baseurl, timeout=15).read().decode(&apos;base64&apos;)</div><div class="line"></div><div class="line"># write the decoded content to file then read line by line</div><div class="line">tfs = open(tmpfile, &apos;w&apos;)</div><div class="line">tfs.write(content)</div><div class="line">tfs.close()</div><div class="line">tfs = open(tmpfile, &apos;r&apos;)</div><div class="line"></div><div class="line">print &apos;page content fetched, analysis...&apos;</div><div class="line"></div><div class="line"># remember all blocked domains, in case of duplicate records</div><div class="line">domainlist = []</div><div class="line"></div><div class="line"></div><div class="line">for line in tfs.readlines():</div><div class="line">trueif re.findall(comment_pattern, line):</div><div class="line">truetrueprint &apos;this is a comment line: &apos; + line</div><div class="line">truetrue#fs.write(&apos;#&apos; + line)</div><div class="line">trueelse:</div><div class="line">truetruedomain = re.findall(domain_pattern, line)</div><div class="line">truetrueif domain:</div><div class="line">truetruetruetry:</div><div class="line">truetruetruetruefound = domainlist.index(domain[0])</div><div class="line">truetruetruetrueprint domain[0] + &apos; exists.&apos;</div><div class="line">truetruetrueexcept ValueError:</div><div class="line">truetruetruetrueif ip_pattern.match(domain[0]):</div><div class="line">truetruetruetruetrueprint &apos;skipping ip: &apos; + domain[0]</div><div class="line">truetruetruetruetruecontinue</div><div class="line">truetruetruetrueprint &apos;saving &apos; + domain[0]</div><div class="line">truetruetruetruedomainlist.append(domain[0])</div><div class="line">truetruetruetruefs.write(&apos;server=/.%s/%s#%s\n&apos;%(domain[0],mydnsip,mydnsport))</div><div class="line">truetrueelse:</div><div class="line">truetruetrueprint &apos;no valid domain in this line: &apos; + line</div><div class="line"></div><div class="line">tfs.close()</div><div class="line"></div><div class="line">for each in EX_DOMAIN:</div><div class="line">truefs.write(&apos;server=/%s/%s#%s\n&apos;%(each,mydnsip,mydnsport))</div><div class="line"></div><div class="line">print &apos;write extra domain done&apos;</div><div class="line"></div><div class="line">fs.close();</div><div class="line">print &apos;moving generated file to dnsmasg directory&apos;</div><div class="line">shutil.move(outfile, rulesfile)</div><div class="line"></div><div class="line">print &apos;done!&apos;</div></pre></td></tr></table></figure>
<h2 id="一键式安装包"><a href="#一键式安装包" class="headerlink" title="一键式安装包"></a>一键式安装包</h2><p>捣鼓了一个一键式安装包，脚本归档在 Github 上，需要的朋友可以直接前往下载：<a href="https://github.com/allenn/er-ss" target="_blank" rel="external">https://github.com/allenn/er-ss</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为肉身在墙内的计算机科学技术人员，不能上google实在是一件很遗憾的事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么？你说用百度？你站出来，我是你老板我肯定会开除你。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 百度搜索简直是垃圾中的战斗机，在使用百度时，你不得不忍受他的各种广告，各种竞价排名，而且英文资料极少。很多领先的开源作品、解决方案、论文什么的基本都是国外的。这些资料你查不到，你说什么与国际先进技术接轨？总之，没用过 Google 之前，你可能没什么感觉，但是用过了之后再用”某度”，你会抱怨，这搜的是些什么破玩意儿。。。但是，因为众所周知的原因，我们无法直接访问 Google，不能访问一些很优秀的国外网站，比如 slideshare（里面有很多优秀的PPT、文档）等等。那么怎么办？答案就是：翻墙！&lt;/p&gt;
    
    </summary>
    
      <category term="网络技术" scheme="http://allenn.cn/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="GFW" scheme="http://allenn.cn/tags/GFW/"/>
    
      <category term="防火墙" scheme="http://allenn.cn/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
      <category term="EdgeMax" scheme="http://allenn.cn/tags/EdgeMax/"/>
    
      <category term="路由器" scheme="http://allenn.cn/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>全面学习GFW</title>
    <link href="http://allenn.cn/articles/2016-10/2016-10-20-learn-gfw/"/>
    <id>http://allenn.cn/articles/2016-10/2016-10-20-learn-gfw/</id>
    <published>2016-10-20T08:21:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>摘自：<a href="https://docs.google.com/document/d/1mmMiMYbviMxJ-DhTyIGdK7OOg581LSD1CZV4XY1OMG8/edit#heading=h.qgojh5xsppyz" target="_blank" rel="external">翻墙路由器的实现与原理</a></p>
<p>注：本文只供研究学习网络技术使用，请阅读者在24小时内忘记本文内容，谢绝网监请喝茶。</p>
<p>GFW会是一个长期的存在。要学会与之共存，必须先了解GFW是什么。做为局外人，学习GFW有六个角度。渐进的来看分别是：</p>
<p>首先我们学习到的是WHAT和WHEN。比如说，你经常听到人的议论是“昨天”，“github”被封了。其中的昨天就是WHEN，github就是WHAT。这是学习GFW的最天然，最朴素的角度。在这个方面做得非常极致的是一个叫做<a href="https://en.greatfire.org/" target="_blank" rel="external">greatfire</a>的网站。这个网站长期监控成千上万个网站和关键词。通过长期监控，不但可以掌握WHAT被封锁了，还可以知道WHEN被封的，WHEN被解封的。</p>
<a id="more"></a>
<p>接下来的角度是WHO。比如说，“方校长”这个人名就经常和GFW同时出现。但是如果仅仅是掌握一个两个人名，然后像某位同志那样天天在twitter上骂一遍那样，除了把这个人名骂成名人之外，没有什么特别的积极意义。我更看好这篇文章“通过分析论文挖掘防火长城(GFW)的技术人员”的思路。通过网络上的公开信息，掌握GFW的哪些方面与哪些人有关系，这些合作者之间又有什么联系。除了大家猜测的将来可以鞭尸之外，对现在也是有积极的意义的。比如关注这些人的研究动态和思想发展，可以猜测GFW的下一步发展方向。比如阅读过去发表的论文，可以了解GFW的技术演进历史，可以从历史中找到一些技术或者管理体制上的缺陷。</p>
<p>再接下来就是WHY了。github被封之后就常听人说，github这样的技术网站你封它干啥？是什么原因促成了一个网站的被封与解封的？我们做为局外人，真正的原因当然是无从得知的。但是我们可以猜测。基于猜测，可以把不同网站被封，与网络上的舆情时间做关联和分类。我们知道，方校长对于网路舆情监控是有很深入研究的。有一篇<a href="https://docs.google.com/file/d/0B3q8z0KnC5z6Zjc4VzdfOVN3RzA/edit?usp=sharing" target="_blank" rel="external">论文</a>（Whiskey, Weed, and Wukan on the World Wide Web: On Measuring Censors’ Resources and Motivations）专门讨论监管者的动机的。观测触发被封的事件与实际被封之间的时间关系，也可以推测出一些有趣的现象。比如有人报告，OpenVPN触发的封端口和封IP这样的事情一般都发生在中国的白天。也就是说，GFW背后不光是机器，有一些组件是血肉构成的。</p>
<p>剩下的两个角度就是对如何翻墙穿墙最有价值的两个角度了：HOW和WHERE。HOW是非常好理解的，就是在服务器和客户端两边抓包，看看一个正常的网络通信，GFW做为中间人，分别给两端在什么时候发了什么包或者过滤掉了什么包。而这些GFW做的动作，无论是过滤还是发伪包又是如何干扰客户端与服务器之间的正常通信的。WHERE是在知道了HOW之后的进一步发展，不但要了解客户端与服务器这两端的情况，更要了解GFW是挂在两端中间的哪一级路由器上做干扰的。在了解到GFW的关联路由器的IP的基础上，可以根据不同的干扰行为，不同的运营商归属做分组，进一步了解GFW的整体部署情况。</p>
<p>整体上来说，对GFW的研究都是从WHAT和WHEN开始，让偏人文的就去研究WHO和WHY，像我们这样偏工程的就会去研究HOW和WHERE。以上就是全面了解GFW的主体脉络。接下来，我们就要以HOW和WHERE这两个角度去看一看GFW的原理。</p>
<h1 id="GFW的原理"><a href="#GFW的原理" class="headerlink" title="GFW的原理"></a>GFW的原理</h1><p>要与GFW对抗不能仅仅停留在什么不能访问了，什么可以访问之类的表面现象上。知道youtube不能访问了，对于翻墙来说并无帮助。但是知道GFW是如何让我们不能访问youtube的，则对下一步的翻墙方案的选择和实施具有重大意义。所以在讨论如何翻之前，先要深入原理了解GFW是如何封的。</p>
<p>总的来说，GFW是一个分布式的入侵检测系统，并不是一个严格意义上的防火墙。不是说每个出入国境的IP包都需要先经过GFW的首可。做为一个入侵检测系统，GFW把你每一次访问facebook都看做一次入侵，然后在检测到入侵之后采取应对措施，也就是常见的连接重置。整个过程一般话来说就是：</p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-1.png" alt="learn-gfw-1"></p>
<p>检测有两种方式。一种是人工检测，一种是机器检测。你去国新办网站举报，就是参与了人工检测。在人工检测到不和谐的网站之后，就会采取一些应对方式来防止国内的网民访问该网站。对于这类的封锁，规避检测就不是技术问题了，只能从GFW采取的应对方式上采取反制措施。另外一类检测是机器检测，其检测过程又可以再进一步细分：</p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-2.png" alt="learn-gfw-2"></p>
<h2 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h2><p>重建是指GFW从网络上监听过往的IP包，然后分析其中的TCP协议，最后重建出一个完整的字节流。分析是在这个重建的字节流上分析具体的应用协议，比如HTTP协议。然后在应用协议中查找是不是有不和谐的内容，然后决定采用何种应对方式。</p>
<p>所以，GFW机器检测的第一步就是重建出一个字节流。那么GFW是如何拿到原始的IP包的呢？真正的GFW部署方式，外人根本无从得知。据猜测，GFW是部署在国家的出口路由器的旁路上，用“分光”的方式把IP包复制一份到另外一根光纤上，从而拿到所有进出国境的IP包。下图引在gfwrev.blogspot.com：</p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-3.png" alt="learn-gfw-3"></p>
<p>但是Google在北京有自己的机房。所以聪明的网友就使用Google的北京机房提供的GAE服务，用Goagent软件达到高速翻墙的目的。但是有网友证实（<a href="https://twitter.com/chengr28/status/260970749190365184" target="_blank" rel="external">https://twitter.com/chengr28/status/260970749190365184</a>），即便是北京的机房也会被骨干网丢包。事实上Google在北京的谷翔机房有一个独立的AS（BGP的概念）。这个AS与谷歌总部有一条IPV6的直连线路，所以通过这个机房可以用IPV6不受墙的限制出去。但是这个AS无论是连接国内还是国外都是要经过GFW的。所以机房在北京也不能保证国内访问不被墙。GFW通过配置骨干网的BGP路由规则，是可以让国内的机房也经过它的。另外一个例子是当我们访问被封的网站触发连接重置的时候，往往收到两个RST包，但是TTL不同。还有一个例子是对于被封的IP，访问的IP包还没有到达国际出口就已经被丢弃。所以GFW应该在其他地方也部署有设备，据推测是在省级骨干路由的位置。</p>
<p>对于GFW到底在哪这个话题，最近又有国外友人表达了兴趣（<a href="https://github.com/mothran/mongol" target="_blank" rel="external">https://github.com/mothran/mongol</a>）。笔者在前人的基础上写了一个更完备的<a href="https://github.com/fqrouter/qiang" target="_blank" rel="external">探测工具</a>。其原理是基于一个IP协议的特性叫TTL。TTL是Time to Live的简写。IP包在没经过一次路由的时候，路由器都会把IP包的TTL减去1。如果TTL到零了，路由器就不会再把IP包发给下一级路由。然后我们知道GFW会在监听到不和谐的IP包之后发回RST包来重置TCP连接。那么通过设置不同的TTL就可以知道从你的电脑，到GFW之间经过了几个路由器。比如说TTL设置成9不触发RST，但是10就触发RST，那么到GFW就是经过了10个路由器。另外一个IP协议的特性是当TTL耗尽的时候，路由器应该发回一个TTL EXCEEDED的ICMP包，并把自己的IP地址设置成SRC（来源）。结合这两点，就可以探测出IP包是到了IP地址为什么的路由器之后才被GFW检测到。有了IP地址之后，再结合IP地址地理位置的数据库就可以知道其地理位置。据说，得出的位置大概是这样的：</p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-4.jpg" alt="learn-gfw-4"></p>
<p>但是这里检测出来的IP到底是GFW的还是骨干路由器的？更有可能的是骨干路由器的IP。GFW做为一个设备用“分光”的方式挂在主干路由器旁边做入侵检测。无论如何，GFW通过某种神奇的方式，可以拿到你和国外服务器之间来往的所有的IP包，这点是肯定的。更严谨的理论研究有：<a href="http://pam2011.gatech.edu/papers/pam2011--Xu.pdf" target="_blank" rel="external">Internet Censorship in China: Where Does the Filtering Occur?</a></p>
<p>GFW在拥有了这些IP包之后，要做一个艰难的决定，那就是到底要不要让你和服务器之间的通信继续下去。GFW不能太过于激进，毕竟全国性的不能访问国外的网站是违反GFW自身存在价值的。GFW就需要在理解了IP包背后代表的含义之后，再来决定是不是可以安全的阻断你和国外服务器之间的连接。这种理解就要建立了前面说的“重建”这一步的基础上。大概用图表达一下重建是在怎么一回事：</p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-5.png" alt="learn-gfw-5"></p>
<p>重建需要做的事情就是把IP包1中的GET /inde和IP包2中的x.html H和IP包3中的TTP/1.1拼到一起变成GET /index.html HTTP/1.1。拼出来的数据可能是纯文本的，也可能是二进制加密的协议内容。具体是什么是你和服务器之间约定好的。GFW做为窃听者需要猜测才知道你们俩之间的交谈内容。对于HTTP协议就非常容易猜测了，因为HTTP的协议是标准化的，而且是未加密的。所以GFW可以在重建之后很容易的知道，你使用了HTTP协议，访问的是什么网站。</p>
<p>重建这样的字节流有一个难点是如何处理巨大的流量？这个问题在这篇<a href="http://gfwrev.blogspot.tw/2010/02/gfw.html" target="_blank" rel="external">博客</a>中已经讲得很明白了。其原理与网站的负载均衡器一样。对于给定的来源和目标，使用一个HASH算法取得一个节点值，然后把所有符合这个来源和目标的流量都往这个节点发。所以在一个节点上就可以重建一个TCP会话的单向字节流。</p>
<p>最后为了讨论完整，再提两点。虽然GFW的重建发生在旁路上是基于分光来实现的，但并不代表整个GFW的所有设备都在旁路。后面会提到有一些GFW应对形式必须是把一些GFW的设备部署在了主干路由上，比如对Google的HTTPS的间歇性丢包，也就是GFW是要参与部分IP的路由工作的。另外一点是，重建是单向的TCP流，也就是GFW根本不在乎双向的对话内容，它只根据监听到的一个方向的内容然后做判断。但是监听本身是双向的，也就是无论是从国内发到国外，还是从国外发到国内，都会被重建然后加以分析。所以一个TCP连接对于GFW来说会被重建成两个字节流。具体的证据会在后面谈如何直穿GFW中详细讲解。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分析是GFW在重建出字节流之后要做的第二步。对于重建来说，GFW主要处理IP协议，以及上一层的TCP和UDP协议就可以了。但是对于分析来说，GFW就需要理解各种各样的应用层的稀奇古怪的协议了。甚至，我们也可以自己发明新的协议。</p>
<p>总的来说，GFW做协议分析有两个相似，但是不同的目的。第一个目的是防止不和谐内容的传播，比如说使用Google搜索了“不该”搜索的关键字。第二个目的是防止使用翻墙工具绕过GFW的审查。下面列举一些已知的GFW能够处理的协议。</p>
<p>对于GFW具体是怎么达到目的一，也就是防止不和谐内容传播的就牵涉到对HTTP协议和DNS协议等几个协议的明文审查。大体的做法是这样的。</p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-6.png" alt="learn-gfw-6"></p>
<p>像HTTP这样的协议会有非常明显的特征供检测，所以第一步就没什么好说的了。当GFW发现了包是HTTP的包之后就会按照HTTP的协议规则拆包。这个拆包过程是GFW按照它对于协议的理解来做的。比如说，从HTTP的GET请求中取得请求的URL。然后GFW拿到这个请求的URL去与关键字做匹配，比如查找Twitter是否在请求的URL中。为什么有拆包这个过程？首先，拆包之后可以更精确的打击，防止误杀。另外可能预先做拆包，比全文匹配更节省资源。其次，xiaoxia和liruqi同学的<a href="https://github.com/liruqi/jjproxy" target="_blank" rel="external">jjproxy</a>的核心就是基于GFW的一个HTTP拆包的漏洞，当然这个bug已经被修复了。其原理就是GFW在拆解HTTP包的时候没有处理有多出来的rn这样的情况，但是你访问的google.com却可以正确处理额外的rn的情况。从这个例子中可以证明，GFW还是先去理解协议，然后才做关键字匹配的。关键字匹配应该就是使用了一些高效的正则表达式算法，没有什么可以讨论的。</p>
<p>HTTP代理和SOCKS代理，这两种明文的代理都可以被GFW识别。之前笔者认为GFW可以在识别到HTTP代理和SOCKS代理之后，再拆解其内部的HTTP协议的正文。也就是做两次拆包。但是分析发现，HTTP代理的关键字列表和HTTP的关键字列表是不一样的，所以笔者现在认为HTTP代理协议和SOCKS代理协议是当作单独的协议来处理的，并不是拆出载荷的HTTP请求再进行分析的。</p>
<p>目前已知的GFW会做的协议分析如下：</p>
<h3 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h3><p>GFW可以分析53端口的UDP协议的DNS查询。如果查询的域名匹配关键字则会被DNS劫持。可以肯定的是，这个匹配过程使用的是类似正则的机制，而不仅仅是一个黑名单，因为子域名实在太多了。证据是：2012年11月9日下午3点半开始，防火长城对Google的泛域名 .google.com 进行了大面积的污染，所有以 .google.com 结尾的域名均遭到污染而解析错误不能正常访问，其中甚至包括不存在的域名（来源：<a href="http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81</a>）</p>
<p>目前为止53端口之外的查询也没有被劫持。但是TCP的DNS查询已经可以被TCP RST切断了，表明了GFW具有这样的能力，只是不屑于大规模部署。而且TCP查询的关键字比UDP劫持的域名要少的多。目前只有dl.dropbox.com会触发TCP RST。相关的研究论文有：</p>
<ul>
<li><p><a href="http://corelabs.coresecurity.com/index.php?module=Wiki&amp;action=attachment&amp;type=researcher&amp;page=Ezequiel_Gutesman&amp;file=publication/Predicting_attacker_tools_risk_assessment/gutesman-abstract-4pgs.pdf" target="_blank" rel="external">Hold-On: Protecting Against On-Path DNS Poisoning</a></p>
</li>
<li><p><a href="http://cs.nyu.edu/~pcw216/work/nds/final.pdf" target="_blank" rel="external">The Great DNS Wall of China</a></p>
</li>
</ul>
<h3 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h3><p>GFW可以识别出HTTP协议，并且检查GET的URL与HOST。如果匹配了关键字则会触发TCP RST阻断。前面提到了jjproxy使用的构造特殊的HTTP GET请求欺骗GFW的做法已经失效，现在GFW只要看到rn就直接TCP RST阻断了（来源u/0/108661470402896863593/posts/6U6Q492M3yY）。相关的研究论文有：</p>
<ul>
<li><p><a href="http://www.internetfreedom.org/files/WhitePaper/ChinaGreatFirewallRevealed.pdf" target="_blank" rel="external">The Great Firewall Revealed</a></p>
</li>
<li><p><a href="http://www.cl.cam.ac.uk/~rnc1/ignoring.pdf" target="_blank" rel="external">Ignoring the Great Firewall of China</a></p>
</li>
<li><p><a href="http://gfwrev.blogspot.com/2010/03/http-url.html" target="_blank" rel="external">HTTP URL/深度关键字检测</a></p>
</li>
<li><p><a href="http://www.csd.uoc.gr/~hy558/papers/conceptdoppler.pdf" target="_blank" rel="external">ConceptDoppler: A Weather Tracker for Internet Censorship</a></p>
</li>
</ul>
<h3 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h3><p>GFW除了会分析上行的HTTP GET请求，对于HTTP返回的内容也会做全文关键字检查。这种检查与对请求的关键字检查不是由同一设备完成的，而且对GFW的资源消耗也更大。相关的研究论文有：</p>
<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.191.206&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Empirical Study of a National-Scale Distributed Intrusion Detection System: Backbone-Level Filtering of HTML Responses in China</a></li>
</ul>
<h3 id="HTTP代理协议"><a href="#HTTP代理协议" class="headerlink" title="HTTP代理协议"></a>HTTP代理协议</h3><p>TODO</p>
<h3 id="SOCKS4-5代理协议"><a href="#SOCKS4-5代理协议" class="headerlink" title="SOCKS4/5代理协议"></a>SOCKS4/5代理协议</h3><p>TODO</p>
<h3 id="SMTP-协议"><a href="#SMTP-协议" class="headerlink" title="SMTP 协议"></a>SMTP 协议</h3><p>因为有很多翻墙软件都是以邮件索取下载地址的方式发布的，所以GFW有针对性的封锁了SMTP协议，阻止这样的邮件往来。</p>
<p>封锁有三种表现方式（<a href="http://fqrouter.tumblr.com/post/43400982633/gfw-smtp" target="_blank" rel="external">http://fqrouter.tumblr.com/post/43400982633/gfw-smtp</a>），简单概要的说就是看邮件是不是发往上了黑名单的邮件地址的（比如xiazai@upup.info就是一个上了黑名单的邮件地址），如果发现了就立马用TCP RST包切断连接。</p>
<h3 id="电驴-ed2k-协议"><a href="#电驴-ed2k-协议" class="headerlink" title="电驴(ed2k)协议"></a>电驴(ed2k)协议</h3><p>GFW还会过滤电驴（ed2k）协议中的查询内容。因为ed2k还有一个混淆模式，会加密往来的数据包，GFW会切断所有使用混淆模式的ed2k连接，迫使客户端使用明文与服务器通讯（<a href="http://fqrouter.tumblr.com/post/43490772120/gfw-ed2k" target="_blank" rel="external">http://fqrouter.tumblr.com/post/43490772120/gfw-ed2k</a>）。然后如果客户端发起了搜索请求，查找的关键字中包含敏感词的话就会被用TCP RST包切断连接。</p>
<h3 id="对翻墙流量的分析识别"><a href="#对翻墙流量的分析识别" class="headerlink" title="对翻墙流量的分析识别"></a>对翻墙流量的分析识别</h3><p>GFW的第二个目的是封杀翻墙软件。为了达到这个目的GFW采取的手段更加暴力。原因简单，对于HTTP协议的封杀如果做不好会影响互联网的正常运作，GFW与互联网是共生的关系，它不会做威胁自己存在的事情。但是对于TOR这样的几乎纯粹是为翻墙而存在的协议，只要检测出来就是格杀勿论的了。GFW具体是如何封杀各种翻墙协议的，我也不是很清楚，事态仍然在不断更新中。但是举两个例子来证明GFW的高超技术。</p>
<p>第一个例子是GFW对TOR的自动封杀，体现了GFW尽最大努力去理解协议本身。根据这篇<a href="https://blog.torproject.org/blog/knock-knock-knockin-bridges-doors" target="_blank" rel="external">博客</a>。使用中国的IP去连接一个美国的TOR网桥，会被GFW发现。然后GFW回头（15分钟之后）会亲自假装成客户端，用TOR的协议去连接那个网桥。如果确认是TOR的网桥，则会封当时的那个端口。换了端口之后，可以用一段时间，然后又会被封。这表现出了GFW对于协议的高超检测能力，可以从国际出口的流量中敏锐地发现你连接的TOR网桥。据TOR的同志说是因为TOR协议中的握手过程具有太明显的特征了。另外一点就表现了GFW的不辞辛劳，居然会自己伪装成客户端过去连连看。</p>
<p>第二个例子表现了GFW根本不在乎加密的流量中的具体内容是不是有敏感词。只要疑似翻墙，特别是提供商业服务给多个翻墙，就会被封杀。根据这个<a href="http://www.v2ex.com/t/55531" target="_blank" rel="external">帖子</a>，使用的ShadowSocks协议。预先部署密钥，没有明显的握手过程仍然被封。据说是GFW已经升级为能够机器识别出哪些加密的流量是疑似翻墙服务的。</p>
<p>关于GFW是如何识别与封锁翻墙服务器的，最近写了一篇文章提出我的猜想，大家可以去看看：<a href="http://fqrouter.tumblr.com/post/45969604783/gfw" target="_blank" rel="external">http://fqrouter.tumblr.com/post/45969604783/gfw</a>。</p>
<p>最近发现GFW对OpenVPN和SSL证书已经可以做到准实时的封IP（端口）。原理应该是离线做的深包分析，然后提取出可疑的IP列表，经过人工确认之后封IP。因为OpenVPN有显著的协议的特征，而且基本不用于商业场景所以很容易确认是翻墙服务。但是SSL也就是HTTPS用的加密协议也能基于“证书”做过滤不得不令人感到敬畏了。Shadowsocks的作者Clowwindy为此专门撰文:<a href="https://gist.github.com/clowwindy/5947691" target="_blank" rel="external">为什么不应该用SSL翻墙</a>。</p>
<p>总结起来就是，GFW已经基本上完成了目的一的所有工作。明文的协议从HTTP到SMTP都可以分析然后关键字检测，甚至电驴这样不是那么大众的协议GFW都去搞了。从原理上来说也没有什么好研究的，就是明文，拆包，关键字。GFW显然近期的工作重心在分析网络流量上，从中识别出哪些是翻墙的流量。这方面的研究还比较少，而且一个显著的特征是自己用没关系，大规模部署就容易出问题。我目前没有在GFW是如何封翻墙工具上有太多研究，只能是道听途说了。</p>
<h1 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h1><p>GFW的应对措施是三步中最明显的，因为它最直接。GFW的重建过程和协议分析的过程需要耐心的试探才能大概推测出GFW是怎么实现的。但是GFW的应对手段我们每天都可以见到，比如连接重置。GFW的应对目前可以感受到的只有一个目的就是阻断。但是从广义上来说，应对方式应该不限于阻断。比如说记录下日志，然后做统计分析，秋后算账什么的也可以算是一种应对。就阻断方式而言，其实并不多，那么我们一个个来列举吧。</p>
<h2 id="封IP"><a href="#封IP" class="headerlink" title="封IP"></a>封IP</h2><p>一般常见于人工检测之后的应对。还没有听说有什么方式可以直接使得GFW的机器检测直接封IP。一般常见的现象是GFW机器检测，然后用TCP RST重置来应对。过了一段时间才会被封IP，而且没有明显的时间规律。所以我的推测是，全局性的封IP应该是一种需要人工介入的。注意我强调了全局性的封IP，与之相对的是部分封IP，比如只对你访问那个IP封个3分钟，但是别人还是可以访问这样的。这是一种完全不同的封锁方式，虽然现象差不多，都是ping也ping不通。要观摩的话ping twitter.com就可以了，都封了好久了。</p>
<p>其实现方式是把无效的路由黑洞加入到主干路由器的路由表中，然后让这些主干网上的路由器去帮GFW把到指定IP的包给丢弃掉。路由器的路由表是动态更新的，使用的协议是BGP协议。GFW只需要维护一个被封的IP列表，然后用BGP协议广播出去就好了。然后国内主干网上的路由器都好像变成了GFW的一份子那样，成为了帮凶。</p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-7.png" alt="learn-gfw-7"></p>
<p>如果我们使用traceroute去检查这种被全局封锁的IP就可以发现，IP包还没有到GFW所在的国际出口就已经被电信或者联通的路由器给丢弃了。这就是BGP广播的作用了。</p>
<h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><p>这也是一种常见的人工检测之后的应对。人工发现一个不和谐网站，然后就把这个网站的域名给加到劫持列表中。其原理是基于DNS与IP协议的弱点，DNS与IP这两个协议都不验证服务器的权威性，而且DNS客户端会盲目地相信第一个收到的答案。所以你去查询facebook.com的话，GFW只要在正确的答案被返回之前抢答了，然后伪装成你查询的DNS服务器向你发错误的答案就可以了。</p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-8.png" alt="learn-gfw-8"></p>
<h2 id="TCP-RST阻断"><a href="#TCP-RST阻断" class="headerlink" title="TCP RST阻断"></a>TCP RST阻断</h2><p>TCP协议规定，只要看到RST包，连接立马被中断。从浏览器里来看就是连接已经被重置。我想对于这个错误大家都不陌生。据我个人观感，这种封锁方式是GFW目前的主要应对手段。大部分的RST是条件触发的，比如URL中包含某些关键字。目前享受这种待遇的网站就多得去了，著名的有facebook。还有一些网站，会被无条件RST。也就是针对特定的IP和端口，无论包的内容就会触发RST。比较著名的例子是https的wikipedia。GFW在TCP层的应对是利用了IPv4协议的弱点，也就是只要你在网络上，就假装成任何人发包。所以GFW可以很轻易地让你相信RST确实是Google发的，而让Google相信RST是你发的。</p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-9.png" alt="learn-gfw-9"></p>
<h2 id="封端口"><a href="#封端口" class="headerlink" title="封端口"></a>封端口</h2><p>GFW除了自身主体是挂在骨干路由器旁路上的入侵检测设备，利用分光技术从这个骨干路由器抓包下来做入侵检测 (所谓 IDS)，除此之外这个路由器还会被用来封端口 (所谓 IPS)。GFW在检测到入侵之后可以不仅仅可以用TCP RST阻断当前这个连接，而且利用骨干路由器还可以对指定的IP或者端口进行从封端口到封IP，设置选择性丢包的各种封禁措施。可以理解为骨干路由器上具有了类似“iptables”的能力（网络层和传输层的实时拆包，匹配规则的能力）。这个iptables的能力在CISCO路由器上叫做ACL Based Forwarding (ABF)。而且规则的部署是全国同步的，一台路由器封了你的端口，全国的挂了GFW的骨干路由器都会封。一般这种封端口都是针对翻墙服务器的，如果检测到服务器是用SSH或者VPN等方式提供翻墙服务。GFW会在全国的出口骨干路由上部署这样的一条ACL规则，来封你这个服务器+端口的下行数据包。也就是如果包是从国外发向国内的，而且src（源ip）是被封的服务器ip，sport（源端口）是被封的端口，那么这个包就会被过滤掉。这样部署的规则的特点是，上行的数据包是可以被服务器收到的，而下行的数据包会被过滤掉。</p>
<p>如果被封端口之后服务器采取更换端口的应对措施，很快会再次被封。而且多次尝试之后会被封IP。初步推断是，封端口不是GFW的自动应对行为，而是采取黑名单加人工过滤地方式实现的。一个推断的理由就是网友报道，封端口都是发生在白天工作时间。</p>
<p>在进入了封端口阶段之后，还会有继发性的临时性封其他端口的现象，但是这些继发性的封锁具有明显的超时时间，触发了之后（触发条件不是非常明确）会立即被封锁，然后过了一段时间就自动解封。目前对于这一波封SSH/OPENVPN采用的以封端口为明显特征的封锁方式研究尚不深入。可以参考我最近写的一篇<a href="http://fqrouter.tumblr.com/post/45969604783/gfw" target="_blank" rel="external">文章</a></p>
<p><img src="/assets/images/2016-10-20-learn-gfw/learn-gfw-10.png" alt="learn-gfw-10"></p>
<h2 id="HTTPS间歇性丢包"><a href="#HTTPS间歇性丢包" class="headerlink" title="HTTPS间歇性丢包"></a>HTTPS间歇性丢包</h2><p>对于Google的HTTPS服务，GFW不愿意让其完全不能访问。所以采取的办法是对于Google的某些IP的443端口采取间歇性丢包的措施。其原理应该类似于封端口，是在骨干路由器上做的丢包动作。但是触发条件并不只是看IP和端口，加上了时间间隔这样一个条件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘自：&lt;a href=&quot;https://docs.google.com/document/d/1mmMiMYbviMxJ-DhTyIGdK7OOg581LSD1CZV4XY1OMG8/edit#heading=h.qgojh5xsppyz&quot;&gt;翻墙路由器的实现与原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：本文只供研究学习网络技术使用，请阅读者在24小时内忘记本文内容，谢绝网监请喝茶。&lt;/p&gt;
&lt;p&gt;GFW会是一个长期的存在。要学会与之共存，必须先了解GFW是什么。做为局外人，学习GFW有六个角度。渐进的来看分别是：&lt;/p&gt;
&lt;p&gt;首先我们学习到的是WHAT和WHEN。比如说，你经常听到人的议论是“昨天”，“github”被封了。其中的昨天就是WHEN，github就是WHAT。这是学习GFW的最天然，最朴素的角度。在这个方面做得非常极致的是一个叫做&lt;a href=&quot;https://en.greatfire.org/&quot;&gt;greatfire&lt;/a&gt;的网站。这个网站长期监控成千上万个网站和关键词。通过长期监控，不但可以掌握WHAT被封锁了，还可以知道WHEN被封的，WHEN被解封的。&lt;/p&gt;
    
    </summary>
    
      <category term="网络技术" scheme="http://allenn.cn/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="GFW" scheme="http://allenn.cn/tags/GFW/"/>
    
      <category term="防火墙" scheme="http://allenn.cn/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
      <category term="研究" scheme="http://allenn.cn/tags/%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>解决mac升级10.11后，出现的 xcrun: error: invalid active developer path, missing xcrun 错误</title>
    <link href="http://allenn.cn/articles/2016-09/after-update-macosx-git-failed/"/>
    <id>http://allenn.cn/articles/2016-09/after-update-macosx-git-failed/</id>
    <published>2016-09-24T05:50:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>前天把小mac升级到了10.11，结果今天在终端里使用git的时候，弹出一行莫名其妙的错误：<code>xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</code>。去google了一圈，找到了一个github上homebrew issues里很老的帖子，按着里面说的，重装了一下xcode command line，结果就正常了……</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">xcode-select --install</div></pre></td></tr></table></figure>
<p>不过看帖子里并不是所有人重装都能解决问题，有些人似乎还要手动切换下xcode的路径才能解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo xcode-select -switch /</div></pre></td></tr></table></figure>
<p>因为帖子标题说是在升级到“冲浪湾”时遇到了这问题，所以看来这问题属于每次升级时候都会碰到的月经型问题了OTL。问题解决后，我又去各处翻了下问题出现的原因，可惜没有找到。个人推断可能是因为git所需的lib关联到了command line tools，升级时改动了lib的路径所致吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天把小mac升级到了10.11，结果今天在终端里使用git的时候，弹出一行莫名其妙的错误：&lt;code&gt;xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), mi
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mac OS X" scheme="http://allenn.cn/tags/Mac-OS-X/"/>
    
      <category term="git" scheme="http://allenn.cn/tags/git/"/>
    
      <category term="升级" scheme="http://allenn.cn/tags/%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Sed 命令详解</title>
    <link href="http://allenn.cn/articles/2016-09/sed-usage/"/>
    <id>http://allenn.cn/articles/2016-09/sed-usage/</id>
    <published>2016-09-17T11:27:03.000Z</published>
    <updated>2017-04-06T16:00:05.647Z</updated>
    
    <content type="html"><![CDATA[<p>sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>
<h2 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sed [option] &apos;command&apos; input_file</div></pre></td></tr></table></figure>
<p>常用的option有如下几种：</p>
<ul>
<li><code>-n</code> 使用安静(silent)模式。默认条件下，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有在脚本中使用<code>p</code>，被匹配的行才会被列出来，比如：<code>sed -n &#39;/&lt;HTML&gt;/p&#39;</code>（仅显示<html>这一行）；</html></li>
<li><code>-e</code> 用于执行多个编辑命令，如：<code>sed -e &#39;1,3s/my/your/g&#39; -e &#39;3,$s/This/That/g&#39; my.txt</code>；</li>
<li><code>-f</code> 从 script-file 中读取 sed 编辑命令，可以将多个编辑命令写在文件中，使用<code>sed -f script-file ...</code>读取；</li>
<li><code>-r</code> 让sed命令支持扩展的正则表达式(默认是基础正则表达式)；</li>
<li><code>-i</code> 直接修改读取的文件内容，默认下，sed 不会直接修改文件，当提供<code>-i</code>选项时 sed 会直接修改文件内容。</li>
</ul>
<a id="more"></a>
<p>常用的命令有以下几种：</p>
<ul>
<li><code>a \</code>： 在匹配的行下新起一行，追加字符串，<code>a \</code>的后面跟上字符串(多行字符串可以用<code>\n</code>分隔)；</li>
<li><code>c \</code>： 取代/替换字符串，<code>c \</code>后面跟上字符串s(多行字符串可以用<code>\n</code>分隔)，会将当前选中的行替换成字符串s；</li>
<li><code>d</code>： delete即删除，该命令会将当前选中的行删除；</li>
<li><code>i \</code>： insert即插入字符串，<code>i \</code>后面跟上字符串s(多行字符串可以用\n分隔)，则会在当前选中的行的前面都插入字符串s；</li>
<li><code>p</code>： print即打印，该命令会打印当前选择的行到屏幕上，通常同<code>-n</code>一起使用，打印选中的行；</li>
<li><code>s</code>： 替换，通常s命令的用法是这样的：s/old/new/g，将old字符串替换成new字符串</li>
</ul>
<h2 id="多个匹配"><a href="#多个匹配" class="headerlink" title="多个匹配"></a>多个匹配</h2><p>有时我们需要一次进行多次匹配，可参考下面的示例：（第一个模式把第一行到第三行的my替换成your，第二个则把第3行以后的This替换成了That）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;1,3s/my/your/g; 3,$s/This/That/g&apos; my.txt</div><div class="line">This is your cat, your cat&apos;s name is betty</div><div class="line">This is your dog, your dog&apos;s name is frank</div><div class="line">That is your fish, your fish&apos;s name is george</div><div class="line">That is my goat, my goat&apos;s name is adam</div></pre></td></tr></table></figure>
<p>上面的命令等价于：（注：下面使用的是sed的-e命令行参数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sed -e &apos;1,3s/my/your/g&apos; -e &apos;3,$s/This/That/g&apos; my.txt</div></pre></td></tr></table></figure>
<p>我们可以使用&amp;来当做被匹配的变量，然后可以在基本左右加点东西。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;s/my/[&amp;]/g&apos; my.txt</div><div class="line">This is [my] cat, [my] cat&apos;s name is betty</div><div class="line">This is [my] dog, [my] dog&apos;s name is frank</div><div class="line">This is [my] fish, [my] fish&apos;s name is george</div><div class="line">This is [my] goat, [my] goat&apos;s name is adam</div></pre></td></tr></table></figure>
<h2 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h2><p>假设有一个本地文件test.txt，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat test.txt</div><div class="line"></div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this fifth line</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本节将使用该文件详细演示每一个命令的用法。</p>
<h3 id="a命令"><a href="#a命令" class="headerlink" title="a命令"></a>a命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;1a \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">add one</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例命令部分中的1表示第一行，同样的第二行写成2，第一行到第三行写成<code>1,3</code>，用<code>$</code>表示最后一行，比如<code>2,$</code>表示第二行到最后一行中间所有的行(包含第二行和最后一行)。<br>本例的作用是在第一行之后增加字符串”add one”，从输出可以看到具体效果。需要注意的是在 Mac OS X 系统上，<code>a \</code>后的追加文本需要另起一行写，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;1a \</div><div class="line">&gt;add one&apos; test.txt</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;1,$a \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">add one</div><div class="line">this is second line</div><div class="line">add one</div><div class="line">this is third line</div><div class="line">add one</div><div class="line">this is fourth line</div><div class="line">add one</div><div class="line">this is fifth line</div><div class="line">add one</div><div class="line">happy everyday</div><div class="line">add one</div><div class="line">end</div><div class="line">add one</div></pre></td></tr></table></figure>
<p>本例表示在第一行和最后一行所有的行后面都加上”add one”字符串，从输出可以看到效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;/first/a \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">add one</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例表示在包含”first”字符串的行的后面加上字符串”add one”，从输出可以看到第一行包含first，所以第一行之后增加了”add one”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;/^ha.*day$/a \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">happy everyday</div><div class="line">add one</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例使用正则表达式匹配行，<code>^ha.*day$</code>表示以ha开头，以day结尾的行，则可以匹配到文件的”happy everyday”这样，所以在该行后面增加了”add one”字符串。</p>
<h3 id="i命令"><a href="#i命令" class="headerlink" title="i命令"></a>i命令</h3><p>i命令使用方法和a命令一样的，只不过是在匹配的行的前面插入字符串，所以直接将上面a命令的示例的a替换成i即可，在此就不啰嗦了。</p>
<h3 id="c命令"><a href="#c命令" class="headerlink" title="c命令"></a>c命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;$c \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is     fifth line</div><div class="line">happy everyday</div><div class="line">add one</div></pre></td></tr></table></figure>
<p>本例表示将最后一行替换成字符串”add one”，从输出可以看到效果。同<code>a</code>命令一样在 Mac OS X 系统上，<code>c \</code>后文本需要另起一行写，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;$c \</div><div class="line">&gt;add one&apos; test.txt</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;4,$c \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">add one</div></pre></td></tr></table></figure>
<p>本例将第四行到最后一行的内容替换成字符串”add one”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;/^ha.*day$/c \replace line&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">replace line</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例将以ha开头，以day结尾的行替换成”replace line”。</p>
<h3 id="d命令"><a href="#d命令" class="headerlink" title="d命令"></a>d命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;/^ha.*day$/d&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例删除以<code>ha</code>开头，以<code>day</code>结尾的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;4,$d&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div></pre></td></tr></table></figure>
<p>本例删除第四行到最后一行中的内容。</p>
<h3 id="p命令"><a href="#p命令" class="headerlink" title="p命令"></a>p命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -n &apos;4,$p&apos; test.txt</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例在屏幕上打印第四行到最后一行的内容，p命令一般和-n选项一起使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -n &apos;/^ha.*day$/p&apos; test.txt</div><div class="line">happy everyday</div></pre></td></tr></table></figure>
<p>本例打印以<code>ha</code>开始，以<code>day</code>结尾的行。</p>
<h3 id="s命令"><a href="#s命令" class="headerlink" title="s命令"></a>s命令</h3><p>实际运用中s命令式最常使用到的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;s/line/text/g&apos; test.txt</div><div class="line">this is first text</div><div class="line">this is second text</div><div class="line">this is third text</div><div class="line">this is fourth text</div><div class="line">this is fifth text</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例将文件中的所有line替换成text，最后的<code>g</code>是global的意思，也就是全局替换，如果不加g，则只会替换本行的第一个line。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;/^ha.*day$/s/happy/very happy/g&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">very happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例首先匹配以ha开始，以day结尾的行，本例中匹配到的行是”happy everyday”这样，然后再将该行中的happy替换成very happy。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;s/\(.*\)line$/\1/g&apos; test.txt</div><div class="line">this is first</div><div class="line">this is second</div><div class="line">this is third</div><div class="line">this is fourth</div><div class="line">this is fifth</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>这个例子有点复杂，先分解一下。首先s命令的模式是s/old/new/g这样的，所以本例的old部分即<code>\(.*\)line$</code>，sed命令中使用<code>\(\)</code>包裹的内容表示正则表达式的第n部分，序号从1开始计算，本例中只有一个<code>\(\)</code>所以<code>\(.*\)</code>表示正则表达式的第一部分，这部分匹配任意字符串，所以<code>\(.*\)line$</code>匹配的就是以line结尾的任何行。然后将匹配到的行替换成正则表达式的第一部分（本例中相当于删除line部分），使用<code>\1</code>表示匹配到的第一部分，同样<code>\2</code>表示第二部分，<code>\3</code>表示第三部分，可以依次这样引用。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;s/\(.*\)is\(.*\)line/\1\2/g&apos; test.txt</div><div class="line">this  first</div><div class="line">this  second</div><div class="line">this  third</div><div class="line">this  fourth</div><div class="line">this  fifth</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>正则表达式中is两边的部分可以用<code>\1</code>和<code>\2</code>表示，该例子的作用其实就是删除中间部分的is。</p>
<h2 id="一些关于-sed-的基础知识"><a href="#一些关于-sed-的基础知识" class="headerlink" title="一些关于 sed 的基础知识"></a>一些关于 sed 的基础知识</h2><p>前面通过实例说完了 sed 的运用，下面来说一些和 sed 相关的基础知识</p>
<h3 id="Pattern-Space"><a href="#Pattern-Space" class="headerlink" title="Pattern Space"></a>Pattern Space</h3><p>什么是Pattern Space，Pattern space相当于车间sed把流内容在这里处理，你可以将pattern space看成是一个流水线，所有的动作都是在“流水线”上执行的。不理解？没关系，我们来看看 sed 的伪代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">foreach line in file &#123;</div><div class="line">    //放入把行Pattern_Space</div><div class="line">    Pattern_Space &lt;= line;</div><div class="line"></div><div class="line">    // 对每个pattern space执行sed命令</div><div class="line">    Pattern_Space &lt;= EXEC(sed_cmd, Pattern_Space);</div><div class="line"></div><div class="line">    // 如果没有指定 -n 则输出处理后的Pattern_Space</div><div class="line">    if (sed option hasn&apos;t &quot;-n&quot;)  &#123;</div><div class="line">       print Pattern_Space</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/assets/images/sed-usage/pattern-space.png" alt="sed 执行流程图"></p>
<h3 id="Hold-Space"><a href="#Hold-Space" class="headerlink" title="Hold Space"></a>Hold Space</h3><p>什么是Hold Space？Hold space相当于仓库，加工的半成品在这里临时储存。由于各种各样的原因，比如用户希望在某个条件下脚本中的某个命令被执行，或者希望模式空间得到保留以便下一次的处理，都有可能使得sed在处理文件的时候不按照正常的流程来进行。这个时候，sed设置了一些高级命令来满足用户的要求。</p>
<ul>
<li>g：[address[,address]]g 将hold space中的内容拷贝到pattern space中，原来pattern space里的内容清除</li>
<li>G：[address[,address]]G 将hold space中的内容append到pattern space后</li>
<li>h：[address[,address]]h 将pattern space中的内容拷贝到hold space中，原来的hold space里的内容被清除</li>
<li>H：[address[,address]]H 将pattern space中的内容append到hold space后</li>
<li>x： 交换pattern space和hold space的内容</li>
</ul>
<p>那么这些命令怎么用呢，我们来看些例子，示例文件如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat t.txt</div><div class="line">one</div><div class="line">two</div><div class="line">three</div></pre></td></tr></table></figure></p>
<p>如果我需要使用 sed 完成文件倒序输出要怎么做呢？你可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sed &apos;1!G;h;$!d&apos; t.txt</div></pre></td></tr></table></figure>
<p>其中的 ‘1!G;h;$!d’ 可拆解为三个命令</p>
<ul>
<li><code>1!G</code> —— 只有第一行不执行G命令，将hold space中的内容append回到pattern space</li>
<li><code>h</code> —— 第一行都执行h命令，将pattern space中的内容拷贝到hold space中</li>
<li><code>$!d</code> —— 除了最后一行不执行d命令，其它行都执行d命令，删除当前行</li>
</ul>
<p><img src="/assets/images/sed-usage/sed_demo.jpg" alt="执行序列"></p>
<h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>通过 Address 可以指定 Sed 地址/操作范围，Address 可以是一个数字，也可以是一个模式。用逗号分割两个 Address 表示匹配两个 Address 的区间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[address[,address]][!]&#123;cmd&#125;</div></pre></td></tr></table></figure>
<p>其中的!表示匹配成功后是否执行命令，Address 也可以使用相对位置，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 其中的+3表示后面连续3行</div><div class="line">$ sed &apos;/dog/,+3s/^/# /g&apos; pets.txt</div><div class="line">This is my cat</div><div class="line">  my cat&apos;s name is betty</div><div class="line"># This is my dog</div><div class="line">#   my dog&apos;s name is frank</div><div class="line"># This is my fish</div><div class="line">#   my fish&apos;s name is george</div><div class="line">This is my goat</div><div class="line">  my goat&apos;s name is adam</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。&lt;/p&gt;
&lt;h2 id=&quot;使用语法&quot;&gt;&lt;a href=&quot;#使用语法&quot; class=&quot;headerlink&quot; title=&quot;使用语法&quot;&gt;&lt;/a&gt;使用语法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sed [option] &amp;apos;command&amp;apos; input_file&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;常用的option有如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt; 使用安静(silent)模式。默认条件下，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有在脚本中使用&lt;code&gt;p&lt;/code&gt;，被匹配的行才会被列出来，比如：&lt;code&gt;sed -n &amp;#39;/&amp;lt;HTML&amp;gt;/p&amp;#39;&lt;/code&gt;（仅显示&lt;HTML&gt;这一行）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; 用于执行多个编辑命令，如：&lt;code&gt;sed -e &amp;#39;1,3s/my/your/g&amp;#39; -e &amp;#39;3,$s/This/That/g&amp;#39; my.txt&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 从 script-file 中读取 sed 编辑命令，可以将多个编辑命令写在文件中，使用&lt;code&gt;sed -f script-file ...&lt;/code&gt;读取；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 让sed命令支持扩展的正则表达式(默认是基础正则表达式)；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; 直接修改读取的文件内容，默认下，sed 不会直接修改文件，当提供&lt;code&gt;-i&lt;/code&gt;选项时 sed 会直接修改文件内容。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://allenn.cn/tags/Linux/"/>
    
      <category term="Shell" scheme="http://allenn.cn/tags/Shell/"/>
    
      <category term="sed" scheme="http://allenn.cn/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>由 Java 到 Scala：如何优雅的跳出循环</title>
    <link href="http://allenn.cn/articles/2016-09/how-to-break-loop-scala/"/>
    <id>http://allenn.cn/articles/2016-09/how-to-break-loop-scala/</id>
    <published>2016-09-16T11:27:03.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，我们经常会遇到这样的需求：循环执行某个操作，当满足一定条件的时候循环终止。最常见的场景就是累加数组中的元素，一直到大于某个值，用伪代码来描述就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DO LOOP&#123;</div><div class="line">  DO SOME THING</div><div class="line">  IF SOME CONDITION</div><div class="line">    BREAK</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果我们使用 Java 来完成这样的需求，我们会这样完成我们的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// List[1,2,3,4,5,6]</span></div><div class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i ++)&#123;</div><div class="line">  sum += list.get(i);</div><div class="line">  <span class="keyword">if</span>(sum &gt; <span class="number">4</span>)&#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Java 中，我们用一个<code>break</code>语句，就完成的从循环中跳出的工作。但在 Scala 中我们应该怎么做呢？要知道 Scala 特地没有在内置控制结构中包含 break 和 continue 是因为这两个控制结构和函数式编程有点格格不入。那么下面我将介绍几种在 Scala 中跳出循环的方法。</p>
<h3 id="使用Return语句"><a href="#使用Return语句" class="headerlink" title="使用Return语句"></a>使用Return语句</h3><p>没有<code>break</code>语句，那么作为 Java 的开发人员，第一时间就会想到<code>return</code>，还好 Scala 支持<code>return</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="comment">// List[1,2,3,4,5,6]</span></div><div class="line"><span class="keyword">var</span> sum = <span class="number">0</span></div><div class="line">list.foreach(i =&gt;&#123;</div><div class="line">  sum += i</div><div class="line">  <span class="keyword">if</span>(sum &gt; <span class="number">4</span>)&#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="使用Breaks"><a href="#使用Breaks" class="headerlink" title="使用Breaks"></a>使用Breaks</h3><p>在 Scala 2.8以上版本中，Scala 增加了<code>scala.util.control.Breaks</code>包，通过导入这个包，你可以在 Scala 中写出和 Java 中相似的带<code>break</code>语句的循环。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>._</div><div class="line"><span class="keyword">var</span> sum = <span class="number">0</span></div><div class="line">breakable &#123;</div><div class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) &#123;</div><div class="line">   sum += i</div><div class="line">   <span class="keyword">if</span> (sum &gt;= <span class="number">4</span>) <span class="keyword">break</span></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，这并不代表 Scala 从 2.8 版本开始支持<code>break</code>语句，它的实现实际是通过抛出异常给上级调用函数来达到控制循环的目的。<code>Breaks</code>的关键代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">breakable</span></span>(op: =&gt; <span class="type">Unit</span>) &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    op</div><div class="line">  &#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="keyword">case</span> ex: <span class="type">BreakControl</span> =&gt;</div><div class="line">      <span class="keyword">if</span> (ex ne breakException) <span class="keyword">throw</span> ex</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，使用<code>Breaks</code>就等价于下面的代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">AllDone</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; &#125;</div><div class="line"><span class="keyword">var</span> sum = <span class="number">0</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">6</span>) &#123; sum += i; <span class="keyword">if</span> (sum&gt;=<span class="number">4</span>) <span class="keyword">throw</span> <span class="type">AllDone</span> &#125;</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">AllDone</span> =&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="一些优雅的方法"><a href="#一些优雅的方法" class="headerlink" title="一些优雅的方法"></a>一些优雅的方法</h2><p>上面的方法虽然可以达到我们的目的，但和优雅还是差点距离，下面就回到我们的主题：如何优雅的跳出循环。</p>
<h3 id="使用-Stream"><a href="#使用-Stream" class="headerlink" title="使用 Stream"></a>使用 Stream</h3><p>Stream 是个很有意思的结构，它和列表相似，只不过它会延迟计算下一个元素，仅当需要的时候才会去计算。运用 Stream 的这个特性，我们可以用一种优雅的方式达到我们跳出循环的目的</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="number">0</span></div><div class="line">(<span class="number">0</span> to <span class="number">6</span>).toStream.takeWhile(_ =&gt; sum &lt; <span class="number">4</span>).foreach(i =&gt; sum+=i)</div></pre></td></tr></table></figure>
<p>你可能会觉得这个程序有 Bug，因为咋一看<code>takeWhile</code>中并没有进行累加，只比较了<code>sum &lt; 4</code>，而累加是在<code>foreach</code>中做的，<code>takeWhile</code>的条件应该永远为<code>true</code>，导致最后的结果是错误的。那么到底会不会这样呢？答案是：不会。因为 Stream 是 Lazy 的，它会延迟计算下一个元素，在这个例子中，<code>takeWhile(_ =&gt; sum &lt; 4)</code>只会在每次<code>foreach</code>需要取 Stream 中的一个元素出来累加的时候才会执行一次，这就保证了判断条件的有效性。大致的执行序列如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// List[1,2,3,4,5,6]</div><div class="line">var sum = 0</div><div class="line">takeWhile(_ =&gt; 0 &lt; 4)</div><div class="line">foreach(1 =&gt; 0+=1)</div><div class="line">var sum = 1</div><div class="line">takeWhile(_ =&gt; 1 &lt; 4)</div><div class="line">foreach(2 =&gt; 1+=2)</div><div class="line">....</div></pre></td></tr></table></figure>
<h3 id="使用递归代替循环"><a href="#使用递归代替循环" class="headerlink" title="使用递归代替循环"></a>使用递归代替循环</h3><p>还有一种方法就是使用递归代替循环</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="number">0</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTo</span></span>(i: <span class="type">Int</span>, max: <span class="type">Int</span>) &#123;</div><div class="line">  sum += i; <span class="keyword">if</span> (sum &lt; max) addTo(i+<span class="number">1</span>,max)</div><div class="line">&#125;</div><div class="line">addTo(<span class="number">0</span>,<span class="number">6</span>)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中，我们经常会遇到这样的需求：循环执行某个操作，当满足一定条件的时候循环终止。最常见的场景就是累加数组中的元素，一直到大于某个值，用伪代码来描述就是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;DO LOOP&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  DO SOME THING&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  IF SOME CONDITION&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    BREAK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Scala" scheme="http://allenn.cn/tags/Scala/"/>
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="跳出循环" scheme="http://allenn.cn/tags/%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>为什么java.util.concurrent 包里没有并发的ArrayList实现？</title>
    <link href="http://allenn.cn/articles/2016-09/why-not-concurrency-arraylist/"/>
    <id>http://allenn.cn/articles/2016-09/why-not-concurrency-arraylist/</id>
    <published>2016-09-07T11:27:03.000Z</published>
    <updated>2017-04-06T16:00:05.647Z</updated>
    
    <content type="html"><![CDATA[<p>问：JDK 5在 java.util.concurrent 里引入了 ConcurrentHashMap，在需要支持高并发的场景，我们可以使用它代替 HashMap。但是为什么没有 ArrayList 的并发实现呢？难道在多线程场景下我们只有 Vector 这一种线程安全的数组实现可以选择么？为什么在 java.util.concurrent 没有一个类可以代替 Vector 呢？</p>
<p>答：我认为在 java.util.concurrent 包中没有加入并发的 ArrayList 实现的主要原因是：很难去开发一个通用并且没有并发瓶颈的线程安全的 List。像 ConcurrentHashMap 这样的类的真正价值（The real point / value of classes）并不是它们保证了线程安全。而在于它们在保证线程安全的同时不存在并发瓶颈。举个例子，ConcurrentHashMap 采用了锁分段技术和弱一致性的Map迭代器去规避并发瓶颈。所以问题在于，像“Array List”这样的数据结构，你不知道如何去规避并发的瓶颈。拿contains() 这样一个操作来说，当你进行搜索的时候如何避免锁住整个 list？另一方面，Queue 和 Deque (基于Linked List)有并发的实现是因为他们的接口相比List的接口有更多的限制，这些限制使得实现并发成为可能。CopyOnWriteArrayList 是一个有趣的例子，它规避了只读操作（如 get/contains）并发的瓶颈，但是它为了做到这点，在修改操作中做了很多工作和修改可见性规则。 此外，修改操作还会锁住整个List，因此这也是一个并发瓶颈。所以从理论上来说，CopyOnWriteArrayList 并不算是一个通用的并发 List。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问：JDK 5在 java.util.concurrent 里引入了 ConcurrentHashMap，在需要支持高并发的场景，我们可以使用它代替 HashMap。但是为什么没有 ArrayList 的并发实现呢？难道在多线程场景下我们只有 Vector 这一种线程安全的
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://allenn.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://allenn.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>玩花招的PowerMock</title>
    <link href="http://allenn.cn/articles/2016-09/play-trick-with-powermock/"/>
    <id>http://allenn.cn/articles/2016-09/play-trick-with-powermock/</id>
    <published>2016-09-01T15:31:03.000Z</published>
    <updated>2017-04-06T16:00:05.647Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载至：<a href="http://agiledon.github.io/blog/2013/11/21/play-trick-with-powermock/" target="_blank" rel="external">逸言</a>，感谢原作者的精彩分享</p>
<p>当我们面对一个遗留系统时，常见的问题是没有测试。正如Michael Feathers在Working Effectively with Legacy Code一书中对“遗留代码”的定义。他将其简单归纳为“没有测试的代码”。真是太贴切了！正是因为没有测试，使得我们对遗留代码的任何重构都有些战战兢兢，甚至成为开发人员抵制重构的借口。从收益与成本的比例来看，对于这样的系统，我一贯认为不要盲目进行重构。因为重构的真正适用场景其实是发生在开发期间，而非维护期间。当然，提升自己的重构能力，尤其学会运用IDE提供的自动重构工具，可以在一定程度上保障重构的质量。然而，安全的做法，还是需要为其编写测试。</p>
<a id="more"></a>
<p>测试是分层的，即使是针对自动化测试。面对遗留系统，成本相对较低的是针对功能特性编写的功能测试（或者说是验收测试），这可以运用一些BDD框架如Cucumber、JBehave等。由于它的测试粒度较粗，可以以较少的测试用例覆盖系统的主要功能。然而，它的缺点同样存在，那就是反馈周期相对较长。这就好像你置身一个陌生的城市，在找不到路的情况下，只是跟着感觉走。走了数十公里之后，方才幡然醒悟，想起要翻一翻带在手上的地图。倘若发现方向走错，再要回转就已经晚了。反馈周期最短的自然是单元测试。同样根据Michael Feather的定义，单元测试一定要快，一定要不依赖于外部资源。单元测试的粒度自然是最小的，但不要直观地认为单元测试就是针对方法。若只是针对方法来编写单元测试，就会陷入为测试而测试的怪圈。即使是位于技术象限的单元测试，我们仍然要按照业务规则来编写。一个测试方法应该对应一个粒度最小的原子功能。</p>
<p>要让单元测试跑得快，还要不吃草（依赖外部资源），应该怎么办？答案呼之欲出，那就是Mock。Mock当然不是万能的，记得胡凯写过一篇文章，提及Mock不是银弹。我知道他仅仅是为了强调这个观点，避免太多人过于依赖Mock，因为Brooks早就发表过论断，在软件行业，其实根本就“没有银弹”。关于Mock的争论由来已久，对此，我准备避而不谈。至少在我看来，如下几点基本已成定论：</p>
<p>1、是Mock行为，而非Mock数据；如果是针对数据，则应该属于Stub的范畴；</p>
<p>2、Mock通常发生在三种情况（让我们假设被测试对象为消费者，它要协作的对象为服务，此时需要Mock服务）：服务的行为只有定义，还未实现；服务需要访问外部资源（这意味着它可能很慢，也意味着它需要依赖外部资源）；服务的行为结果不确定（例如天气服务，股票服务）。</p>
<p>自然，我们不需要自己写Mock，有许多现成的好用框架，例如Java平台下的Mockito与EasyMock，.NET平台下的Moq，以及C++下的Google Mock和MockCpp。</p>
<p>然而，问题依然存在。考虑这样两种情况：</p>
<p>1、当我们要Mock的服务，其实是Utils的静态方法时，应该怎么办？</p>
<p>2、当我们要测试的方法内部直接实例化了协作的服务对象，又该怎么办？</p>
<p>显然，这是设计和代码的坏味道，它明显违背了DIP原则，即它不应该依赖于细节，而应该依赖于抽象。换言之，它产生了对服务对象的具体依赖。若要遵循DIP，就应该在被测对象的外部来注入依赖。这种紧耦合酿成了我们设计的类不具备良好的可测试性。</p>
<p>一个蠢蠢欲动的声音在说：让我们重构吧！且住，先让我们把这苛求的眼光放柔和一点。当你视所有丑陋的代码为“蝼蚁”时，那是因为你站在了足够的高度。可是站得太高，往往摔得更惨。现在，还是脚踏实地，先设身处地地考虑这样的场景：这是一个代码行数超过1000万行的软件系统，一共有十余个开发团队，一百多名开发人员在这个团队中工作。这个系统几乎没有测试，而系统的Jar包则达到上千个。这些Utils的静态方法被数十乃至上百个类调用，牵涉到的模块也有多个甚至十余个。而且，这个系统并没有引入任何一个IoC容器。有了这样一个背景，让我们再把柔和的眼光变得锐利一点，分析分析重构的可行性。要消除前面提到的坏味道，就需要将这些静态方法修改为实例方法，并通过依赖注入的方式注入。这个变化带来的是对整个系统的全局影响，即使我们有一些自动化重构的手段，仍然不认为这种重构一定就是可行的。</p>
<p>这就是我要谈PowerMock的前提！</p>
<p>现在，轮到玩花招的PowerMock出场了。有了它，什么静态方法，方法内部实例，乃至私有方法，统统都是浮云。而且，它对Mockito与EasyMock的扩展，使得我们更容易熟悉它的语法。要使用它很简单，需先设置对它的依赖。我选择了PowerMock针对Mockito的扩展：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>powermock-api-mockito<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>powermock-module-junit4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>让我先给出如下的一份奇奇怪怪的设计，它主要是为了迎合之前提到的代码臭味。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTableUtil</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Employee&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Employee employee)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (existed(employee.getId())) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExistedEmployeeException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//insert employee</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Employee employee)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (employee == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullEmployeeException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Employee employee)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (existed(employee.getId())) &#123;</div><div class="line">            <span class="comment">//delete employee</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">existed</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRepository</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> EmployeeTableUtil tableUtil;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmployeeTableUtil().count();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> EmployeeTableUtil.findAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(Employee employee)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            tableUtil.insert(employee);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (ExistedEmployeeException e) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(Employee employee)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            EmployeeTableUtil.update(employee);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (NullEmployeeException e) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Employee employee)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> tableUtil.delete(employee);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">bonus</span><span class="params">(Employee employee)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> employee.getSalary() * <span class="number">0.1</span>d;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTableUtil</span><span class="params">(EmployeeTableUtil tableUtil)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.tableUtil = tableUtil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我要针对EmployeeRepository编写测试，它协作的服务类为EmployeTableUtil，主要承担了访问数据库的职责。在测试EmployeeRepository时，我们需要去Mock协作对象EmployeeTableUtil的行为。</p>
<p>在使用PowerMock编写测试时，首先需要在测试类上运用框架提供的Annotation：@PrepareForTest，以及一个Runner：PowerMockRunner。因为我们要Mock的对象为EmployeeTableUtil，故而测试类的定义为：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</div><div class="line"><span class="meta">@PrepareForTest</span>(EmployeeTableUtil.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRepositoryTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> EmployeeRepository repository;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        repository = <span class="keyword">new</span> EmployRepository();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我要使用PowerMock去Mock静态方法，如EmployeeTableUtil的findAll()方法，至于要测试的方法则为EmployeeRepository的findAll()方法。则编写的单元测试为：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_mock_static_method</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Employee&gt; employee = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</div><div class="line">    employee.add(<span class="keyword">new</span> Employee(<span class="string">"1"</span>));</div><div class="line">    employee.add(<span class="keyword">new</span> Employee(<span class="string">"2"</span>));</div><div class="line"></div><div class="line">    PowerMockito.mockStatic(EmployeeTableUtil.class);</div><div class="line">    when(EmployeeTableUtil.findAll()).thenReturn(employee);</div><div class="line"></div><div class="line">    List&lt;Employee&gt; employees = repository.findAll();</div><div class="line">    assertThat(employees.size(), is(<span class="number">2</span>));</div><div class="line">    assertThat(employees.get(<span class="number">0</span>).getId(), is(<span class="string">"1"</span>));</div><div class="line">    assertThat(employees.get(<span class="number">1</span>).getId(), is(<span class="string">"2"</span>));</div><div class="line"></div><div class="line">    PowerMockito.verifyStatic();</div><div class="line">    EmployeeTableUtil.findAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Mock静态方法的关键是先要调用框架定义的PowerMockito类的mockStatic()方法（针对EasyMock有相似的类）。方法接收的参数就是我们要Mock的类的类型。接下来就可以调用Mockito框架的方法，对我们要模拟的方法findAll()进行模拟，这里主要的工作是为模拟方法的返回值设置一个stub。之后就是单元测试的验证逻辑。如果需要验证被Mock的方法是否被调用，则需要调用PowerMockito.verifyStatic()方法，紧随其后的是被mock的方法。</p>
<p>如果要Mock的方法是一个命令方法（即没有返回值的方法），做法又有不同。倘若熟悉Mockito，可以看出PowerMock完全沿袭了Mockito的风格（当然，针对EasyMock的扩展则会沿袭EasyMock的风格，这是PowerMock体贴人的地方）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_mock_exception_for_command_method_in_mock_object</span><span class="params">()</span> </span>&#123;</div><div class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="string">"1"</span>);</div><div class="line"></div><div class="line">        PowerMockito.mockStatic(EmployeeTableUtil.class);</div><div class="line">        PowerMockito.doThrow(<span class="keyword">new</span> NullEmployeeException()).when(EmployeeTableUtil.class);</div><div class="line">        EmployeeTableUtil.update(employee);</div><div class="line"></div><div class="line">        assertThat(repository.update(employee), is(<span class="keyword">false</span>));</div><div class="line">    &#125;</div><div class="line">PowerMock还可以Mock私有方法，当然只能是实例的私有方法。这主要发生在当我们不希望Mock服务的公开方法时（例如，公开方法的逻辑没有Mock的必要），但这些公开方法的内部又调用了自己的私有方法，而私有方法却需要Mock。例如，EmployeeTableUtil的insert()和delete()方法调用了私有的existed()方法。假设insert()和delete()方法不需要我们Mock，此时就需要对私有方法existed()进行Mock。因为是实例方法，所以下面的测试方法通过调用setTableUtil()方法将被模拟的对象注入到EmployeeRepository对象中：</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_mock_private_method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="string">"1"</span>);</div><div class="line"></div><div class="line">        EmployeeTableUtil util = PowerMockito.spy(<span class="keyword">new</span> EmployeeTableUtil());</div><div class="line">        PowerMockito.when(util,<span class="string">"existed"</span>, anyString())</div><div class="line">                .thenReturn(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        repository.setTableUtil(util);</div><div class="line"></div><div class="line">        assertThat(repository.insert(employee), is(<span class="keyword">false</span>));</div><div class="line">        assertThat(repository.delete(employee), is(<span class="keyword">true</span>));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>PowerMock顺带还提供了测试私有方法的便捷办法（注意是测试，而不是Mock）。例如，测试EmployeeReployee类的私有方法bonus()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_test_private_method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Employee employee = <span class="keyword">new</span> Employee(<span class="string">"1"</span>);</div><div class="line">    employee.setSalary(<span class="number">8000</span>);</div><div class="line"></div><div class="line">    <span class="keyword">double</span> result = Whitebox.&lt;Double&gt;invokeMethod(repository, <span class="string">"bonus"</span>, employee);</div><div class="line">    assertThat(result, is(<span class="number">800</span>d));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后再来看看另外一种诡异的手段。假设我们要测试的方法其内部调用了协作对象的方法，而该协作对象不是在外部注入的，而是在方法中直接实例化。例如在前面例子中，EmployeeRepository的count()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRepository</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> EmployeeTableUtil tableUtil;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmployeeTableUtil().count();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要针对这样一种情形进行Mock，做法有所不同。因为它实际针对的是待测类——即这里的EmployeeRepository——执行count()方法，这就需要在count()方法内部形成一个拦截点。因此，需要在@PrepareForTest标记中指向EmployeeRepository类的类型，而非我们要Mock的EmployeeTableUtil。故而，我们需要为这个测试定义一个新的测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</div><div class="line"><span class="meta">@PrepareForTest</span>(EmployeeRepository.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructionEmployeeRepositoryTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_mock_construction_object</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        EmployeeTableUtil util = mock(EmployeeTableUtil.class);</div><div class="line">        when(util.count()).thenReturn(<span class="number">100</span>);</div><div class="line"></div><div class="line">        PowerMockito.whenNew(EmployeeTableUtil.class).withNoArguments().thenReturn(util);</div><div class="line"></div><div class="line">        EmployeeRepository repository = <span class="keyword">new</span> EmployeeRepository();</div><div class="line">        assertThat(repository.count(), is(<span class="number">100</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，测试方法的前两行代码调用的mock()与when()方法都是Mockito提供的方法，与PowerMock无关。</p>
<p>我虽然没有看过PowerMock的源代码，但我猜测，当我们在使用PowerMock去Mock静态方法时，定然是结合反射与代理的方式来完成对该方法的调用，其中必然需要初始化该类。由于是静态方法，更多的是需要静态初始化。此外，还有一种情形时，你所要测试的类声明和初始化了一个静态的字段。这些都可能需要调用静态初始化。我们在开发中就碰到一种情形是，我们希望Mock的一个类，定义了一个static块，其中又调用了私有的静态方法。在这个私有静态方法中，依赖了其他的一些对象，这些对象还牵扯到服务容器的问题。即使以静态的方式Mock了该类，仍然逃不过运行static块的命运，换言之，仍然需要依赖服务容器。这时，又可以祭出PowerMock的杀器了。它提供了@SuppressStaticInitializationFor的标注，在该标注中需要传入字符串类型的目标类型的全名。假设EmployeeTableUtil有一个static块是我们需要绕过的，它的类全名为com.agiledon.powermock.EmployeeTableUtil：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</div><div class="line"><span class="meta">@PrepareForTest</span>(EmployeeTableUtil.class)</div><div class="line"><span class="meta">@SuppressStaticInitializationFor</span>(<span class="string">"com.agiledon.powermock.EmployeeTableUtil"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRepositoryTest</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>此外，对于@PrepareForTest以及@SuppressStaticInitializationFor标记而言，如果需要针对多个类型，则需要传入一个数组，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</div><div class="line"><span class="meta">@PrepareForTest</span>(&#123;MockedObjectA.class, MockObjectB.class&#125;)</div><div class="line"><span class="meta">@SuppressStaticInitializationFor</span>(&#123;<span class="string">"com.agiledon.powermock.MockedObjectA"</span>, <span class="string">"com.agiledon.powermock.MockedObjectB"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneTest</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>或许我已经变得像祥林嫂一般的唠叨，但我还是必须再次申明，以上Mock方式所针对的情形皆为设计与代码的坏味道。优先情况下，我们应该重构，使得它遵循DIP原则，解除对服务类的耦合，使其具有良好的可测试性；而不能因为有了强大的PowerMock而“姑息养奸”。换言之，让我们仅仅将PowerMock耍弄的种种花招，看做是压箱底的手段。实在走投无路了，再祭出你的杀手锏吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载至：&lt;a href=&quot;http://agiledon.github.io/blog/2013/11/21/play-trick-with-powermock/&quot;&gt;逸言&lt;/a&gt;，感谢原作者的精彩分享&lt;/p&gt;
&lt;p&gt;当我们面对一个遗留系统时，常见的问题是没有测试。正如Michael Feathers在Working Effectively with Legacy Code一书中对“遗留代码”的定义。他将其简单归纳为“没有测试的代码”。真是太贴切了！正是因为没有测试，使得我们对遗留代码的任何重构都有些战战兢兢，甚至成为开发人员抵制重构的借口。从收益与成本的比例来看，对于这样的系统，我一贯认为不要盲目进行重构。因为重构的真正适用场景其实是发生在开发期间，而非维护期间。当然，提升自己的重构能力，尤其学会运用IDE提供的自动重构工具，可以在一定程度上保障重构的质量。然而，安全的做法，还是需要为其编写测试。&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="http://allenn.cn/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="单元测试" scheme="http://allenn.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="PowerMock" scheme="http://allenn.cn/tags/PowerMock/"/>
    
  </entry>
  
  <entry>
    <title>Allen&#39;s Blogs 创建历程（1）</title>
    <link href="http://allenn.cn/articles/2016-08/make-mine-blogs-1/"/>
    <id>http://allenn.cn/articles/2016-08/make-mine-blogs-1/</id>
    <published>2016-08-30T08:21:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>很早很早以前我就开始玩博客，陆陆续续注册了很多平台，比如博客中国、cnblogs、javeeye（现在叫iteye）、csdn，也零零散散写了一些文章，不过没有坚持多久，工作忙起来后就不再更新，自我回顾一下好像还真没有什么干货，只算是给互联网里堆了一串01010101的数据罢了。那为什么最近又动了写 Blogs 的心思，原因是最近读了一本书，书名是：<a href="http://product.china-pub.com/4971248" target="_blank" rel="external">《软技能：代码之外的生存指南》</a>，里面<em>第二篇：自我营销</em>中讲到程序员自我营销的重要性，其中一点就提到了写 Blogs。总结来说，程序员写写 Blogs 不仅是自我营销的一种方式，还是一种很好的学习方式，不是说知识能说出来才算学到了么。</p>
<a id="more"></a>
<h2 id="Jekyll-amp-GitHub-Pages"><a href="#Jekyll-amp-GitHub-Pages" class="headerlink" title="Jekyll &amp; GitHub Pages"></a>Jekyll &amp; GitHub Pages</h2><p>自我总结一下，之前没有坚持下来很大一个原因就是一个字：“懒”，再加上之前的那些 Blogs 系统多多少少会有点不足。我也曾经尝试过购买 VPS 主机，自己搭建 Blogs，我甚至还为之购买了域名，可是后来发现，为何 VPS 是何等的费时费力。要安装软件，要安装数据库，还要防止被盗链导致流量不够用，哎，都是泪，不说了。到最近，无意中看到一篇译文，似乎是<a href="http://tom.preston-werner.com/2008/11/17/blogging-like-a-hacker.html" target="_blank" rel="external">《像黑客一样写博客》</a>，瞬间就被带上车了，开始使用 Jekyll 和 GitHub Pages 架设我的静态博客。</p>
<p>要在使用 GitHub Pages 服务，首先需要创建一个名字叫 “[你的用户名].github.io” 的项目：</p>
<p><img src="/assets/images/make-mine-blogs-1/user-repo@2x.png" alt="图片来自：GitHub"></p>
<p>接着把新建好的项目 Clone 下来，有两种方式 Clone 项目，一种是点击项目右上角的绿色“Set up in desktop”按钮使用 Github 客户端 Clone 项目；另外一种就是通过终端命令行来 Clone 项目。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> [you project addr] [your locale dir]</div></pre></td></tr></table></figure>
<p>Clone 完成后，需要在本地搭建 Jekyll 的写作环境，正式开启静态博客之旅。</p>
<h3 id="Jekyll-环境准备"><a href="#Jekyll-环境准备" class="headerlink" title="Jekyll 环境准备"></a>Jekyll 环境准备</h3><p>首先安装必要工具</p>
<ul>
<li>Ruby：Mac OS X 10.5以上都自带</li>
<li>RubyGems：Mac OS X 10.5以上都自带</li>
<li>Xcode Command-Line Tools： 安装Xcode会自动安装，检查Preferences → Downloads → Components是否有Command-Line Tools这项提供下载，如果没有说明已安装</li>
<li>git：命令行输入git –version检查是否已安装，下载地址：<a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="external">http://sourceforge.net/projects/git-osx-installer/</a></li>
</ul>
<p>在国内 gem 源地址可能已经被墙（万恶的 GFW），所以你可能需要将 gem 源替换为淘宝的镜像源：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">// 移除官方镜像源</div><div class="line">$ gem sources --remove https://rubygems.org/</div><div class="line">// 添加淘宝镜像源，或者其他镜像地址</div><div class="line">$ gem sources <span class="_">-a</span> http://ruby.taobao.org/</div><div class="line">// 验证是否替换成功</div><div class="line">$ gem sources <span class="_">-l</span></div></pre></td></tr></table></figure>
<p>如果终端中出现下面的显示则代表替换成功。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">*** CURRENT SOURCES ***</div><div class="line">http://ruby.taobao.org/</div></pre></td></tr></table></figure>
<p>接着开始安装 Jekyll</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">// 更新下 gem</div><div class="line">sudo gem update --system</div></pre></td></tr></table></figure>
<p>MAC 系统版本如果是 El Capitan 使用下面这个命令。这是因为 Apple 在 OS X El Capitan 中全面启用了名为 System Integrity Protection (SIP) 的系统完整性保护技术。受此影响，大部分系统文件即使在 root 用户下也无法直接进行修改，所以需要把安装路径替换为用户有写入权限的目录。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">sudo gem update -n /usr/<span class="built_in">local</span>/bin --system</div></pre></td></tr></table></figure>
<p>如果你嫌每次都要打安装路径比较麻烦，你也可以把它变成默认配置，在用户根目录下创建一个名为<code>.gemrc</code>的文件，在里面写入<code>gem: -n/usr/local/bin</code>，并保存。或者使用下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">echo &quot;gem: -n/usr/local/bin&quot; &gt;&gt; ~/.gemrc</div></pre></td></tr></table></figure>
<p>接下来安装 Jekyll</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">$ sudo gem install jekyll</div><div class="line">// 如果提示权限错误，请使用下面的命令</div><div class="line">$ sudo gem install jekyll -n /usr/<span class="built_in">local</span>/bin</div></pre></td></tr></table></figure>
<p>OK，这样 Jekyll 环境就安装完成了，接下来导入 Jekyll 后，就可以开始写作了。在网络上有很多漂亮的 Jekyll 主题可供你选择，你可以访问<a href="http://jekyllthemes.io/" target="_blank" rel="external">jekyllthemes.io</a>找到你喜欢的主题并下载下来，或者通过 Google 搜索，如果还不满意，你也可以选择自己创建一个主题。选择好你喜欢的 Jekyll 的主题后，将主题复制到前面从 Github 上 Clone 的项目文件夹中去。一个典型的 Jekyll Blogs 的目录结构应该如下面所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml</div><div class="line">├── _drafts</div><div class="line">|   ├── begin-with-the-crazy-ideas.textile</div><div class="line">|   └── on-simplicity-in-technology.markdown</div><div class="line">├── _includes</div><div class="line">|   ├── footer.html</div><div class="line">|   └── header.html</div><div class="line">├── _layouts</div><div class="line">|   ├── default.html</div><div class="line">|   └── post.html</div><div class="line">├── _posts</div><div class="line">|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile</div><div class="line">|   └── 2009-04-26-barcamp-boston-4-roundup.textile</div><div class="line">├── _data</div><div class="line">|   └── members.yml</div><div class="line">├── _site</div><div class="line">├── .jekyll-metadata</div><div class="line">└── index.html</div></pre></td></tr></table></figure>
<p>在该目录下执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">$ jekyll server // 简写 jekyll s</div></pre></td></tr></table></figure>
<p>在浏览器地址栏中输入：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 就可以看到刚才新建的 Blog 长什么样子了。在这里新增、修改、删除文章都可以实时的看到，只需要刷新页面即可。你可以试着修改那篇默认文章看看效果。</p>
<h3 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h3><p>Jekyll 博客的配置全在 Blogs 根目录的<code>_config.yml</code>文件中，一般来说，只要没有什么特殊的需求，只需要修改诸如：博客名、所有者名字、email等信息即可，如果有更多的需求，请参考所用主题的说明和 Jekyll 的文档：<a href="https://jekyllrb.com/docs/configuration/" target="_blank" rel="external">https://jekyllrb.com/docs/configuration/</a>。我的 Blog 的基本配置如下，可以参考：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="attr">name:</span> <span class="string">Allen</span></div><div class="line"><span class="attr">description:</span> <span class="string">Blogging</span> <span class="string">about</span> <span class="string">stuffs</span></div><div class="line"><span class="attr">meta_description:</span> <span class="string">"Allen's Blog"</span></div><div class="line"></div><div class="line"><span class="attr">markdown:</span> <span class="string">krmark</span></div><div class="line"><span class="attr">redcarpet:</span></div><div class="line"></div><div class="line"><span class="attr">highlighter:</span> <span class="string">pygments</span></div><div class="line"><span class="attr">logo:</span> <span class="literal">false</span></div><div class="line"><span class="attr">paginate:</span> <span class="number">20</span></div><div class="line"><span class="attr">baseurl:</span> <span class="string">/</span></div><div class="line"><span class="attr">domain_name:</span> <span class="string">'http://allenn.cn/'</span></div><div class="line"><span class="attr">google_analytics:</span> <span class="string">'UA-XXXXXXXX-X'</span></div><div class="line"></div><div class="line"><span class="comment"># Details for the RSS feed generator</span></div><div class="line"><span class="attr">url:</span>            <span class="string">'/rss.xml'</span></div><div class="line"><span class="attr">author:</span>         <span class="string">'Allen'</span></div></pre></td></tr></table></figure>
<p>好了，一切准备就绪，我们可以开始写作了。按照 Jekyll 的规范，文章是放在<code>_posts</code>目录下的，并且需要以时间戳开头，比如：<code>2007-10-29-why-every-programmer-should-play-nethack.md</code>，在文章的开头，需要增加一些描述性的东西，这样 Jekyll 才能正确的处理我们写的文章。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">layout: post</div><div class="line">title:  &quot;在多线程构建场景下Powermockito无法在不同类中Mock同一个静态方法&quot;</div><div class="line">date:   2015-10-14 13:50:39</div><div class="line">comments: true</div><div class="line">categories: 软件技术</div><div class="line">tags: [Java, 单元测试]</div><div class="line">---</div></pre></td></tr></table></figure>
<p>写好描述后，就可以开始愉快的写正文啦，当你洋洋洒洒的写完你的大作后，你可以使用下面的命令将你的文章提交到 Github 上，完成之后过几分钟应该就能看到新的文章已经在你的个人博客主页上了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git commit -m <span class="string">'xxxxx'</span></div><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，使用 GitHub Pages + Jekyll 搭建简单的静态博客是非常容易上手的，只要有一点编程基础应该都能搞得定，而且不用像自己搭建 VPS 那样要时不时去维护主机，当然了，Jekyll 也并非完美，下篇文章我将分享我用 Jekyll 时踩到的一些坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早很早以前我就开始玩博客，陆陆续续注册了很多平台，比如博客中国、cnblogs、javeeye（现在叫iteye）、csdn，也零零散散写了一些文章，不过没有坚持多久，工作忙起来后就不再更新，自我回顾一下好像还真没有什么干货，只算是给互联网里堆了一串01010101的数据罢了。那为什么最近又动了写 Blogs 的心思，原因是最近读了一本书，书名是：&lt;a href=&quot;http://product.china-pub.com/4971248&quot;&gt;《软技能：代码之外的生存指南》&lt;/a&gt;，里面&lt;em&gt;第二篇：自我营销&lt;/em&gt;中讲到程序员自我营销的重要性，其中一点就提到了写 Blogs。总结来说，程序员写写 Blogs 不仅是自我营销的一种方式，还是一种很好的学习方式，不是说知识能说出来才算学到了么。&lt;/p&gt;
    
    </summary>
    
      <category term="随便乱写" scheme="http://allenn.cn/categories/%E9%9A%8F%E4%BE%BF%E4%B9%B1%E5%86%99/"/>
    
    
      <category term="Blogs" scheme="http://allenn.cn/tags/Blogs/"/>
    
      <category term="Jekyll" scheme="http://allenn.cn/tags/Jekyll/"/>
    
      <category term="软件工程师的自我宣传" scheme="http://allenn.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E5%AE%A3%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Github的正确使用方法</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-24-how-to-use-github/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-24-how-to-use-github/</id>
    <published>2016-08-24T08:21:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>在了解了Git的基本用法后（如果你还未了解 Git 的基本使用方法，建议你先话点时间阅读下《 Pro Git 》这本书），相信你已经开始跃跃欲试了，那么我就说下如何正确的使用 Github。下面的图描述了使用 Github 的基本流程：</p>
<p><img src="/assets/images/github-flow/github-flow.png" alt="Github Flow"></p>
<a id="more"></a>
<h3 id="第一步：Fork项目"><a href="#第一步：Fork项目" class="headerlink" title="第一步：Fork项目"></a>第一步：Fork项目</h3><p>Fork 项目其实就是在 Github 上拷贝一份他人项目的副本作为自己的项目。当你进入一个项目页面后，会在右上方看见一个<em>Fork</em>的按钮，点击它就可以 Fork 一个项目。</p>
<p><img src="/assets/images/github-flow/fork-project.jpg" alt="Fork Project"></p>
<p>需要注意的是Fork项目后，你自己的项目并不会和源项目保持自动同步，所以你需要手动进行更新，如何更新请看：<em>第五步：拉取源项目的更新</em>。</p>
<h3 id="第二步：Clone-到本地"><a href="#第二步：Clone-到本地" class="headerlink" title="第二步：Clone 到本地"></a>第二步：Clone 到本地</h3><p>Fork 项目后，我们就可以把代码 Clone 到本地以便我们修改。Github 提供两种 Clone 项目的方式，SSH/HTTPS。如果选用SSH模式，你需要先在本地生成一对SSH Key并上传到Github用于身份识别，具体请参考 Github 的帮助文档：<a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="external">Generating an SSH key</a>。如果选用HTTPS模式，在更新和提交时就要输入 Github 的用户名和密码。一般来说使用 SSH 模式，在一次配置后，就可以免输密码提交代码，比较方便，但使用 HTTPS 模式更具备通用性，所以各有利弊，随意选择~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 使用 ssh clone 项目到本地</div><div class="line">$ git clone git@github.com:rvm/rvm.git</div><div class="line"></div><div class="line"># 使用 https clone 项目到本地</div><div class="line">$ git clone https://github.com/rvm/rvm.git</div></pre></td></tr></table></figure>
<h3 id="第三步：创建分支"><a href="#第三步：创建分支" class="headerlink" title="第三步：创建分支"></a>第三步：创建分支</h3><p>每次开发新功能，都应该新建一个单独的分支（这方面可以参考<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="external">《Git分支管理策略》</a>）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 获取主干最新代码</div><div class="line">$ git checkout master</div><div class="line">$ git pull</div><div class="line"></div><div class="line"># 新建一个开发分支myfeature</div><div class="line">$ git checkout -b myfeature</div></pre></td></tr></table></figure>
<h3 id="第四步：Commit-新代码"><a href="#第四步：Commit-新代码" class="headerlink" title="第四步：Commit 新代码"></a>第四步：Commit 新代码</h3><p>分支修改后，就可以提交commit了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git add --all</div><div class="line">$ git status</div><div class="line">$ git commit --verbose</div></pre></td></tr></table></figure>
<ul>
<li>git add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。</li>
<li>git status 命令，用来查看发生变动的文件。</li>
<li>git commit 命令的verbose参数，会列出 diff 的结果。</li>
</ul>
<p>需要注意的是 Commit 代码必须给出简明扼要的提交信息，下面是一个范本，第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Present-tense summary under 50 characters</div><div class="line"></div><div class="line">* More information about commit (under 72 characters).</div><div class="line">* More information about commit (under 72 characters).</div><div class="line"></div><div class="line">http://project.management-system.com/ticket/123</div></pre></td></tr></table></figure>
<h3 id="第五步：拉取源项目的更新"><a href="#第五步：拉取源项目的更新" class="headerlink" title="第五步：拉取源项目的更新"></a>第五步：拉取源项目的更新</h3><p>当我们在修改代码的时候，源项目肯定也会发生变化，所以在我们向源项目推送代码之前，需要先将源项目的代码更新拉取下来。</p>
<p>先查看我们的 Remote 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git remote -v</div><div class="line">origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)</div><div class="line">origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)</div></pre></td></tr></table></figure>
<p>将源项目添加为 upstream</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</div></pre></td></tr></table></figure>
<p>检查配置是否生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git remote -v</div><div class="line">origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)</div><div class="line">origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)</div><div class="line">upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)</div><div class="line">upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)</div></pre></td></tr></table></figure>
<p>拉取源项目的变更</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git fetch upstream</div><div class="line">remote: Counting objects: 75, done.</div><div class="line">remote: Compressing objects: 100% (53/53), done.</div><div class="line">remote: Total 62 (delta 27), reused 44 (delta 9)</div><div class="line">Unpacking objects: 100% (62/62), done.</div><div class="line">From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY</div><div class="line"> * [new branch]      master     -&gt; upstream/master</div></pre></td></tr></table></figure>
<p>切换到 master 分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git checkout master</div></pre></td></tr></table></figure>
<p>将源项目的修改合并到本地 master 分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git merge upstream/master</div></pre></td></tr></table></figure>
<h3 id="第六步：Rebase-本地分支并解决冲突"><a href="#第六步：Rebase-本地分支并解决冲突" class="headerlink" title="第六步：Rebase 本地分支并解决冲突"></a>第六步：Rebase 本地分支并解决冲突</h3><p>接着我们切换到之前的开发分支 myfeature，并同 master 分支进行同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git checkout myfeature</div><div class="line">$ git rebase master</div></pre></td></tr></table></figure>
<p>有时我们会和主干发生冲突，那么我们需要在本地把所有冲突解决掉后才能继续合入代码。如何解决冲突，请阅：<a href="https://help.github.com/articles/resolving-a-merge-conflict-from-the-command-line/" target="_blank" rel="external">Resolving a merge conflict from the command line</a></p>
<h3 id="第七步：Push到Github"><a href="#第七步：Push到Github" class="headerlink" title="第七步：Push到Github"></a>第七步：Push到Github</h3><p>同步好本地分支后，我们就可以将代码推送到Github了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git push -u origin myfeature</div></pre></td></tr></table></figure>
<h3 id="第八步：发送Pull-Request"><a href="#第八步：发送Pull-Request" class="headerlink" title="第八步：发送Pull Request"></a>第八步：发送Pull Request</h3><p>点击项目页面上方的pull request按钮</p>
<p><img src="/assets/images/github-flow/create-pull-request-1.jpg" alt="pull request button"></p>
<p>我们自己的项目选择之前的开发分支，源项目选择 master 分支</p>
<p><img src="/assets/images/github-flow/create-pull-request-2.png" alt="pull request"></p>
<p>在下面的页面上填写上描述，然后点击发送即可，接着下来就是原作者的事儿了，如果他同意合入我们会在项目的 master 分支看到我们刚刚贡献的代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解了Git的基本用法后（如果你还未了解 Git 的基本使用方法，建议你先话点时间阅读下《 Pro Git 》这本书），相信你已经开始跃跃欲试了，那么我就说下如何正确的使用 Github。下面的图描述了使用 Github 的基本流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/github-flow/github-flow.png&quot; alt=&quot;Github Flow&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Git" scheme="http://allenn.cn/tags/Git/"/>
    
      <category term="Github" scheme="http://allenn.cn/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>在公司内网如何更新IntelliJ的插件</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-19-resolve-java-app-ssl-error/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-19-resolve-java-app-ssl-error/</id>
    <published>2016-08-19T14:21:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>最近小伙伴们更新IntelliJ后，发现没法安装或者更新插件了，每次尝试在线安装时总会提示SSL错误。特别是要玩Scala的小伙伴更是抓狂，因为本身IntelliJ并不自带Scala的支持，需要下载Scala插件。不得以，只能通过手动下载，但是这样就不能享受插件更新的新功能了，很是不爽。那么报SSL错误的原因是什么呢？其实是因为IntelliJ更新插件时使用了Https连接，在连接时，客户端和服务器是要相互校验证书的，一般来说，只要证书正确，客户端是可以和服务器正常交互的。但是，我们是在公司内网，用的是公司的Proxy连接外网。公司的代理服务器会将证书换成公司自己颁(wei)发(zao)的证书（满满的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="external">中间人攻击</a>的即视感，公司这样做是要干嘛？你懂的。。。），这时IntelliJ就无法同插件服务器正常通信了，那么怎么解决这个问题呢？那就是导入公司代理服务器的根证书，把公司颁(wei)发(zao)的证书变成可信任的证书。</p>
<a id="more"></a>
<p>OK, Let’s do it! 首先导出公司代理服务器的根证书，用浏览器即可，随便访问应该https的外网网站，点击地址栏上的小锁头。</p>
<p><img src="/assets/images/java-ssl-error/ie_url_bar-certificate-error.png" alt="ie_url_bar"></p>
<p>打开的窗口中,点击下一步即可,</p>
<p><img src="/assets/images/java-ssl-error/export_cert_1.png" alt="证书详细信息"></p>
<p>在正式编码格式中,选择指定的格式,点击下一步;</p>
<p><img src="/assets/images/java-ssl-error/export_cert_2.png" alt="证书导出向导"></p>
<p>指定生成证书文件的名称(此处为vbooking.cer)</p>
<p><img src="/assets/images/java-ssl-error/export_cert_3.png" alt="vbooking.cer"></p>
<p>接着，将证书导入java的cacerts证书库，切换到目录 ${JAVA_HOME}/jre/lib/security, 执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">keytool -import -alias vbooking -keystore cacerts -file $&#123;cert_file_path&#125;</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>-alias 指定别名(推荐和证书同名)</li>
<li>-keystore 指定存储文件(此处固定)</li>
<li>-file 指定证书文件全路径(证书文件所在的目录)</li>
</ul>
<p>此时命令行会提示你输入cacerts证书库的密码,敲入changeit即可,这是java中cacerts证书库的默认密码,当然也可自行修改。</p>
<p>最后，在系统中新建一个环境变量，IDEA_JDK（64位程序为IDEA_JDK_64），指向刚才导入根证书的JDK，不然IntelliJ会使用内置的JDK（详细见<a href="https://intellij-support.jetbrains.com/hc/en-us/articles/206544879-Selecting-the-JDK-version-the-IDE-will-run-under" target="_blank" rel="external">这里</a>），重启IntelliJ后即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近小伙伴们更新IntelliJ后，发现没法安装或者更新插件了，每次尝试在线安装时总会提示SSL错误。特别是要玩Scala的小伙伴更是抓狂，因为本身IntelliJ并不自带Scala的支持，需要下载Scala插件。不得以，只能通过手动下载，但是这样就不能享受插件更新的新功能了，很是不爽。那么报SSL错误的原因是什么呢？其实是因为IntelliJ更新插件时使用了Https连接，在连接时，客户端和服务器是要相互校验证书的，一般来说，只要证书正确，客户端是可以和服务器正常交互的。但是，我们是在公司内网，用的是公司的Proxy连接外网。公司的代理服务器会将证书换成公司自己颁(wei)发(zao)的证书（满满的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB&quot;&gt;中间人攻击&lt;/a&gt;的即视感，公司这样做是要干嘛？你懂的。。。），这时IntelliJ就无法同插件服务器正常通信了，那么怎么解决这个问题呢？那就是导入公司代理服务器的根证书，把公司颁(wei)发(zao)的证书变成可信任的证书。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="IntelliJ" scheme="http://allenn.cn/tags/IntelliJ/"/>
    
      <category term="ssl" scheme="http://allenn.cn/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>Java核心API需要掌握的程度</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-14-java-api-need-to-know/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-14-java-api-need-to-know/</id>
    <published>2016-08-14T15:21:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>最近总结，发现自己没啥提升，准备开始练级，记下这个，给自己一个目标。Java的核心API是非常庞大的,这给开发者来说带来了很大的方便，经常人有评论,java让程序员变傻。但是一些内容我认为是必须掌握的，否则不可以熟练运用java，也不会使用就很难办了。</p>
<ol>
<li>java.lang包下的80％以上的类的功能的灵活运用。</li>
<li>java.util包下的80％以上的类的灵活运用，特别是集合类体系、正规表达式、时间、属性、和Timer.</li>
<li>java.io包下的60％以上的类的使用，理解IO体系的基于管道模型的设计思路以及常用IO类的特性和使用场合。</li>
<li>java.math包下的100％的内容。</li>
<li>java.net包下的60％以上的内容，对各个类的功能比较熟悉。</li>
<li>java.text包下的60％以上的内容，特别是各种格式化类。</li>
<li>熟练运用JDBC.</li>
<li>java.security包下40％以上的内容，如果对于安全没有接触的话根本就不可能掌握java.</li>
<li>AWT的基本内容，包括各种组件事件、监听器、布局管理器、常用组件、打印。</li>
<li>Swing的基本内容，和AWT的要求类似。</li>
<li>XML处理，熟悉SAX、DOM以及JDOM的优缺点并且能够使用其中的一种完成XML的解析及内容处理。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近总结，发现自己没啥提升，准备开始练级，记下这个，给自己一个目标。Java的核心API是非常庞大的,这给开发者来说带来了很大的方便，经常人有评论,java让程序员变傻。但是一些内容我认为是必须掌握的，否则不可以熟练运用java，也不会使用就很难办了。&lt;/p&gt;
&lt;ol&gt;
&lt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="api" scheme="http://allenn.cn/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>25分钟改变你的工作效率：番茄工作法</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-12-intro-pomodoro-technique/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-12-intro-pomodoro-technique/</id>
    <published>2016-08-12T08:50:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>少年，你是不是每5分钟就会拿起一次手机？你是不是每天忙忙碌碌但最后好像什么也没干？你是不是日复一日的加班感觉身体被掏空？</p>
<p><img src="/assets/images/intro-pomodoro-technique/time-lack.png" alt="我真的很缺时间"></p>
<p>那么，你想变得更专注么？你想变得更有效率么？你想每天下班按时回家么？那么来试试这个番茄工作法吧！</p>
<a id="more"></a>
<p>番茄工作法？也许很多人对它还比较陌生，包括我，我也是在阅读了《软技能－代码之外的生存指南》（这是一本好书，推荐所有人阅读）后才了解到它。那么什么是番茄工作法呢？</p>
<blockquote>
<p>番茄工作法（英语：Pomodoro Technique）是一种时间管理法方法，在上世纪八十年代由Francesco Cirillo创立。该方法使用一个定时器来分割出一个一般为25分钟的工作时间和5分钟的休息时间，而那些时间段被称为pomodori，为意大利语单词 pomodoro（中文：番茄）之复数。以上来自<a href="https://zh.wikipedia.org/wiki/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95" target="_blank" rel="external">维基百科：番茄工作法</a></p>
</blockquote>
<p>简单来说就是把工作时间划分为一小节一小节的，每小节30分钟，其中包含了25分钟的工作时间和5分钟的休息时间。是不是很简单？</p>
<p>OK，那让我们来实践一下，请选择一件你觉得在25分钟内能完成的工作，在这25分钟的工作时间中，请把Email关掉，手机调整成静音，打好茶水。然后把手机的定时器打开，设置25分钟的倒计时，然后开始工作。</p>
<p><img src="/assets/images/intro-pomodoro-technique/25mins-get-it-done.png" alt="打开你的定时器"></p>
<p>OK,Time up，现在感觉怎么样？是不是找回了专注的感觉？<em>一次只专注做好一件事情</em>，这就是番茄工作法的精髓所在。我们都知道工作情境的切换特别耗费人的精力，你也许会有过这样的体验，当你在酝酿某种思路时，突然一个电话，你之前在大脑里构建的宏伟建筑顷刻就能灰飞烟灭。你只有一双脚，不能同时跳两场舞。</p>
<p><img src="/assets/images/intro-pomodoro-technique/two-dance.gif" alt="打开你的定时器"></p>
<h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><p>「番茄工作法」的使用主流程如下：</p>
<ol>
<li>每天早上到公司后，首先拿一张纸（或者是本子中的一页），用笔写下当天应该要做完的事情。</li>
<li>将这些事情按优先级排序，然后进行大致的估算后，拆分成若干个「番茄钟」，每个「番茄钟」是 25 分钟。</li>
<li>设置「番茄钟」倒计时，同时开始第一件事情的第一个「番茄钟」。</li>
<li>在「番茄钟」倒计时期间，集中精力只做事先安排好的事情。</li>
<li>在「番茄钟」结束后，休息 5 分钟，走动放松一下，然后继续下一个「番茄钟」，直到完成自己的任务。</li>
<li>每完成 4 个「番茄钟」（即 2 小时），休息 15-30 分钟。</li>
<li>每天回顾「番茄钟」完成的情况，回顾一下自己被打断的原因，看看哪些打断可以避免。</li>
</ol>
<p>在实际工作中你总会遇到一些疑问情况，因为你不是与世隔绝的，你是在一个团队中工作。番茄工作法也没有要求你做到与世隔绝，完全“两耳不闻窗外事”。那么如何处理这种“突发状况”呢：</p>
<ol>
<li>如果你被电话、交谈打断，这个「番茄钟」即宣告失败，可以简单休息 5 分钟，然后重启「番茄钟」。</li>
<li>如果你突然想到一件重要的事情，除非当前非做不可，否则应该在纸上将此事快速记录下来，然后继续你的「番茄钟」。</li>
</ol>
<p>下面用一张图来说明整个番茄工作法的流程，这张图来自<a href="https://www.amazon.cn/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E5%9B%BE%E8%A7%A3-%E7%AE%80%E5%8D%95%E6%98%93%E8%A1%8C%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95-%E8%AF%BA%E7%89%B9%E4%BC%AF%E6%A0%BC/dp/B004O9F71K" target="_blank" rel="external">《番茄工作法图解-简单易行的时间管理方法》</a>：</p>
<p><img src="/assets/images/intro-pomodoro-technique/overview.png" alt="工作流程"></p>
<h2 id="技巧和心得"><a href="#技巧和心得" class="headerlink" title="技巧和心得"></a>技巧和心得</h2><p>OK，上面说了那么多，相信你对番茄工作法已经有一定的了解了，那为什么我要推荐给你，因为我用了以后觉得好，就像成龙大哥说的那样：我用完之后是这样子，你们用完之后，也是这样子！</p>
<p><img src="/assets/images/intro-pomodoro-technique/duang.png" alt="duang"></p>
<ol>
<li>在进行「番茄钟」时，我们应该尽量想办法避开一些容易分神的信息源。例如：将手机的消息推送静音，关闭 QQ 和微信。相信我，你大多数时候并不需要立即响应聊天软件中的信息。使用「番茄钟」后，你的消息回复时间最坏情况下也就是晚 25 分钟。如果真的有人有急事，他会直接到你的办公桌来找你，或者直接给你打电话的。</li>
<li>刚开始的时候我建议你把「番茄钟」设定在25分钟，随着你的注意力控制越来越容易，你可以适当延长「番茄钟」的时间。就我的经验，延长到 45 - 50 分钟是完全没有问题的。其实你如果明白了「番茄钟」的原理，你甚至可以在心中假想一个「番茄钟」，然后让自己快速进入精力集中状态。</li>
<li>一天下来，回顾自己当天的「番茄钟」完成情况，看看主要的问题在于自己的精力无法集中，还是老是被别人打断。针对具体的问题可以做一些调整的尝试。比如，如果是精力无法集中，则看看是否是干扰源过多，尽量减少干扰。如果是老被打断，则可以和同事商量一些工作方式，比如让同事尽量用邮件和 QQ 找你，而不是当面打扰你。</li>
<li>我使用了一个内置番茄计时器的看板程序来追踪我每天的工作情况，<a href="https://kanbanflow.com" target="_blank" rel="external">Kanbanflow</a>，我每天会在开完早会后花一个番茄钟的时间来安排我一天的任务，并用它来作为我的「番茄钟」计时器。它还能输出一个报告，告诉你每天完成了多少个「番茄钟」，被打断了多少次，被打断的原因又是什么。我觉得不错，你可以去试试。</li>
</ol>
<p><img src="/assets/images/intro-pomodoro-technique/KanbanFlowBoard.png" alt="KanbanFlowBoard"></p>
<p>最后我想说的是，我们应该认识到，工作被打断是在所难免的，总会有一些临时的沟通工作无法被计划，并且是有价值的。所以，「番茄钟」失败后，不应该有过多的情绪，尽快重启一个「番茄钟」，你的工作应该很快就会进入状态。Try it，相信你也会有很大的收获。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;少年，你是不是每5分钟就会拿起一次手机？你是不是每天忙忙碌碌但最后好像什么也没干？你是不是日复一日的加班感觉身体被掏空？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/intro-pomodoro-technique/time-lack.png&quot; alt=&quot;我真的很缺时间&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么，你想变得更专注么？你想变得更有效率么？你想每天下班按时回家么？那么来试试这个番茄工作法吧！&lt;/p&gt;
    
    </summary>
    
      <category term="工作方法" scheme="http://allenn.cn/categories/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>CompletionService小技巧</title>
    <link href="http://allenn.cn/articles/2016-08/2016-08-10-java-CompletionService-tips/"/>
    <id>http://allenn.cn/articles/2016-08/2016-08-10-java-CompletionService-tips/</id>
    <published>2016-08-10T08:50:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇blogs中，我详细的解释了<code>CompletionService</code>的使用方法和<code>ExecutorCompletionService</code>的详细实现，这篇blogs中，我就介绍使用它的一个小技巧，算是对上一篇blogs的一个补完。在开始之前我们先回顾一下它的实现。</p>
<a id="more"></a>
<p>首先，在初始化<code>ExecutorCompletionService</code>的时候我们需要传入一个<code>Executor</code>，作为<code>ExecutorCompletionService</code>执行任务的容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor)</span> </span>&#123;</div><div class="line">    [......]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor,</span></span></div><div class="line">                                 BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) &#123;</div><div class="line">    [......]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，调用<code>submit</code>方法，向它提交任务。<code>submit</code>方法会将我们提交的任务包装成一个<code>QueueingFuture</code>并提交给<code>Executor</code>来执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </div><div class="line">    RunnableFuture&lt;V&gt; f = newTaskFor(task);  </div><div class="line">    executor.execute(<span class="keyword">new</span> QueueingFuture(f));  </div><div class="line">    <span class="keyword">return</span> f;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着，<code>QueueingFuture</code>会在任务执行完成后把执行结果放到队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</div><div class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</div><div class="line">        <span class="keyword">super</span>(task, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">this</span>.task = task;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(task); &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们通过<code>take</code>或者<code>poll</code>方法就能拿到任务执行的结果。</p>
<p>下面让我们设想一个场景，我需要从网络上下载几张图片和视频并最后把它们渲染到页面上去，由于下载图片和视频都比较耗时，所以我希望能以多线程的形式进行下载。但是由于资源有限，下载的并发度不能太大，所以需要限制线程池的并发线程大小。但如果将可用线程数平均分给下载图片和下载视频的线程池，当某线程池的所有任务执行完成后，另外一个线程池也无法获取到它所释放的资源。那怎么办呢？我们可以创建一个统一的线程池，然后把两个CompletionService绑定上去，让CompletionService作为一个句柄来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="keyword">final</span> ExecutorCompletionService&lt;Image&gt; imageCompletionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(pool);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">final</span> String site : imageSites) &#123;</div><div class="line">    completionService.submit(<span class="keyword">new</span> Callable&lt;Image&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> IOUtils.toString(<span class="keyword">new</span> URL(<span class="string">"http://"</span> + site), StandardCharsets.UTF_8);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> ExecutorCompletionService&lt;Video&gt; vidoeCompletionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(pool);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">final</span> String site : videoSites) &#123;</div><div class="line">    completionService.submit(<span class="keyword">new</span> Callable&lt;Video&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> IOUtils.toString(<span class="keyword">new</span> URL(<span class="string">"http://"</span> + site), StandardCharsets.UTF_8);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">List&lt;Image&gt; images = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; topSites.size(); ++i) &#123;</div><div class="line">    <span class="keyword">final</span> Future&lt;String&gt; future = completionService.take();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        images.add(future.get());</div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">        log.warn(<span class="string">"Error while downloading"</span>, e.getCause());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">List&lt;Video&gt; videos = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; topSites.size(); ++i) &#123;</div><div class="line">    <span class="keyword">final</span> Future&lt;String&gt; future = completionService.take();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        videos.add(future.get());</div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">        log.warn(<span class="string">"Error while downloading"</span>, e.getCause());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ... do process content</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇blogs中，我详细的解释了&lt;code&gt;CompletionService&lt;/code&gt;的使用方法和&lt;code&gt;ExecutorCompletionService&lt;/code&gt;的详细实现，这篇blogs中，我就介绍使用它的一个小技巧，算是对上一篇blogs的一个补完。在开始之前我们先回顾一下它的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://allenn.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何在单元测试中设置系统环境变量</title>
    <link href="http://allenn.cn/articles/2015-10/how-to-set-property-in-unit-test/"/>
    <id>http://allenn.cn/articles/2015-10/how-to-set-property-in-unit-test/</id>
    <published>2015-10-17T05:50:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们需要通过读取系统环境变量来获取一些有用的信息，比如系统路径、临时目录等。在系统真正运行的时候我们可以通过启动命令行，如：java -Dxxx.xxx=xxxx …，或者使用System.setProperty(“xxx.xxx”, “xxx.xxx”)来设置系统环境变量。但在单元测试时如何设置这些系统环境变量又成了一个让人头疼的问题。有些小伙伴是在setUp方法里设置，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Before</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> LicenseException</span></div><div class="line">&#123;</div><div class="line">    PowerMockito.mockStatic(XXXSystem.class);</div><div class="line">    System.setProperty(<span class="string">"xxx.xxx"</span>, <span class="string">"xxx.xxx"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是我们很快就会发现，这种设置方法在只有一个测试用例的时候是OK的，当你的测试类里有多个@Test标签时，就会发生一些很奇怪的问题。比如某些用例读到了环境变量，有些却没有读取到。主要的原因是System.setProperty(“xxx.xxx”, “xxx.xxx”);方法是会作用在整个JVM上的，而多个测试用例是会在同一个JVM上面运行的，而JUnit的@Before标签标示的方法又会在每个测试用例启动前运行，这样就会导致环境变量相互覆盖。特别是开启并发执行单元测试功能时，这种现象更加严重。那么如何设置环境变量才是安全的呢？首先，我们要抛弃在setUp方法里设置环境变量的做法，然后在POM文件中做如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 单元测试时，系统参数iemp.home的路径--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">test.home</span>&gt;</span>$&#123;project.build.directory&#125;/opt/server<span class="tag">&lt;/<span class="name">test.home</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">        ....</div><div class="line">        <span class="tag">&lt;<span class="name">systemPropertyVariables</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">home</span>&gt;</span>$&#123;test.home&#125;<span class="tag">&lt;/<span class="name">home</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">systemPropertyVariables</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样我们就可以很轻松的在单元测试中读取系统环境变量了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时我们需要通过读取系统环境变量来获取一些有用的信息，比如系统路径、临时目录等。在系统真正运行的时候我们可以通过启动命令行，如：java -Dxxx.xxx=xxxx …，或者使用System.setProperty(“xxx.xxx”, “xxx.xxx”)来设置系统环境变量。但在单元测试时如何设置这些系统环境变量又成了一个让人头疼的问题。有些小伙伴是在setUp方法里设置，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Before&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setUp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; LicenseException&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    PowerMockito.mockStatic(XXXSystem.class);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;xxx.xxx&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;xxx.xxx&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="单元测试" scheme="http://allenn.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Mock 与 Stub</title>
    <link href="http://allenn.cn/articles/2015-10/2015-10-14-unit-test-mock/"/>
    <id>http://allenn.cn/articles/2015-10/2015-10-14-unit-test-mock/</id>
    <published>2015-10-14T08:50:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在进行单元测试的时候，我们会发现我们要测试的方法会有很多外部依赖，比如：发邮件，进行网络通讯，操作文件系统等等。而我们通常关注的是被测试对象的功能和行为，对于它的依赖，我们仅仅需要关注它们之间的交互，但对依赖的对象是如何执行的具体细节我们并不关注。较为常见的技巧就是使用mock对象或者stub对象来代替真实的依赖。</p>
</blockquote>
<h2 id="Mocks-aren’t-stubs"><a href="#Mocks-aren’t-stubs" class="headerlink" title="Mocks aren’t stubs"></a>Mocks aren’t stubs</h2><p>这是软件大师<a href="http://martinfowler.com/" target="_blank" rel="external">Martin Fowler</a>的一篇经典博文。Martin大师在文章中详细的解释了Mock与Stub的区别，以及怎样使用它们进行TDD实践等等一系列干货，强烈推荐阅读，猛击<a href="http://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="external">这里</a>阅读原文。我无意把大师的话再复述一遍，所以在本文中我就聊聊我对Mock与Stub的理解以及一些实践。</p>
<a id="more"></a>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>先看看两者的相同点吧，非常明确的是，Mock和Stub都可以用来对系统(或者将粒度放小为模块，单元)进行隔离。先看看两者的相同点吧，非常明确的是，Mock和Stub都可以用来对系统(或者将粒度放小为模块，单元)进行隔离。</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>Mock和Stub有两个主要区别：</p>
<ol>
<li>校验测试结果的方式不同，Mock倾向于校验行为（Beahavior verification），Stub倾向于校验状态；</li>
<li>Mock和Stub也代表了两种将测试与设计结合在一起的理念。</li>
</ol>
<p>上面的说法比较抽象，让我们通过例子来看看Mock与Stub的区别。</p>
<h2 id="使用Stub进行单元测试"><a href="#使用Stub进行单元测试" class="headerlink" title="使用Stub进行单元测试"></a>使用Stub进行单元测试</h2><p>下面是一个使用Stub进行单元测试的例子，我们打算创建一个订单对象，并用仓库中的货物填充这个订单。这个订单对象很简单，只有产品和数量两种信息，仓库保存着不同产品的目录。当我们需要填充订单的时候，会有两种不同的回应，如果仓库中有足够的货物，那么订单就会被填满，并且仓库相应产品的数量就会降低到对应的数量。如果仓库中没有足够的参评，那么订单就不会被填充，并且仓库中产品的数量没有任何的变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStateTester</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TALISKER = <span class="string">"Talisker"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String HIGHLAND_PARK = <span class="string">"Highland Park"</span>;</div><div class="line">    <span class="keyword">private</span> WareHouse warehouse = <span class="keyword">new</span> WareHouseImpl();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        warehouse.add(TALISKER , <span class="number">50</span>);</div><div class="line">        warehouse.add(HIGHLAND_PARK , <span class="number">25</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrderIsFilledIfEnoughInWarehouse</span><span class="params">()</span></span>&#123;</div><div class="line">        Order order = <span class="keyword">new</span> Order(TALISKER , <span class="number">50</span>);</div><div class="line">        order.fill(warehouse);</div><div class="line">        assertTrue(order.isFilled());</div><div class="line">        assertEquals(<span class="number">0</span> , warehouse.getInventory(TALISKER));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrderDoseNotRemoveIfNotEnough</span><span class="params">()</span> </span>&#123;</div><div class="line">        Order order = <span class="keyword">new</span> Order(TALISKER , <span class="number">51</span>);</div><div class="line">        order.fill(warehouse);</div><div class="line">        assertFalse(order.isFilled());</div><div class="line">        assertEquals(<span class="number">50</span> , warehouse.getInventory(TALISKER));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子里，我们需要对Order对象进行测试，为了验证Order.fill方法，我们还需要WareHouse对象。但真正的WareHouse对象内部可能有很复杂的实现，比如读取文件，访问数据库，持有同步锁以维持对象在并发访问时内部数据正确等。实际上在单元测试时我们并不需要去和这些代码发生交互，而且这些复杂的代码还会让我们的单元测试很不稳定。数据库连接失败、必须的配置文件读取失败等都会导致我们的单元测试失败。显然我们并不希望这些外部的因素影响我们的单元测试</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在进行单元测试的时候，我们会发现我们要测试的方法会有很多外部依赖，比如：发邮件，进行网络通讯，操作文件系统等等。而我们通常关注的是被测试对象的功能和行为，对于它的依赖，我们仅仅需要关注它们之间的交互，但对依赖的对象是如何执行的具体细节我们并不关注。较为常见的技巧就是使用mock对象或者stub对象来代替真实的依赖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Mocks-aren’t-stubs&quot;&gt;&lt;a href=&quot;#Mocks-aren’t-stubs&quot; class=&quot;headerlink&quot; title=&quot;Mocks aren’t stubs&quot;&gt;&lt;/a&gt;Mocks aren’t stubs&lt;/h2&gt;&lt;p&gt;这是软件大师&lt;a href=&quot;http://martinfowler.com/&quot;&gt;Martin Fowler&lt;/a&gt;的一篇经典博文。Martin大师在文章中详细的解释了Mock与Stub的区别，以及怎样使用它们进行TDD实践等等一系列干货，强烈推荐阅读，猛击&lt;a href=&quot;http://martinfowler.com/articles/mocksArentStubs.html&quot;&gt;这里&lt;/a&gt;阅读原文。我无意把大师的话再复述一遍，所以在本文中我就聊聊我对Mock与Stub的理解以及一些实践。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="单元测试" scheme="http://allenn.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>在多线程构建场景下Powermockito无法在不同类中Mock同一个静态方法</title>
    <link href="http://allenn.cn/articles/2015-10/2015-10-14-powermockito-would-not-work-on-multi-thread/"/>
    <id>http://allenn.cn/articles/2015-10/2015-10-14-powermockito-would-not-work-on-multi-thread/</id>
    <published>2015-10-14T05:50:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>在修改单元测试的过程中，不幸踩了个坑，发现 Powermockito 的PowerMock.mockStatic(ClassThatContainsStaticMethod.class) 在多线程场景下是无法正常工作的，这再次验证了之前 ThrougthWorks 顾问说的那句话：</p>
<blockquote>
<p>除非万不得已，或者是Mock遗留系统接口，否则不要使用Powermockito。</p>
</blockquote>
<a id="more"></a>
<p>发生问题的场景是这样的 Class C 有一个静态方法，Class A 和 Class B 都需要调用这个方法完成一些功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Class C&#123;</div><div class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SomeObject <span class="title">getSomeObject</span><span class="params">()</span></span>&#123;</div><div class="line">truetrue[....]</div><div class="line">true&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class A &#123;</div><div class="line">true<span class="keyword">private</span> SomeObject someObject = C.getSomeObject();</div><div class="line"></div><div class="line">true[.....]</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class B &#123;</div><div class="line">true<span class="keyword">private</span> SomeObject someObject = C.getSomeObject();</div><div class="line"></div><div class="line">true[.....]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在测试中直接调用 C.getSomeObject() 会导致一些不可预期的错误，所以我想对AB类进行测试就必须使用Mock，于是我那么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Class ATest&#123;</div><div class="line">true<span class="meta">@Before</span></div><div class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</div><div class="line">truetruePowerMock.mockStatic(C.class)</div><div class="line">truetruePowerMock.when(C.C.getSomeObject()).thenReturn(PowerMock.mock(SomeObject.class))</div><div class="line">true&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Class BTest&#123;</div><div class="line">true<span class="meta">@Before</span></div><div class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</div><div class="line">truetruePowerMock.mockStatic(C.class)</div><div class="line">truetruePowerMock.when(C.C.getSomeObject()).thenReturn(PowerMock.mock(SomeObject.class))</div><div class="line">true&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我在IDE中分别运行 ATest 或者 BTest 是，我的测试都是能正确运行的，但是当你使用Maven或者其他的构建工具进行多线程测试的时候，你就会发现问题来了。一会是A抛异常，一会是B抛异常，总之就是不能很好的工作。由于我不是Powermockito的专家，所以无法深入的去探究这个问题的原因，但是我想，这应该是和静态方法本身在一个JVM内的唯一性有关，我截取了网上两个解释供参考：</p>
<h4 id="Explanation-1"><a href="#Explanation-1" class="headerlink" title="Explanation 1"></a>Explanation 1</h4><p>Without going into details let’s look at this code written using with Mockito :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">given(mock.doSomethingWith(eq(<span class="string">"A"</span>), longThat(...)).thenReturn(<span class="string">"C"</span>);</div></pre></td></tr></table></figure>
<p>Which is roughly equivalent to :<br>(<strong>*</strong> NEVER use a reference to OngoingStubbing in real test code, it might &gt;lead to wrong test code <strong>*</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String aString = eq(<span class="string">"A"</span>);</div><div class="line">Long aLong = longThat(...);</div><div class="line">String variableThatGiveReturnType = mock.doSomethingWith(aString, aLong);</div><div class="line">BDDOngoingStubbing&lt;String&gt; ongoingStubbing = given(variableThatGiveReturnType);</div><div class="line">ongoingStubbing.thenReturn(<span class="string">"C"</span>);</div></pre></td></tr></table></figure>
<p>The stubbing is clearly not finished until the last call thenReturn is completed, right.</p>
<p>Don’t you see the missing link between all those line to actually achieve the stubbing in a fluent way ? ;)</p>
<p>Dependening on how you do that, if you don’t synchronize this block you won’t be able to achieve any correct stubbing, otherwise concurrent access anywhere in this block will garble things in the mock internals.</p>
<p>And if you add the fact that the mock might be already used, with it’s own concurrent code to use the answers, you end up in with completely messed up internal states.</p>
<p>Anyway, always stub before using mocks concurrently.</p>
<h4 id="Explanation-2"><a href="#Explanation-2" class="headerlink" title="Explanation 2"></a>Explanation 2</h4><p>For healthy scenarios Mockito plays nicely with threads. For instance, you can run tests in parallel to speed up the build. Also, You can let multiple threads call methods on a shared mock to test in concurrent conditions. Check out a [<a href="http://mockito.googlecode.com/svn/tags/latest/javadoc/org/mockito/Mockito.html#22" target="_blank" rel="external">http://mockito.googlecode.com/svn/tags/latest/javadoc/org/mockito/Mockito.html#22</a> timeout()] feature for testing concurrency.</p>
<p>However Mockito is only thread-safe in healthy tests, that is tests without multiple threads stubbing/verifying a shared mock. Stubbing or verification of a shared mock from different threads is NOT the proper way of testing because it will always lead to intermittent behavior. In general mutable state + assertions in multi-threaded environment lead to random results. If you do stub/verify a shared mock across threads you will face occasional exceptions like: WrongTypeOfReturnValue, etc.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在修改单元测试的过程中，不幸踩了个坑，发现 Powermockito 的PowerMock.mockStatic(ClassThatContainsStaticMethod.class) 在多线程场景下是无法正常工作的，这再次验证了之前 ThrougthWorks 顾问说的那句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除非万不得已，或者是Mock遗留系统接口，否则不要使用Powermockito。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://allenn.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://allenn.cn/tags/Java/"/>
    
      <category term="单元测试" scheme="http://allenn.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X 安装 JDK备忘</title>
    <link href="http://allenn.cn/articles/2013-09/mac-install-jdk_1_6/"/>
    <id>http://allenn.cn/articles/2013-09/mac-install-jdk_1_6/</id>
    <published>2013-09-30T08:21:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装JDK1-6"><a href="#安装JDK1-6" class="headerlink" title="安装JDK1.6"></a>安装JDK1.6</h3><p>oracle官网从jdk1.7开始才有Mac版的安装包，但有的项目必须使用jdk1.6，所以必须从其他途径安装jdk1.6了。查了下发现，要想安装jdk1.6，可以直接从apple的开发者网站下安装提供的java支持包，具体下载地址 <a href="http://connect.apple.com/" target="_blank" rel="external">http://connect.apple.com/</a></p>
<a id="more"></a>
<p>详细可参见这篇文章<br><a href="http://stackoverflow.com/questions/6614380/jdk-on-osx-10-7-lion" target="_blank" rel="external">http://stackoverflow.com/questions/6614380/jdk-on-osx-10-7-lion</a></p>
<h3 id="包路径等问题"><a href="#包路径等问题" class="headerlink" title="包路径等问题"></a>包路径等问题</h3><p>系统默认安装的JRE路径<code>/System/Library/Frameworks/JavaVM.framework/</code>，oracle和apple等安装的JDK包的路径<code>/Library/Java/JavaVirtualMachines/</code></p>
<h3 id="JAVA-HOME在哪了？"><a href="#JAVA-HOME在哪了？" class="headerlink" title="JAVA_HOME在哪了？"></a>JAVA_HOME在哪了？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/Library/Java/JavaVirtualMachines/1.6.0_38-b04-436.jdk/Contents/Home</div></pre></td></tr></table></figure>
<p>注：1.6.0_38-b04-436.jdk目录名字与安装的jdk版本有关</p>
<h3 id="rt-jar、jsse-jar去哪了？"><a href="#rt-jar、jsse-jar去哪了？" class="headerlink" title="rt.jar、jsse.jar去哪了？"></a>rt.jar、jsse.jar去哪了？</h3><p>rt.jar已经集成到<code>/Library/Java/JavaVirtualMachines/1.6.0_38-b04-436.jdk/Contents/Classes/classes.jar</code>，jsse.jar也在Classes目录下</p>
<p>建议把<code>classes.jar</code>和<code>jsse.jar</code>建立软连接到<code>/Library/Java/JavaVirtualMachines/1.6.0_38-b04-436.jdk/Contents/Home/lib/</code>下，并且<code>classes.jar</code>的软连接命名为<code>rt.jar</code></p>
<p>这样就可以避免一些时候会发生找不到<code>rt.jar</code>的问题了，例如在使用混淆码的时候。</p>
<h3 id="配置JAVA-HOME"><a href="#配置JAVA-HOME" class="headerlink" title="配置JAVA_HOME"></a>配置JAVA_HOME</h3><p>Mac OS X的环境变量文件在<code>/etc/profile</code>，unix一贯重要的文件。<br>在此添加最下端添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0_38-b04-436.jdk/Contents/Home/</div><div class="line">export JAVA_HOME</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装JDK1-6&quot;&gt;&lt;a href=&quot;#安装JDK1-6&quot; class=&quot;headerlink&quot; title=&quot;安装JDK1.6&quot;&gt;&lt;/a&gt;安装JDK1.6&lt;/h3&gt;&lt;p&gt;oracle官网从jdk1.7开始才有Mac版的安装包，但有的项目必须使用jdk1.6，所以必须从其他途径安装jdk1.6了。查了下发现，要想安装jdk1.6，可以直接从apple的开发者网站下安装提供的java支持包，具体下载地址 &lt;a href=&quot;http://connect.apple.com/&quot;&gt;http://connect.apple.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日积月累" scheme="http://allenn.cn/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="JDK" scheme="http://allenn.cn/tags/JDK/"/>
    
      <category term="Macbook" scheme="http://allenn.cn/tags/Macbook/"/>
    
  </entry>
  
  <entry>
    <title>我的毕业综合症</title>
    <link href="http://allenn.cn/articles/2010-06/2010-06-20-graduate/"/>
    <id>http://allenn.cn/articles/2010-06/2010-06-20-graduate/</id>
    <published>2010-06-20T05:50:39.000Z</published>
    <updated>2017-04-06T16:00:05.643Z</updated>
    
    <content type="html"><![CDATA[<p>最近听到的消息有点多，</p>
<p>FOR EXAMPLE,</p>
<p>XX获得 UNIVERSITY XXX 的 OFFER （XXX可以替代 Cambridge，Oxford，OR Stanford etc..）。</p>
<a id="more"></a>
<p>OR</p>
<p>XX的PHD获批，一年XXXXX欧元研究经费，还不用交学费，</p>
<p>OR</p>
<p>XX雅思6+、7+，GRE 1400+……</p>
<p>P.S:暂时没有听见XX被Microsoft, Google, Ericsson, IBM, Oracle录取，不然我彻底崩溃</p>
<p>然后我就开始质疑我的选择是否正确，并纠结着是否给Dan发个邮件问他能不能赏个PHD我读读，最后开始感叹同样是人，怎么差距就那么大。</p>
<p>我开始担心三年后，我的激情是否会被相对死板的中国银行给浇灭，然后成为一个完全没有自我意识软件流水线操作员。</p>
<p>我开始担心三年后，我不在对代码感兴趣，而是对办公室里的权力斗争感兴趣，特别是在中国银行这样一个非创新性企业。</p>
<p>好吧，我承认我开始俗了，我开始担心是否有车有房，是否能为和我一同来到这个世界上的小兄弟找个港湾。</p>
<p>接着想到民工般的工资，毒贩般的工作压力，GFW，Evil的Party &amp; Gov，悲剧的中国软件业～～～</p>
<p>开始觉得有点渺茫～～</p>
<p>Jason在考试成绩公布后，在Google Talk上留下一句极其霸气的话：</p>
<p>Undergraduate is done, now its time to change the world.</p>
<p>好吧，我承认我比一个35+，并有家室，小孩的人还悲观～～</p>
<p>最后膜拜下Jason</p>
<p><img src="/assets/images//jason-gtalk.jpg" alt="Jason"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近听到的消息有点多，&lt;/p&gt;
&lt;p&gt;FOR EXAMPLE,&lt;/p&gt;
&lt;p&gt;XX获得 UNIVERSITY XXX 的 OFFER （XXX可以替代 Cambridge，Oxford，OR Stanford etc..）。&lt;/p&gt;
    
    </summary>
    
      <category term="随便乱写" scheme="http://allenn.cn/categories/%E9%9A%8F%E4%BE%BF%E4%B9%B1%E5%86%99/"/>
    
    
      <category term="吐槽" scheme="http://allenn.cn/tags/%E5%90%90%E6%A7%BD/"/>
    
      <category term="毕业" scheme="http://allenn.cn/tags/%E6%AF%95%E4%B8%9A/"/>
    
  </entry>
  
</feed>
